<?xml version="1.0"?>
<javascript>
  <class type="dijit">
    <methods>
      <method name="showTooltip" scope="instance">
        <description>Display tooltip w/specified contents in specified position.
	See description of dijit.Tooltip.defaultPosition for details on position parameter.
	If position is not specified then dijit.Tooltip.defaultPosition is used.</description>
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="instance">
        <description>hide the tooltip</description>
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectOnUseEventHandler" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isCollapsed" scope="instance">
        <description>tests whether the current selection is empty</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getBookmark" scope="instance">
        <description>Retrieves a bookmark that can be used with moveToBookmark to return to the same range</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="moveToBookmark" scope="instance">
        <description>Moves current selection to a bookmark</description>
        <parameters>
          <parameter name="bookmark" type="Object" usage="required">
            <description>This should be a returned object from dojo.html.selection.getBookmark()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFocus" scope="instance">
        <description>Returns the current focus and selection.
	Called when a popup appears (either a top level menu or a dialog),
	or when a toolbar/menubar receives focus</description>
        <parameters>
          <parameter name="menu" type="Widget" usage="optional">
            <description>The menu that's being opened</description>
          </parameter>
          <parameter name="openedForWindow" type="Window" usage="optional">
            <description>iframe in which menu was opened</description>
          </parameter>
        </parameters>
        <return-description>A handle to restore focus/selection</return-description>
      </method>
      <method name="focus" scope="instance">
        <description>Sets the focused node and the selection according to argument.
	To set focus to an iframe's content, pass in the iframe itself.</description>
        <parameters>
          <parameter name="handle" type="Object || DomNode" usage="required">
            <description>object returned by get(), or a DomNode</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerWin" scope="instance">
        <description>Registers listeners on the specified window (either the main
	window or an iframe) to detect when the user has clicked somewhere.
	Anyone that creates an iframe should call this function.</description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional"/>
        </parameters>
      </method>
      <method name="_onBlurNode" scope="instance">
        <description>Called when focus leaves a node.
	Usually ignored, _unless_ it *isn't* follwed by touching another node,
	which indicates that we tabbed off the last field on the page,
	in which case every widget is marked inactive</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onTouchNode" scope="instance">
        <description>Callback when node is focused or mouse-downed</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setStack" scope="instance">
        <parameters>
          <parameter name="newStack" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getUniqueId" scope="instance">
        <parameters>
          <parameter name="widgetType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <description>Returns a widget by its id, or if passed a widget, no-op (like dojo.byId())</description>
        <parameters>
          <parameter name="id" type="String|Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="byNode" scope="instance">
        <description>Returns the widget as referenced by node</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="getEnclosingWidget" scope="instance">
        <description>Returns the widget whose dom tree contains node or null if
	the node is not contained within the dom tree of any widget</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_isElementShown" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="isTabNavigable" scope="instance">
        <description>Tests if an element is tab-navigable</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_getTabNavigable" scope="instance">
        <description>Finds the following descendants of the specified root node:
	* the first tab-navigable element in document order
	without a tabindex or with tabindex=&amp;quot;0&amp;quot;
	* the last tab-navigable element in document order
	without a tabindex or with tabindex=&amp;quot;0&amp;quot;
	* the first element in document order with the lowest
	positive tabindex value
	* the last element in document order with the highest
	positive tabindex value</description>
        <parameters>
          <parameter name="root" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstInTabbingOrder" scope="instance">
        <description>Finds the descendant of the specified root node
	that is first in the tabbing order</description>
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Element"/>
        </return-types>
      </method>
      <method name="getLastInTabbingOrder" scope="instance">
        <description>Finds the descendant of the specified root node
	that is last in the tabbing order</description>
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Element"/>
        </return-types>
      </method>
      <method name="getViewport" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="placeOnScreen" scope="instance">
        <description>Positions one of the node's corners at specified position
	such that node is fully visible in viewport.</description>
        <example>Try to place node's top right corner at (10,20).
	If that makes node go (partially) off screen, then try placing
	bottom left corner at (10,20).
		placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])</example>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="dijit.__Position" usage="required">
            <description>Object like {x: 10, y: 20}</description>
          </parameter>
          <parameter name="corners" type="String[]" usage="required">
            <description>Array of Strings representing order to try corners in, like [&amp;quot;TR&amp;quot;, &amp;quot;BL&amp;quot;].
	Possible values are:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</description>
          </parameter>
          <parameter name="tryOnly" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_place" scope="instance">
        <description>Given a list of spots to put node, put it at the first spot where it fits,
	of if it doesn't fit anywhere then the place with the least overflow</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="choices" type="Array" usage="required">
            <description>of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	Above example says to put the top-left corner of the node at (10,20)</description>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="required">
            <description>(node aroundNodeCorner, nodeCorner)
	for things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.   This adjusts the popup based on orientation.</description>
          </parameter>
        </parameters>
      </method>
      <method name="placeOnScreenAroundNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundRectangle" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundRect" type="dijit.__Rectangle" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_placeOnScreenAroundRect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="height" type="Number" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundElement" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiRole" scope="instance">
        <description>Determines if an element has a particular non-XHTML role.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
        <return-description>true if elem has the specific non-XHTML role attribute and false if not.
	for backwards compatibility if role parameter not provided,
	returns true if has non XHTML role</return-description>
      </method>
      <method name="getWaiRole" scope="instance">
        <description>Gets the non-XHTML role for an element (which should be a wai role).</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-description>The non-XHTML role of elem or an empty string if elem
	does not have a role.</return-description>
      </method>
      <method name="setWaiRole" scope="instance">
        <description>Sets the role on an element.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiRole" scope="instance">
        <description>Removes the specified non-XHTML role from an element.
	removes role attribute if no specific role provided (for backwards compat.)</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiState" scope="instance">
        <description>Determines if an element has a given state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>true if elem has a value for the given state and
	false if it does not.</return-description>
        <return-types>
          <return-type type="www.w3.org/2005/07/aaa&quot;, state);"/>
        </return-types>
      </method>
      <method name="getWaiState" scope="instance">
        <description>Gets the value of a state on an element.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>The value of the requested state on elem
	or an empty string if elem has no value for state.</return-description>
        <return-types>
          <return-type type="www.w3.org/2005/07/aaa&quot;, state);"/>
        </return-types>
      </method>
      <method name="setWaiState" scope="instance">
        <description>Sets a state on an element.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiState" scope="instance">
        <description>Removes a state from an element.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getDocumentWindow" scope="instance">
        <description>Get window object associated with document doc</description>
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="selectInputText" scope="instance">
        <description>Select text in the input element argument, from start (default 0), to stop (default end).</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_curFocus" scope="instance" type="Object"/>
      <property name="_prevFocus" scope="instance" type="Object"/>
      <property name="_activeStack" scope="instance" type="Object"/>
      <property name="registry" scope="instance" type="Object">
        <description>A list of widgets on a page.</description>
      </property>
      <property name="_widgetTypeCtr" scope="instance" type="Object"/>
      <property name="defaultDuration" scope="instance" type="Object"/>
      <property name="placementRegistry" scope="instance" type="Object"/>
      <property name="_XhtmlRoles" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="dijit-all" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object">
        <description>A roll-up for common dijit methods</description>
      </property>
    </properties>
  </class>
  <class type="dijit.ColorPalette" superclass="dijit._Widget">
    <description>A keyboard accessible color-picking widget</description>
    <example>
		&lt;div dojoType="dijit.ColorPalette"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="focus" scope="prototype">
        <description>Focus this ColorPalette.  Puts focus on the first swatch.</description>
      </method>
      <method name="onChange" scope="prototype">
        <description>Callback when a color is selected.</description>
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>Hex value corresponding to color.
	console.debug(&amp;quot;Color selected is: &amp;quot;+color);</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusFirst" scope="prototype"/>
      <method name="_onDivNodeFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype"/>
      <method name="_onBlur" scope="prototype"/>
      <method name="_onCellDijitclick" scope="prototype">
        <description>Handler for click, enter key &amp;amp; space key. Selects the color.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="prototype">
        <description>Handler for onMouseOver. Put focus on the color under the mouse.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The mouse event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellFocus" scope="prototype">
        <description>Handler for onFocus. Removes highlight of
	the color that just lost focus, and highlights
	the new color.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The focus event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="prototype">
        <description>Called when color is hovered or focused.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onCellBlur" scope="prototype">
        <description>needed for Firefox 2 on Mac OS X</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_removeCellHighlight" scope="prototype">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectColor" scope="prototype">
        <description>This selects a color. It triggers the onChange event
	area:
	The area node that covers the color being selected.</description>
        <parameters>
          <parameter name="selectNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="prototype">
        <description>This is the callback for typematic.
	It changes the focus and the highlighed color.</description>
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <description>much the key is navigated.</description>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <description>many times typematic has fired.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="prototype" type="Number">
        <description>number of milliseconds before a held key or button becomes typematic</description>
      </property>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <description>fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</description>
      </property>
      <property name="palette" scope="prototype" type="String">
        <description>Size of grid, either &amp;quot;7x10&amp;quot; or &amp;quot;3x4&amp;quot;.</description>
      </property>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="_currentFocus" scope="instance-prototype" type="Integer">
        <description>Index of the currently focused color.</description>
      </property>
      <property name="_xDim" scope="instance-prototype" type="Integer">
        <description>This is the number of colors horizontally across.</description>
      </property>
      <property name="_yDim" scope="instance-prototype" type="Integer">
        <description>/		This is the number of colors vertically down.</description>
      </property>
      <property name="templatePath" scope="prototype" type="String">
        <description>Path to the template of this widget.</description>
      </property>
      <property name="tabIndex" scope="prototype" type="String">
        <description>Widget tabindex.</description>
      </property>
      <property name="_cellNodes" scope="instance" type="Object"/>
      <property name="colorNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._palettes">
    <description>This represents the value of the colors.
	The first level is a hashmap of the different arrays available
	The next two dimensions represent the columns and rows of colors.</description>
    <properties>
      <property name="7x10" scope="instance" type="Object"/>
      <property name="3x4" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._imagePaths">
    <description>This is stores the path to the palette images</description>
    <properties>
      <property name="7x10" scope="instance" type="Object"/>
      <property name="3x4" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._paletteCoords">
    <description>This is a map that is used to calculate the coordinates of the
	images that make up the palette.</description>
    <properties>
      <property name="leftOffset" scope="instance" type="Object"/>
      <property name="topOffset" scope="instance" type="Object"/>
      <property name="cWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._paletteDims.7x10">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._paletteDims">
    <description>Size of the supported palettes for alignment purposes.</description>
  </class>
  <class type="dijit.ColorPalette._paletteDims.3x4">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette.domNode.style">
    <properties>
      <property name="position" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="this.divNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Declaration" superclass="dijit._Widget">
    <description>The Declaration widget allows a user to declare new widget
	classes directly from a snippet of markup.</description>
    <methods>
      <method name="buildRendering" scope="prototype"/>
    </methods>
    <properties>
      <property name="_noScript" scope="prototype" type="Object"/>
      <property name="widgetClass" scope="prototype" type="Object"/>
      <property name="replaceVars" scope="prototype" type="Object"/>
      <property name="defaults" scope="prototype" type="Object"/>
      <property name="mixins" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay" superclass="dijit._Widget">
    <description>The component that grays out the screen behind the dialog
	Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
	Inner div has opacity specified in CSS file.</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Append the underlay to the body</description>
      </method>
      <method name="layout" scope="prototype">
        <description>Sets the background to the size of the viewport</description>
      </method>
      <method name="show" scope="prototype">
        <description>Show the dialog underlay</description>
      </method>
      <method name="hide" scope="prototype">
        <description>hides the dialog underlay</description>
      </method>
      <method name="uninitialize" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.bgIframe.iframe.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._DialogMixin">
    <methods>
      <method name="execute" scope="prototype">
        <description>User defined function to do stuff when the user hits the submit button</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <description>Callback when user has canceled dialog, to notify container
	(user shouldn't override)</description>
      </method>
      <method name="onExecute" scope="prototype">
        <description>Callback when user is about to execute dialog, to notify container
	(user shouldn't override)</description>
      </method>
      <method name="_onSubmit" scope="prototype">
        <description>callback when user hits submit button</description>
      </method>
      <method name="_getFocusItems" scope="prototype">
        <parameters>
          <parameter name="dialogNode" type="Node" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_firstFocusItem" scope="instance" type="Object"/>
      <property name="_lastFocusItem" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Dialog" superclass="dijit.layout.ContentPane">
    <description>A modal dialog Widget</description>
    <example>
		&lt;div dojoType="dijit.Dialog" href="test.html"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onLoad" scope="prototype">
        <description>when href is specified we need to reposition the dialog after the data is loaded</description>
      </method>
      <method name="_endDrag" scope="prototype">
        <description>Called after dragging the Dialog. Calculates the relative offset
	of the Dialog in relation to the viewport.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="prototype">
        <description>stuff we need to do before showing the Dialog for the first
	time (but we defer it until right beforehand, for
	performance reasons)</description>
      </method>
      <method name="uninitialize" scope="prototype"/>
      <method name="_size" scope="prototype">
        <description>Make sure the dialog is small enough to fit in viewport.</description>
      </method>
      <method name="_position" scope="prototype">
        <description>Position modal dialog in the viewport. If no relative offset
	in the viewport has been determined (by dragging, for instance),
	center the node. Otherwise, use the Dialog's stored relative offset,
	and position the node to top: left: values based on the viewport.</description>
      </method>
      <method name="_onKey" scope="prototype">
        <description>handles the keyboard events for accessibility reasons</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="just let it go"/>
        </return-types>
      </method>
      <method name="show" scope="prototype">
        <description>display the dialog</description>
      </method>
      <method name="hide" scope="prototype">
        <description>Hide the dialog</description>
      </method>
      <method name="layout" scope="prototype">
        <description>Position the Dialog and the underlay</description>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit.form._FormMixin" scope="prototype"/>
      <mixin type="dijit._DialogMixin" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="open" scope="instance-prototype" type="Boolean">
        <description>is True or False depending on state of dialog</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>The time in milliseconds it takes the dialog to fade in and out</description>
      </property>
      <property name="refocus" scope="prototype" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to re-focus the element which had focus before being opened.
	False will disable refocusing. Default: true</description>
      </property>
      <property name="autofocus" scope="prototype" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</description>
      </property>
      <property name="_firstFocusItem" scope="instance-prototype" type="DomNode">
        <description>The pointer to the first focusable node in the dialog</description>
      </property>
      <property name="_lastFocusItem" scope="prototype" type="DomNode">
        <description>The pointer to which node has focus prior to our dialog</description>
      </property>
      <property name="doLayout" scope="prototype" type="Boolean">
        <description>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for Dialog, since Dialog
	is never a child of a layout container, nor can you specify the size of
	Dialog in order to control the size of an inner widget.</description>
      </property>
      <property name="draggable" scope="prototype" type="Boolean">
        <description>Toggles the moveable aspect of the Dialog. If true, Dialog
	can be moved by it's title. If false it will remain centered
	in the viewport.</description>
      </property>
      <property name="_modalconnects" scope="instance" type="Object"/>
      <property name="_relativePosition" scope="instance" type="Object"/>
      <property name="_moveable" scope="instance" type="Object"/>
      <property name="_underlay" scope="instance" type="Object"/>
      <property name="_fadeIn" scope="instance" type="Object"/>
      <property name="_fadeOut" scope="instance" type="Object"/>
      <property name="_alreadyInitialized" scope="instance" type="Object"/>
      <property name="_savedFocus" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog" superclass="dijit.layout.ContentPane">
    <description>Pops up a dialog that appears like a Tooltip</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="orient" scope="prototype">
        <description>configure widget to be displayed in given position relative to the button</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="corner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <description>called when dialog is displayed</description>
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <description>keep keyboard focus in dialog; close dialog on escape key</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit.form._FormMixin" scope="prototype"/>
      <mixin type="dijit._DialogMixin" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String">
        <description>Description of tooltip dialog (required for a11Y)</description>
      </property>
      <property name="doLayout" scope="prototype" type="Boolean">
        <description>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
	is never a child of a layout container, nor can you specify the size of
	TooltipDialog in order to control the size of an inner widget.</description>
      </property>
      <property name="autofocus" scope="prototype" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</description>
      </property>
      <property name="class" scope="prototype" type="Object"/>
      <property name="_firstFocusItem" scope="instance-prototype" type="DomNode">
        <description>The pointer to the first focusable node in the dialog</description>
      </property>
      <property name="_lastFocusItem" scope="prototype" type="DomNode">
        <description>The domNode that had focus before we took it.</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog.containerNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Editor" superclass="dijit._editor.RichText">
    <description>A rich text Editing widget</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="addPlugin" scope="prototype">
        <description>takes a plugin name as a string or a plugin instance and
	adds it to the toolbar and associates it with this editor
	instance. The resulting plugin is added to the Editor's
	plugins array. If index is passed, it's placed in the plugins
	array at that index. No big magic, but a nice helper for
	passing in plugin names via markup.</description>
        <parameters>
          <parameter name="plugin" type="String||Object" usage="required">
            <description>String args object or plugin instance
	args: This object will be passed to the plugin constructor</description>
          </parameter>
          <parameter name="index" type="Integer" usage="optional">
            <description>Used when creating an instance from
	something already in this.plugins. Ensures that the new
	instance is assigned to this.plugins at that index.</description>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="layout" scope="prototype"/>
      <method name="onBeforeDeactivate" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginEditing" scope="prototype">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="plugins" scope="instance-prototype" type="Object"/>
      <property name="extraPlugins" scope="prototype" type="Array">
        <description>a list of extra plugin names which will be appended to plugins array</description>
      </property>
      <property name="customUndo" scope="prototype" type="Object"/>
      <property name="editActionInterval" scope="prototype" type="Integer">
        <description>When using customUndo, not every keystroke will be saved as a step.
	Instead typing (including delete) will be grouped together: after
	a user stop typing for editActionInterval seconds, a step will be
	saved; if a user resume typing within editActionInterval seconds,
	the timeout will be restarted. By default, editActionInterval is 3
	seconds.</description>
      </property>
      <property name="_steps" scope="instance-prototype" type="Object"/>
      <property name="_undoedSteps" scope="instance" type="Object"/>
      <property name="commands" scope="instance" type="Object"/>
      <property name="toolbar" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance" type="Object"/>
      <property name="_layoutMode" scope="instance" type="Object"/>
      <property name="_inEditing" scope="instance" type="Object"/>
      <property name="_editTimer" scope="instance" type="Object"/>
      <property name="_editInterval" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Editor.editingArea.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Editor.iframe.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="o">
    <properties>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox" superclass="dijit._Widget">
    <description>An element with in-line edit capabilitites</description>
    <methods>
      <method name="onChange" scope="prototype">
        <description>User should set this handler to be notified of changes to value</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <description>User should set this handler to be notified when no change occured</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="setDisabled" scope="prototype">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;disabled&amp;quot;, ...) work.
	Set disabled state of widget.</description>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="prototype"/>
      <method name="_onMouseOut" scope="prototype"/>
      <method name="_onClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="edit" scope="prototype">
        <description>Display the editor widget in place of the original (read only) markup.</description>
      </method>
      <method name="_showText" scope="prototype">
        <description>revert to display mode, and optionally focus on display node</description>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <description>Save the contents of the editor and revert to display mode.</description>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <description>Focus on the display mode text</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;value&amp;quot;, ...) work.
	Inserts specified HTML value into this node, or an &amp;quot;input needed&amp;quot; character if node is blank.</description>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype"/>
      <method name="cancel" scope="prototype">
        <description>Revert to display mode, discarding any changes made in the editor</description>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editing" scope="instance-prototype" type="Object"/>
      <property name="autoSave" scope="prototype" type="Boolean">
        <description>Changing the value automatically saves it; don't have to push save button
	(and save button isn't even displayed)</description>
      </property>
      <property name="buttonSave" scope="prototype" type="String">
        <description>Save button label</description>
      </property>
      <property name="buttonCancel" scope="prototype" type="String">
        <description>Cancel button label</description>
      </property>
      <property name="renderAsHtml" scope="prototype" type="Boolean">
        <description>Set this to true if the specified Editor's value should be interpreted as HTML
	rather than plain text (ie, dijit.Editor)</description>
      </property>
      <property name="editor" scope="prototype" type="String">
        <description>Class name for Editor widget</description>
      </property>
      <property name="editorParams" scope="instance-prototype" type="Object">
        <description>Set of parameters for editor, like {required: true}</description>
      </property>
      <property name="width" scope="prototype" type="String">
        <description>Width of editor.  By default it's width=100% (ie, block mode)</description>
      </property>
      <property name="value" scope="instance-prototype" type="String">
        <description>The display value of the widget in read-only mode</description>
      </property>
      <property name="noValueIndicator" scope="prototype" type="String">
        <description>The text that gets displayed when there is no value (so that the user has a place to click to edit)</description>
      </property>
      <property name="disabled" scope="instance" type="Object"/>
      <property name="editWidget" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.displayNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.displayNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor" superclass="dijit._Widget">
    <description>internal widget used by InlineEditBox, displayed when in editing mode
	to display the editor and maybe save/cancel buttons.  Calling code should
	connect to save/cancel methods to detect when editing is finished
	Has mainly the same parameters as InlineEditBox, plus these values:
	style: Object
	Set of CSS attributes of display node, to replicate in editor
	value: String
	Value as an HTML string or plain text string, depending on renderAsHTML flag</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="getValue" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <description>Callback when keypress in the edit box (see template).</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>Called when focus moves outside the editor</description>
      </method>
      <method name="_onChange" scope="prototype">
        <description>Called when the underlying widget fires an onChange event,
	which means that the user has finished entering the value</description>
      </method>
      <method name="enableSave" scope="prototype">
        <description>User replacable function returning a Boolean to indicate
	if the Save button should be enabled or not - usually due to invalid conditions</description>
      </method>
      <method name="focus" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="messages" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="editWidget" scope="instance" type="Object"/>
      <property name="_exitInProgress" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.editorParams">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.buttonContainer.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Menu" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="onExecute" scope="prototype">
        <description>attach point for notification about when a menu item has been executed</description>
      </method>
      <method name="onCancel" scope="prototype">
        <description>attach point for notification about when the user cancels the current menu</description>
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToPopup" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <description>Handle keyboard based menu navigation.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemHover" scope="prototype">
        <description>Called when cursor is over a MenuItem</description>
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="prototype">
        <description>Close all popups that are open and descendants of this menu</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onItemUnhover" scope="prototype">
        <description>Callback fires when mouse exits a MenuItem</description>
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_stopPopupTimer" scope="prototype"/>
      <method name="_getTopMenu" scope="prototype"/>
      <method name="onItemClick" scope="prototype">
        <description>user defined function to handle clicks on an item</description>
        <parameters>
          <parameter name="item" type="Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeContentWindow" scope="prototype">
        <description>Returns the window reference of the passed iframe</description>
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="_iframeContentDocument" scope="prototype">
        <description>Returns a reference to the document object inside iframe_el</description>
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="HTMLDocument"/>
        </return-types>
      </method>
      <method name="bindDomNode" scope="prototype">
        <description>attach menu to given node</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="unBindDomNode" scope="prototype">
        <description>detach menu from given node</description>
        <parameters>
          <parameter name="nodeName" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_contextKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_contextMouse" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <description>Open menu relative to the mouse</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="prototype">
        <description>callback when this menu is closed</description>
      </method>
      <method name="_openPopup" scope="prototype">
        <description>open the popup to the side of the current menu item</description>
      </method>
      <method name="uninitialize" scope="prototype"/>
      <method name="getPlaceholders" scope="prototype">
        <description>returns an array of placeholders with the given label.  There
	can be multiples.</description>
        <parameters>
          <parameter name="label" type="String" usage="optional">
            <description>Label to search for - if not specified, then all placeholders
	are returned</description>
          </parameter>
        </parameters>
        <return-description>An array of placeholders that match the given label</return-description>
        <return-types>
          <return-type type="dojox.widget.PlaceholderMenuItem[]"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._KeyNavContainer" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="targetNodeIds" scope="prototype" type="String[]">
        <description>Array of dom node ids of nodes to attach to.
	Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.</description>
      </property>
      <property name="contextMenuForWindow" scope="prototype" type="Boolean">
        <description>if true, right clicking anywhere on the window will cause this context menu to open;
	if false, must specify targetNodeIds</description>
      </property>
      <property name="leftClickToOpen" scope="prototype" type="Boolean">
        <description>If true, menu will open on left click instead of right click, similiar to a file menu.</description>
      </property>
      <property name="parentMenu" scope="instance-prototype" type="Widget">
        <description>pointer to menu that displayed me</description>
      </property>
      <property name="popupDelay" scope="prototype" type="Integer">
        <description>number of milliseconds before hovering (without clicking) causes the popup to automatically open</description>
      </property>
      <property name="_contextMenuWithMouse" scope="instance-prototype" type="Boolean">
        <description>used to record mouse and keyboard events to determine if a context
	menu is being opened with the keyboard or the mouse</description>
      </property>
      <property name="hover_timer" scope="instance" type="Object"/>
      <property name="_onBlur" scope="instance" type="Object"/>
      <property name="isShowingNow" scope="instance" type="Object"/>
      <property name="currentPopup" scope="instance" type="Object"/>
      <property name="focusedChild" scope="instance" type="Object"/>
      <property name="_bindings" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Menu._openMyself">
    <description>Internal function for opening myself when the user
	does a right-click or something similar</description>
    <methods>
      <method name="_onBlur" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.MenuItem" superclass="dijit._Widget">
    <description>A line item in a Menu Widget</description>
    <methods>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_onHover" scope="prototype">
        <description>callback when mouse is moved onto menu item</description>
      </method>
      <method name="_onUnhover" scope="prototype">
        <description>callback when mouse is moved off of menu item</description>
      </method>
      <method name="_onClick" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>User defined function to handle clicks</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype"/>
      <method name="_blur" scope="prototype"/>
      <method name="setLabel" scope="prototype">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <description>Hook for attr('disabled', ...) to work.
	Enable or disable this menu item.</description>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type="String">
        <description>menu text</description>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <description>Class to apply to div in button to make it display an icon</description>
      </property>
      <property name="disabled" scope="instance-prototype" type="Boolean">
        <description>if true, the menu item is disabled
	if false, the menu item is enabled</description>
      </property>
    </properties>
  </class>
  <class type="dijit.PopupMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="_fillContent" scope="prototype">
        <description>The innerHTML contains both the menu item text and a popup widget</description>
        <example>
		&lt;div dojoType="dijit.PopupMenuItem"&gt;
			&lt;span&gt;pick me&lt;/span&gt;
			&lt;popup&gt; ... &lt;/popup&gt;
		&lt;/div&gt;</example>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="destroyDescendants" scope="prototype"/>
    </methods>
    <properties>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.PopupMenuItem.popup.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuSeparator" superclass="dijit._Widget">
    <description>A line between two menu items</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="isFocusable" scope="prototype">
        <description>over ride to always return false</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.CheckedMenuItem" superclass="dijit.MenuItem">
    <description>a checkbox-like menu item for toggling on and off</description>
    <methods>
      <method name="_setCheckedAttr" scope="prototype">
        <description>Hook so attr('checked', bool) works.
	Sets the class and state for the check box.</description>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>User defined function to handle change events</description>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <description>Clicking this item just toggles its state</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="checked" scope="instance-prototype" type="Boolean">
        <description>Our checked state</description>
      </property>
    </properties>
  </class>
  <class type="dijit.ProgressBar" superclass="dijit._Widget">
    <description>A progress indication widget</description>
    <example>
		&lt;div dojoType="ProgressBar"
			 places="0"
			 progress="..." maximum="..."&gt;
		&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="update" scope="prototype">
        <description>update progress information</description>
        <parameters>
          <parameter name="attributes" type="Object" usage="optional">
            <description>may provide progress and/or maximum properties on this parameter,
	see attribute specs for details.</description>
          </parameter>
        </parameters>
      </method>
      <method name="report" scope="prototype">
        <description>Generates message to show; may be overridden by user</description>
        <parameters>
          <parameter name="percent" type="float" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>User definable function fired when progress updates.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="progress" scope="instance-prototype" type="String">
        <description>(Percentage or Number)
	initial progress value.
	with &amp;quot;%&amp;quot;: percentage value, 0% &amp;lt;= progress &amp;lt;= 100%
	or without &amp;quot;%&amp;quot;: absolute value, 0 &amp;lt;= progress &amp;lt;= maximum</description>
      </property>
      <property name="maximum" scope="prototype" type="Float">
        <description>max sample number</description>
      </property>
      <property name="places" scope="prototype" type="Number">
        <description>number of places to show in values; 0 by default</description>
      </property>
      <property name="indeterminate" scope="prototype" type="Boolean">
        <description>If false: show progress.
	If true: show that a process is underway but that the progress is unknown</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_indeterminateHighContrastImagePath" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.label.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane" superclass="dijit.layout.ContentPane">
    <description>A pane with a title on top, that can be opened or collapsed.</description>
    <example>
	 	// load a TitlePane from remote file:
		var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
		foo.startup();</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_setOpenAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;open&amp;quot;, boolean) control the open/closed state of the pane.</description>
        <parameters>
          <parameter name="open" type="Boolean" usage="required">
            <description>True if you want to open the pane, false if you want to close it.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;content&amp;quot;, ...) work.
	Typically called when an href is loaded.  Our job is to make the animation smooth</description>
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <description>switches between opened and closed state</description>
      </method>
      <method name="_setCss" scope="prototype">
        <description>set the open/close css state for the TitlePane</description>
      </method>
      <method name="_onTitleKey" scope="prototype">
        <description>callback when user hits a key</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleFocus" scope="prototype">
        <description>handle blur and focus for this widget
	add/removeClass is safe to call without hasClass in this case</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <description>sets the text of the title</description>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="Object"/>
      <property name="open" scope="instance-prototype" type="Boolean">
        <description>Whether pane is opened or closed.</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>Time in milliseconds to fade in/fade out</description>
      </property>
      <property name="baseClass" scope="prototype" type="String">
        <description>The root className to use for the various states of this widget</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_wipeIn" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.hideNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane._hideNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.arrowNodeInner">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Toolbar" superclass="dijit._Widget">
    <description>A Toolbar widget, used to hold things like dijit.Editor buttons</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._KeyNavContainer" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="tabIndex" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ToolbarSeparator" superclass="dijit._Widget">
    <description>A spacer between two Toolbar items</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="isFocusable" scope="prototype">
        <description>This widget isn't focusable, so pass along that fact.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="show" scope="prototype">
        <description>Display tooltip w/specified contents to right specified node
	(To left if there's no space on the right, or if LTR==right)</description>
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
        </parameters>
      </method>
      <method name="orient" scope="prototype">
        <description>private function to set CSS for tooltip node based on which position it's in</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="tooltipCorner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="prototype"/>
      <method name="hide" scope="prototype">
        <description>hide the tooltip</description>
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHide" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="fadeIn" scope="instance" type="Object"/>
      <property name="fadeOut" scope="instance" type="Object"/>
      <property name="aroundNode" scope="instance" type="Object"/>
      <property name="_onDeck" scope="instance" type="Object"/>
      <property name="isShowingNow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode.style">
    <properties>
      <property name="top" scope="instance" type="Object"/>
      <property name="filter" scope="instance" type="Object"/>
      <property name="cssText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tooltip" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_onMouseEnter" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHover" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnHover" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="prototype">
        <description>display the tooltip; usually not called directly.</description>
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>hide the tooltip or cancel timer for show of tooltip</description>
      </method>
      <method name="uninitialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="label" scope="prototype" type="Object"/>
      <property name="showDelay" scope="prototype" type="Integer">
        <description>Number of milliseconds to wait after hovering over/focusing on the object, before
	the tooltip is displayed.</description>
      </property>
      <property name="connectId" scope="prototype" type="String[]">
        <description>Id(s) of domNodes to attach the tooltip to.
	When user hovers over any of the specified dom nodes, the tooltip will appear.</description>
      </property>
      <property name="position" scope="prototype" type="String[]">
        <description>See description of dijit.Tooltip.defaultPosition for details on position parameter.</description>
      </property>
      <property name="_connectNodes" scope="instance" type="Object"/>
      <property name="_focus" scope="instance" type="Object"/>
      <property name="_showTimer" scope="instance" type="Object"/>
      <property name="_connectNode" scope="instance" type="Object"/>
      <property name="defaultPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode" superclass="dijit._Widget">
    <description>Single node within a tree</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="markProcessing" scope="prototype">
        <description>visually denote that tree is loading data, etc.</description>
      </method>
      <method name="unmarkProcessing" scope="prototype">
        <description>clear markup from markProcessing() call</description>
      </method>
      <method name="_updateItemClasses" scope="prototype">
        <description>set appropriate CSS classes for icon and label dom node (used to allow for item updates to change respective CSS)</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateLayout" scope="prototype">
        <description>set appropriate CSS classes for this.domNode</description>
      </method>
      <method name="_setExpando" scope="prototype">
        <description>set the right image for the expando node</description>
        <parameters>
          <parameter name="processing" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="prototype">
        <description>show my children</description>
      </method>
      <method name="collapse" scope="prototype"/>
      <method name="setLabelNode" scope="prototype">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setChildItems" scope="prototype">
        <description>Sets the child items of this node, removing/adding nodes
	from current children to match specified items[] array.</description>
        <parameters>
          <parameter name="items" type="Object[]" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="node" type="treeNode" usage="required"/>
        </parameters>
      </method>
      <method name="makeExpandable" scope="prototype">
        <description>if this node wasn't already showing the expando node,
	turn it into one and call _setExpando()</description>
      </method>
      <method name="_onNodeFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="item" scope="prototype" type="Object"/>
      <property name="isTreeNode" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type="String">
        <description>Text of this tree node</description>
      </property>
      <property name="isExpandable" scope="instance-prototype" type="Object"/>
      <property name="isExpanded" scope="instance-prototype" type="Object"/>
      <property name="state" scope="instance-prototype" type="String">
        <description>dynamic loading-related stuff.
	When an empty folder node appears, it is &amp;quot;UNCHECKED&amp;quot; first,
	then after dojo.data query it becomes &amp;quot;LOADING&amp;quot; and, finally &amp;quot;LOADED&amp;quot;</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_wipeIn" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.iconNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.labelNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.expandoNodeText">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.contentNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tree" superclass="dijit._Widget">
    <description>This widget displays hierarchical data from a store.  A query is specified
	to get the &amp;quot;top level children&amp;quot; from a data store, and then those items are
	queried for their children and so on (but lazily, as the user clicks the expand node).
	Thus in the default mode of operation this widget is technically a forest, not a tree,
	in that there can be multiple &amp;quot;top level children&amp;quot;.  However, if you specify label,
	then a special top level node (not corresponding to any item in the datastore) is
	created, to father all the top level children.</description>
    <example>{type:'continent'}</example>
    <methods>
      <method name="_publish" scope="prototype">
        <description>Publish a message for this widget/topic</description>
        <parameters>
          <parameter name="topicName" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_store2model" scope="prototype">
        <description>user specified a store&amp;amp;query rather than model, so create model from store/query</description>
      </method>
      <method name="_load" scope="prototype">
        <description>initial load of the tree
	load root node (possibly hidden) and it's children</description>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <description>User overridable function to tell if an item has or may have children.
	Controls whether or not +/- expando icon is shown.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getItemChildren" scope="prototype">
        <description>User overridable function that return array of child items of given parent item,
	or if parentItem==null then return top items in tree</description>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>user overridable function to get the label for a tree node (given the item)</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIconClass" scope="prototype">
        <description>user overridable function to return CSS class name to display icon</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelClass" scope="prototype">
        <description>user overridable function to return CSS class name to display label</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <description>translates keypress events into commands for the controller</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterKey" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDownArrow" scope="prototype">
        <description>down arrow pressed; get next visible node, set focus there</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpArrow" scope="prototype">
        <description>up arrow pressed; move to previous visible node</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRightArrow" scope="prototype">
        <description>right arrow pressed; go to child node</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeftArrow" scope="prototype">
        <description>Left arrow pressed.
	If not collapsed, collapse, else move to parent.</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHomeKey" scope="prototype">
        <description>home pressed; get first visible node, set focus there</description>
      </method>
      <method name="_onEndKey" scope="prototype">
        <description>end pressed; go to last visible node</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLetterKeyNav" scope="prototype">
        <description>letter key pressed; search for node starting with first char = key</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <description>translates click events into commands for the controller to process</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoClick" scope="prototype">
        <description>user clicked the +/- icon; expand or collapse my children.</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>user overridable function for executing a tree item</description>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <description>callback when a node is opened</description>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="prototype">
        <description>callback when a node is closed</description>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextNode" scope="prototype">
        <description>get next visible node</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_TreeNode"/>
        </return-types>
      </method>
      <method name="_getRootOrFirstNode" scope="prototype">
        <description>get first visible node</description>
      </method>
      <method name="_collapseNode" scope="prototype">
        <description>called when the user has requested to collapse the node</description>
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_expandNode" scope="prototype">
        <description>called when the user has requested to expand the node</description>
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="blurNode" scope="prototype">
        <description>Removes focus from the currently focused node (which must be visible).
	Usually not called directly (just call focusNode() on another node instead)</description>
      </method>
      <method name="focusNode" scope="prototype">
        <description>Focus on the specified node (which must be visible)</description>
        <parameters>
          <parameter name="node" type="_tree.Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>We've moved away from the whole tree.  The currently &amp;quot;focused&amp;quot; node
	(see focusNode above) should remain as the lastFocused node so we can
	tab back into the tree.  Just change CSS to get rid of the dotted border
	until that time</description>
      </method>
      <method name="_onTreeFocus" scope="prototype">
        <description>called from onFocus handler of treeitem labelNode to set styles, wai state and tabindex
	for currently focused treeitem.</description>
        <parameters>
          <parameter name="node" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemDelete" scope="prototype">
        <description>processes notification of a deletion of an item</description>
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="prototype">
        <description>processes notification of a change to an item's scalar values like label</description>
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChildrenChange" scope="prototype">
        <description>processes notification of a change to an item's children</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="prototype">
        <description>create and save a cookie with the currently expanded nodes identifiers</description>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="destroyRecursive" scope="prototype"/>
      <method name="_createTreeNode" scope="prototype">
        <description>creates a TreeNode</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="prototype" type="Object"/>
      <property name="model" scope="instance-prototype" type="dijit.Tree.model">
        <description>Alternate interface from store to access data (and changes to data) in the tree</description>
      </property>
      <property name="query" scope="prototype" type="anything">
        <description>Specifies datastore query to return the root item for the tree.
	Deprecated functionality: if the query returns multiple items, the tree is given
	a fake root node (not corresponding to any item in the data store),
	whose children are the items that match this query.
	The root node is shown or hidden based on whether a label is specified.
	Having a query return multiple items is deprecated.
	If your store doesn't have a root item, wrap the store with
	dijit.tree.ForestStoreModel, and specify model=myModel</description>
      </property>
      <property name="label" scope="prototype" type="String">
        <description>Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	Used in conjunction with query parameter.
	If a query is specified (rather than a root node id), and a label is also specified,
	then a fake root node is created and displayed, with this label.</description>
      </property>
      <property name="showRoot" scope="instance-prototype" type="Boolean">
        <description>Should the root node be displayed, or hidden?</description>
      </property>
      <property name="childrenAttr" scope="prototype" type="String[]">
        <description>one ore more attributes that holds children of a tree node</description>
      </property>
      <property name="openOnClick" scope="prototype" type="Boolean">
        <description>If true, clicking a folder node's label will open it, rather than calling onClick()</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="isExpandable" scope="prototype" type="Object"/>
      <property name="isTree" scope="prototype" type="Object"/>
      <property name="persist" scope="prototype" type="Boolean">
        <description>enables/disables use of cookies for state saving.</description>
      </property>
      <property name="dndController" scope="instance-prototype" type="String">
        <description>class name to use as as the dnd controller</description>
      </property>
      <property name="dndParams" scope="prototype" type="Object"/>
      <property name="onDndDrop" scope="prototype" type="Object"/>
      <property name="itemCreator" scope="prototype" type="Object"/>
      <property name="onDndCancel" scope="prototype" type="Object"/>
      <property name="checkAcceptance" scope="prototype" type="Object"/>
      <property name="checkItemAcceptance" scope="prototype" type="Object"/>
      <property name="dragThreshold" scope="prototype" type="Object"/>
      <property name="tree" scope="instance" type="Object"/>
      <property name="_itemNodeMap" scope="instance" type="Object"/>
      <property name="cookieName" scope="instance" type="Object"/>
      <property name="_openedItemIds" scope="instance" type="Object"/>
      <property name="_v10Compat" scope="instance" type="Object"/>
      <property name="rootNode" scope="instance" type="Object"/>
      <property name="_keyHandlerMap" scope="instance" type="Object"/>
      <property name="lastFocused" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree"/>
  <class type="dijit.tree.TreeStoreModel">
    <description>passed the arguments listed above (store, etc)</description>
    <example>{id:'ROOT'}</example>
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="getRoot" scope="prototype">
        <description>Calls onItem with the root item for the tree, possibly a fabricated item.
	Calls onError on error.</description>
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <description>Tells if an item has or may have children.  Implementing logic here
	avoids showing +/- expando icon for nodes that we know don't have children.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <description>Calls onComplete() with array of child items of given parent item, all loaded.</description>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>get the label for an item</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="newItem" scope="prototype">
        <description>Creates a new item.   See dojo.data.api.Write for details on args.
	Used in drag &amp;amp; drop when item from external source dropped onto tree.</description>
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="parent" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <description>Move or copy an item from one parent item to another.
	Used in drag &amp;amp; drop</description>
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>Callback whenever an item has changed, so that Tree
	can update the label, icon, etc.   Note that changes
	to an item's children or parent(s) will trigger an
	onChildrenChange() so you can ignore those changes here.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="prototype">
        <description>Callback to do notifications about new, updated, or deleted items.</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <description>Callback when an item has been deleted.</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="_onNewItem" scope="prototype">
        <description>handler for when new items appear in the store.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="prototype">
        <description>handler for delete notifications from underlying store</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="prototype">
        <description>set data event on an item in the store</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object | array" usage="required"/>
          <parameter name="newValue" type="object | array" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="prototype" type="Object"/>
      <property name="childrenAttrs" scope="prototype" type="String[]">
        <description>one ore more attributes that holds children of a tree node</description>
      </property>
      <property name="labelAttr" scope="prototype" type="String">
        <description>If specified, get label for tree node from this attribute, rather
	than by calling store.getLabel()</description>
      </property>
      <property name="root" scope="instance-prototype" type="dojo.data.Item">
        <description>Pointer to the root item (read only, not a parameter)</description>
      </property>
      <property name="query" scope="prototype" type="anything">
        <description>Specifies datastore query to return the root item for the tree.
	Must only return a single item.   Alternately can just pass in pointer
	to root item.</description>
      </property>
      <property name="connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.ForestStoreModel" superclass="dijit.tree.TreeStoreModel">
    <description>Interface between Tree and a dojo.store that doesn't have a root item, ie,
	has multiple &amp;quot;top level&amp;quot; items.
	description
	Use this class to wrap a dojo.store, making all the items matching the specified query
	appear as children of a fabricated &amp;quot;root item&amp;quot;.  If no query is specified then all the
	items returned by fetch() on the underlying store become children of the root item.
	It allows dijit.Tree to assume a single root item, even if the store doesn't have one.</description>
    <example>{type:'continent'}</example>
    <methods>
      <method name="mayHaveChildren" scope="prototype">
        <description>Tells if an item has or may have children.  Implementing logic here
	avoids showing +/- expando icon for nodes that we know don't have children.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <description>Calls onComplete() with array of child items of given parent item, all loaded.</description>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="callback" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <description>Creates a new item.   See dojo.data.api.Write for details on args.
	Used in drag &amp;amp; drop when item from external source dropped onto tree.</description>
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="parent" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="onNewRootItem" scope="prototype">
        <description>User can override this method to modify a new element that's being
	added to the root of the tree, for example to add a flag like root=true</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <description>Move or copy an item from one parent item to another.
	Used in drag &amp;amp; drop</description>
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onAddToRoot" scope="prototype">
        <description>Called when item added to root of tree; user must override
	to modify the item so that it matches the query for top level items
	example
		store.setValue(item, &amp;quot;root&amp;quot;, true);</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onLeaveRoot" scope="prototype">
        <description>Called when item removed from root of tree; user must override
	to modify the item so it doesn't match the query for top level items
	example
		store.unsetAttribute(item, &amp;quot;root&amp;quot;);</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_requeryTop" scope="prototype"/>
      <method name="_onNewItem" scope="prototype">
        <description>handler for when new items appear in the store.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="prototype">
        <description>handler for delete notifications from underlying store</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rootId" scope="prototype" type="Object"/>
      <property name="rootLabel" scope="prototype" type="String">
        <description>Label of fabricated root item</description>
      </property>
      <property name="query" scope="prototype" type="String">
        <description>Specifies the set of children of the root item.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.tree.ForestStoreModel.root">
    <properties>
      <property name="children" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Calendar" superclass="dijit._Widget">
    <description>A simple GUI for choosing a date in the context of a monthly calendar.</description>
    <example>
		var calendar = new dijit._Calendar({}, dojo.byId("calendarNode"));</example>
    <methods>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;value&amp;quot;, ...) work.</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateGrid" scope="prototype"/>
      <method name="goToToday" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_adjustDisplay" scope="prototype">
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayClick" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="prototype">
        <description>a date cell was selected.  It may be the same as the previous value.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>called only when the selected date has changed</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="prototype">
        <description>May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getClassForDate" scope="prototype">
        <description>May be overridden to return CSS classes to associate with the date entry for the given dateObject,
	for example to indicate a holiday in specified locale.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="value" scope="instance-prototype" type="Date">
        <description>the currently selected Date</description>
      </property>
      <property name="dayWidth" scope="prototype" type="String">
        <description>How to represent the days of the week in the calendar header. See dojo.date.locale</description>
      </property>
      <property name="displayMonth" scope="instance" type="Object"/>
      <property name="_currentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Contained">
    <example>summary
	Mixin for widgets that are children of a container widget
	 	// make a basic custom widget that knows about it's parents
		dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});</example>
    <methods>
      <method name="getParent" scope="prototype">
        <description>Returns the parent widget of this widget, assuming the parent
	implements dijit._Container</description>
      </method>
      <method name="_getSibling" scope="prototype">
        <parameters>
          <parameter name="which" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getPreviousSibling" scope="prototype">
        <description>Returns null if this is the first child of the parent,
	otherwise returns the next element sibling to the &amp;quot;left&amp;quot;.</description>
        <return-types>
          <return-type type="Mixed"/>
        </return-types>
      </method>
      <method name="getNextSibling" scope="prototype">
        <description>Returns null if this is the last child of the parent,
	otherwise returns the next element sibling to the &amp;quot;right&amp;quot;.</description>
        <return-types>
          <return-type type="Mixed"/>
        </return-types>
      </method>
      <method name="getIndexInParent" scope="prototype">
        <description>Returns the index of this widget within its container parent.
	It returns -1 if the parent does not exist, or if the parent
	is not a dijit._Container</description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit._Container">
    <description>Mixin for widgets that contain a set of widget children.</description>
    <methods>
      <method name="buildRendering" scope="prototype"/>
      <method name="addChild" scope="prototype">
        <description>Makes the given widget a child of this widget.</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <description>Removes the passed widget instance from this widget but does
	not destroy it.  You can also pass in an integer indicating
	the index within the container to remove</description>
        <parameters>
          <parameter name="widget" type="Widget or int" usage="required"/>
        </parameters>
      </method>
      <method name="_nextElement" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_firstElement" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <description>Returns array of children widgets.</description>
        <return-types>
          <return-type type="Widget[]"/>
        </return-types>
      </method>
      <method name="hasChildren" scope="prototype">
        <description>Returns true if widget has children, i.e. if this.containerNode contains something.</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getSiblingOfChild" scope="prototype">
        <description>Get the next or previous widget sibling of child</description>
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="dir" type="int" usage="required">
            <description>if 1, get the next sibling
	if -1, get the previous sibling</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIndexOfChild" scope="prototype">
        <description>Gets the index of the child in this container or -1 if not found</description>
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="isContainer" scope="prototype" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._KeyNavContainer" superclass="dijit._Container">
    <methods>
      <method name="connectKeyNavHandlers" scope="prototype">
        <description>Call in postCreate() to attach the keyboard handlers
	to the container.
	preKeyCodes: Array
	Key codes for navigating to the previous child.</description>
        <parameters>
          <parameter name="prevKeyCodes" type="Array" usage="required"/>
          <parameter name="nextKeyCodes" type="Array" usage="required">
            <description>Key codes for navigating to the next child.</description>
          </parameter>
        </parameters>
      </method>
      <method name="startupKeyNavChildren" scope="prototype">
        <description>Call in startup() to set child tabindexes to -1</description>
      </method>
      <method name="addChild" scope="prototype">
        <description>Add a child to our _Container</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <description>Default focus() implementation: focus the first child.</description>
      </method>
      <method name="focusFirstChild" scope="prototype">
        <description>Focus the first focusable child in the container.</description>
      </method>
      <method name="focusNext" scope="prototype">
        <description>Focus the next widget or focal node (for widgets
	with multiple focal nodes) within this container.</description>
      </method>
      <method name="focusPrev" scope="prototype">
        <description>Focus the previous widget or focal node (for widgets
	with multiple focal nodes) within this container.</description>
      </method>
      <method name="focusChild" scope="prototype">
        <description>Focus widget. Optionally focus 'node' within widget.</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
          <parameter name="node" type="Node" usage="optional"/>
        </parameters>
      </method>
      <method name="_startupChild" scope="prototype">
        <description>Set tabindex=&amp;quot;-1&amp;quot; on focusable widgets so that we
	can focus them programmatically and by clicking.
	Connect focus and blur handlers.</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_connectNode" scope="prototype">
        <parameters>
          <parameter name="node" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerKeypress" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeBlur" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="prototype">
        <description>Called when focus leaves a child widget to go
	to a sibling widget.</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getFirstFocusableChild" scope="prototype"/>
      <method name="_getNextFocusableChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="focusedChild" scope="instance-prototype" type="Object"/>
      <property name="_keyNavCodes" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Templated">
    <description>Mixin for widgets that are instantiated from a template</description>
    <methods>
      <method name="_stringRepl" scope="prototype">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="prototype">
        <description>Construct the UI for this widget from a template, setting this.domNode.</description>
      </method>
      <method name="_fillContent" scope="prototype">
        <description>relocate source contents to templated container node
	this.containerNode must be able to receive children, or exceptions will be thrown</description>
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_attachTemplateNodes" scope="prototype">
        <description>Iterate through the template and attach functions and nodes accordingly.</description>
        <parameters>
          <parameter name="rootNode" type="DomNode|Array[Widgets" usage="required">
            <description>the node to search for properties. All children will be searched.</description>
          </parameter>
          <parameter name="getAttrFunc" type="function" usage="optional">
            <description>a function which will be used to obtain property for a given
	DomNode/Widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="getCachedTemplate" scope="instance">
        <description>Static method to get a template based on the templatePath or
	templateString key</description>
        <parameters>
          <parameter name="templatePath" type="String" usage="required">
            <description>The URL to get the template from. dojo.uri.Uri is often passed as well.</description>
          </parameter>
          <parameter name="templateString" type="String" usage="optional">
            <description>a string to use in lieu of fetching the template from a URL. Takes precedence
	over templatePath
	Returns: Mixed
	Either string (if there are ${} variables that need to be replaced) or just
	a DOM tree (if the node can be cloned directly)</description>
          </parameter>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_sanitizeTemplateString" scope="instance">
        <description>Strips &amp;lt;?xml ...?&amp;gt; declarations so that external SVG and XML
	documents can be added to a document without worry. Also, if the string
	is an HTML document, only the part inside the body tag is returned.</description>
        <parameters>
          <parameter name="tString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_createNodesFromText" scope="instance">
        <description>Attempts to create a set of nodes based on the structure of the passed text.</description>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="templateNode" scope="prototype" type="DomNode">
        <description>a node that represents the widget template. Pre-empts both templateString and templatePath.</description>
      </property>
      <property name="templateString" scope="prototype" type="String">
        <description>a string that represents the widget template. Pre-empts the
	templatePath. In builds that have their strings &amp;quot;interned&amp;quot;, the
	templatePath is converted to an inline templateString, thereby
	preventing a synchronous network call.</description>
      </property>
      <property name="templatePath" scope="prototype" type="String">
        <description>Path to template (HTML file) for this widget relative to dojo.baseUrl</description>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Boolean">
        <description>should we parse the template to find widgets that might be
	declared in markup inside it? false by default.</description>
      </property>
      <property name="_skipNodeCache" scope="prototype" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
      <property name="_templateCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget">
    <description>The foundation of dijit widgets.</description>
    <methods>
      <method name="onClick" scope="prototype">
        <description>Connect to this function to receive notifications of mouse click events.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDblClick" scope="prototype">
        <description>Connect to this function to receive notifications of mouse double click events.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <description>Connect to this function to receive notifications of keys being pressed down.</description>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyPress" scope="prototype">
        <description>Connect to this function to receive notifications of printable keys being typed.</description>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <description>Connect to this function to receive notifications of keys being released.</description>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse button is pressed down.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseLeave" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse moves off of this widget.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseEnter" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse moves onto this widget.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>Connect to this function to receive notifications of when the mouse button is released.</description>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="prototype">
        <description>Kick off the life-cycle of a widget</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional">
            <description>Hash of initialization parameters for widget, including
	scalar values (like title, duration etc.) and functions,
	typically callbacks like onClick.</description>
          </parameter>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional">
            <description>If a srcNodeRef (dom node) is specified:
	- use srcNodeRef.innerHTML as my contents
	- if this is a behavioral widget then apply behavior
	to that srcNodeRef
	- otherwise, replace srcNodeRef with my generated DOM
	tree</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="prototype">
        <description>Step during widget creation to copy all widget attributes to the
	DOM as per attributeMap and _setXXXAttr functions.</description>
      </method>
      <method name="postMixInProperties" scope="prototype">
        <description>Called after the parameters to the widget have been read-in,
	but before the widget template is instantiated. Especially
	useful to set properties that are referenced in the widget
	template.</description>
      </method>
      <method name="buildRendering" scope="prototype">
        <description>Construct the UI for this widget, setting this.domNode.  Most
	widgets will mixin dijit._Templated, which implements this
	method.</description>
      </method>
      <method name="postCreate" scope="prototype">
        <description>Called after a widget's dom has been setup</description>
      </method>
      <method name="startup" scope="prototype">
        <description>Called after a widget's children, and other widgets on the page, have been created.
	Provides an opportunity to manipulate any children before they are displayed.
	This is useful for composite widgets that need to control or layout sub-widgets.
	Many layout widgets can use this as a wiring phase.</description>
      </method>
      <method name="destroyRecursive" scope="prototype">
        <description>Destroy this widget and it's descendants. This is the generic
	&amp;quot;destructor&amp;quot; function that all widget users should call to
	cleanly discard with a widget. Once a widget is destroyed, it's
	removed from the manager object.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original Dom structure
	alone of descendant Widgets. Note: This will NOT work with
	dijit._Templated widgets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>Destroy this widget, but not its descendants.
	Will, however, destroy internal widgets such as those used within a template.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required">
            <description>If true, this method will leave the original Dom structure alone.
	Note: This will not yet work with _Templated widgets</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyRendering" scope="prototype">
        <description>Destroys the DOM nodes associated with this widget</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original Dom structure alone
	during tear-down. Note: this will not work with _Templated
	widgets yet.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <description>Recursively destroy the children of this widget and their
	descendants.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, the preserveDom attribute is passed to all descendant
	widget's .destroy() method. Not for use with _Templated
	widgets.
	TODO: should I destroy in the reverse order, to go bottom up?</description>
          </parameter>
        </parameters>
      </method>
      <method name="uninitialize" scope="prototype">
        <description>stub function. Override to implement custom widget tear-down
	behavior.</description>
      </method>
      <method name="onFocus" scope="prototype">
        <description>stub function. Override or connect to this method to receive
	notifications for when the widget moves into focus.</description>
      </method>
      <method name="onBlur" scope="prototype">
        <description>stub function. Override or connect to this method to receive
	notifications for when the widget moves out of focus.</description>
      </method>
      <method name="_onFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype"/>
      <method name="_onConnect" scope="prototype">
        <description>Called when someone connects to one of my handlers.
	&amp;quot;Turn on&amp;quot; that handler if it isn't active yet.</description>
        <parameters>
          <parameter name="event" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setAttribute" scope="prototype">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_attrToDom" scope="prototype">
        <description>Reflect a widget attribute (title, tabIndex, duration etc.) to
	the widget DOM, as specified in attributeMap.</description>
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="prototype">
        <description>Set or get properties on a widget instance.</description>
        <parameters>
          <parameter name="name" type="String|Object" usage="required">
            <description>The property to get or set. If an object is passed here and not
	a string, its keys are used as names of attributes to be set
	and the value of the object as values to set in the widget.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. If provided, attr() operates as a setter. If omitted,
	the current value of the named property is returned.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="prototype">
        <description>helper function for Widget.attr()
	cache attribute name values so we don't do the string ops every time</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <description>returns a string that represents the widget. When a widget is
	cast to a string, this method will be used to generate the
	output. Currently, it does not implement any sort of reversable
	serialization.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDescendants" scope="prototype">
        <description>Returns all the widgets that contained by this, i.e., all widgets underneath this.containerNode.</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="prototype">
        <description>Connects specified obj/event to specified method of this object
	and registers for disconnect() on widget destroy.</description>
        <example>
		var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="prototype">
        <description>Disconnects handle created by this.connect.
	Also removes handle from this widget's list of connects</description>
        <parameters>
          <parameter name="handles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLeftToRight" scope="prototype">
        <description>Checks the page for text direction</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFocusable" scope="prototype">
        <description>Return true if this widget can currently be focused
	and false if not</description>
      </method>
      <method name="placeAt" scope="prototype">
        <description>Place this widget's domNode reference somewhere in the DOM based
	on standard dojo.place conventions, or passing a Widget reference that
	contains and addChild member.</description>
        <example>
	 	// create a Button with no srcNodeRef, and place it in the body:
	 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
	 	// now, 'button' is still the widget reference to the newly created button
	 	dojo.connect(button, "onClick", function(e){ console.log('click'); });</example>
        <parameters>
          <parameter name="reference" type="String|DomNode|_Widget" usage="required">
            <description>The String id of a domNode, a domNode reference, or a reference to a Widget posessing
	an addChild method.</description>
          </parameter>
          <parameter name="position" type="String?|Int" usage="optional">
            <description>If passed a string or domNode reference, the position argument
	accepts a string just as dojo.place does, one of: &amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;,
	&amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;.
	If passed a _Widget reference, and that widget reference has an &amp;quot;.addChild&amp;quot; method,
	it will be called passing this widget instance into that method, supplying the optional
	position index passed.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dojoAttachEvent" scope="prototype" type="Object"/>
      <property name="dojoAttachPoint" scope="prototype" type="Object"/>
      <property name="waiRole" scope="prototype" type="Object"/>
      <property name="waiState" scope="prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="String">
        <description>a unique, opaque ID string that can be assigned by users or by the
	system. If the developer passes an ID which is known not to be
	unique, the specified ID is ignored and the system-generated ID is
	used instead.</description>
      </property>
      <property name="lang" scope="prototype" type="String">
        <description>Rarely used.  Overrides the default Dojo locale used to render this widget,
	as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	Value must be among the list of locales specified during by the Dojo bootstrap,
	formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).</description>
      </property>
      <property name="dir" scope="prototype" type="String">
        <description>Unsupported by Dijit, but here for completeness.  Dijit only supports setting text direction on the
	entire document.
	Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	attribute. Either left-to-right &amp;quot;ltr&amp;quot; or right-to-left &amp;quot;rtl&amp;quot;.</description>
      </property>
      <property name="class" scope="prototype" type="String">
        <description>HTML class attribute</description>
      </property>
      <property name="style" scope="prototype" type="String">
        <description>HTML style attribute</description>
      </property>
      <property name="title" scope="prototype" type="String">
        <description>HTML title attribute</description>
      </property>
      <property name="domNode" scope="instance-prototype" type="DomNode">
        <description>This is our visible representation of the widget! Other DOM
	Nodes may by assigned to other properties, usually through the
	template system's dojoAttachPoint syntax, but the domNode
	property is the canonical &amp;quot;top level&amp;quot; node in widget UI.</description>
      </property>
      <property name="containerNode" scope="prototype" type="DomNode">
        <description>Designates where children of the source dom node will be placed.
	&amp;quot;Children&amp;quot; in this case refers to both dom nodes and widgets.
	For example, for myWidget:
		&amp;lt;div dojoType=myWidget&amp;gt;
			&amp;lt;b&amp;gt; here's a plain dom node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain dom node &amp;lt;/i&amp;gt;
		&amp;lt;/div&amp;gt;
	containerNode would point to:
			&amp;lt;b&amp;gt; here's a plain dom node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain dom node &amp;lt;/i&amp;gt;
	In templated widgets, &amp;quot;containerNode&amp;quot; is set via a
	dojoAttachPoint assignment.
	containerNode must be defined for any widget that accepts innerHTML
	(like ContentPane or BorderContainer or even Button), and conversely
	is null for widgets that don't, like TextBox.</description>
      </property>
      <property name="_blankGif" scope="prototype" type="Object"/>
      <property name="_attrPairNames" scope="prototype" type="Object"/>
      <property name="nodesWithKeyClick" scope="prototype" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_created" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="region" scope="prototype" type="Object"/>
      <property name="splitter" scope="prototype" type="Object"/>
      <property name="minSize" scope="prototype" type="Object"/>
      <property name="maxSize" scope="prototype" type="Object"/>
      <property name="dragRestriction" scope="prototype" type="Object"/>
      <property name="column" scope="prototype" type="Object"/>
      <property name="group" scope="prototype" type="Object"/>
      <property name="slideFrom" scope="prototype" type="Object"/>
      <property name="toggleSplitterOpen" scope="prototype" type="Object"/>
      <property name="toggleSplitterClosedThreshold" scope="prototype" type="Object"/>
      <property name="toggleSplitterOpenSize" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker" superclass="dijit._Widget">
    <description>A graphical time picker.
	This widget is used internally by other widgets and is not accessible
	as a standalone widget.</description>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="clickableIncrement" scope="prototype" type="String">
        <description>ISO-8601 string representing the amount by which
	every clickable element in the time picker increases.
	Set in local time, without a time zone.
	Example: `T00:15:00` creates 15 minute increments
	Must divide dijit._TimePicker.visibleIncrement evenly</description>
      </property>
      <property name="visibleIncrement" scope="prototype" type="String">
        <description>ISO-8601 string representing the amount by which
	every element with a visible time in the time picker increases.
	Set in local time, without a time zone.
	Example: `T01:00:00` creates text in every 1 hour increment</description>
      </property>
      <property name="visibleRange" scope="prototype" type="String">
        <description>ISO-8601 string representing the range of this TimePicker.
	The TimePicker will only display times in this range.
	Example: `T05:00:00` displays 5 hours of options</description>
      </property>
      <property name="value" scope="prototype" type="String">
        <description>Date to display.
	Defaults to current time and date.
	Can be a Date object or an ISO-8601 string.
	If you specify the GMT time zone (`-01:00`),
	the time will be converted to the local time in the local time zone.
	Otherwise, the time is considered to be in the local time zone.
	If you specify the date and isDate is true, the date is used.
	Example: if your local time zone is `GMT -05:00`,
	`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
	`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
	`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
	`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
	Example: `2007-06-01T09:00:00`</description>
      </property>
      <property name="_visibleIncrement" scope="prototype" type="Object"/>
      <property name="_clickableIncrement" scope="prototype" type="Object"/>
      <property name="_totalIncrements" scope="prototype" type="Object"/>
      <property name="constraints" scope="prototype" type="dijit._TimePicker.__Constraints"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.__Constraints" superclass="dojo.date.locale.__FormatOptions">
    <properties>
      <property name="clickableIncrement" scope="prototype" type="String">
        <description>see dijit._TimePicker.clickableIncrement</description>
      </property>
      <property name="visibleIncrement" scope="prototype" type="String">
        <description>see dijit._TimePicker.visibleIncrement</description>
      </property>
      <property name="visibleRange" scope="prototype" type="String">
        <description>see dijit._TimePicker.visibleRange</description>
      </property>
    </properties>
  </class>
  <class type="dijit._Widget.attributeMap">
    <description>attributeMap sets up a &amp;quot;binding&amp;quot; between attributes (aka properties)
	of the widget and the widget's DOM.
	Changes to widget attributes listed in attributeMap will be
	reflected into the DOM.
	For example, calling attr('title', 'hello')
	on a TitlePane will automatically cause the TitlePane's DOM to update
	with the new title.
	attributeMap is a hash where the key is an attribute of the widget,
	and the value reflects a binding to a:
	- DOM node attribute
			focus: {node: &amp;quot;focusNode&amp;quot;, type: &amp;quot;attribute&amp;quot;}
	Maps this.focus to this.focusNode.focus
	- DOM node innerHTML
			title: { node: &amp;quot;titleNode&amp;quot;, type: &amp;quot;innerHTML&amp;quot; }
	Maps this.title to this.titleNode.innerHTML
	- DOM node CSS class
			myClass: { node: &amp;quot;domNode&amp;quot;, type: &amp;quot;class&amp;quot; }
	Maps this.myClass to this.domNode.className
	If the value is an array, then each element in the array matches one of the
	formats of the above list.
	There are also some shorthands for backwards compatibility:
	- string --&amp;gt; { node: string, type: &amp;quot;attribute&amp;quot; }, for example:
		&amp;quot;focusNode&amp;quot; ---&amp;gt; { node: &amp;quot;focusNode&amp;quot;, type: &amp;quot;attribute&amp;quot; }
	- &amp;quot;&amp;quot; --&amp;gt; { node: &amp;quot;domNode&amp;quot;, type: &amp;quot;attribute&amp;quot; }</description>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="lang" scope="instance" type="Object"/>
      <property name="class" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget._deferredConnects">
    <description>attributeMap addendum for event handlers that should be connected only on first use</description>
    <properties>
      <property name="onClick" scope="instance" type="Object"/>
      <property name="onDblClick" scope="instance" type="Object"/>
      <property name="onKeyDown" scope="instance" type="Object"/>
      <property name="onKeyPress" scope="instance" type="Object"/>
      <property name="onKeyUp" scope="instance" type="Object"/>
      <property name="onMouseMove" scope="instance" type="Object"/>
      <property name="onMouseDown" scope="instance" type="Object"/>
      <property name="onMouseOut" scope="instance" type="Object"/>
      <property name="onMouseOver" scope="instance" type="Object"/>
      <property name="onMouseLeave" scope="instance" type="Object"/>
      <property name="onMouseEnter" scope="instance" type="Object"/>
      <property name="onMouseUp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget.srcNodeRef">
    <description>pointer to original dom node</description>
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.WidgetSet">
    <description>A set of widgets indexed by id</description>
    <methods>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="prototype">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="filter" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="byId" scope="prototype">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="byClass" scope="prototype">
        <parameters>
          <parameter name="cls" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tabElements">
    <properties>
      <property name="area" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="input" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="select" scope="instance" type="Object"/>
      <property name="textarea" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.__Position">
    <properties>
      <property name="y" scope="instance" type="x">
        <description>Integer
	horizontal coordinate in pixels, relative to document body
	Integer
	vertical coordinate in pixels, relative to document body</description>
      </property>
    </properties>
  </class>
  <class type="dijit.__Rectangle">
    <properties>
      <property name="y" scope="instance" type="x">
        <description>Integer
	horizontal offset in pixels, relative to document body
	Integer
	vertical offset in pixels, relative to document body
	width: Integer
	width in pixels</description>
      </property>
      <property name="height" scope="instance" type="Integer">
        <description>height in pixels</description>
      </property>
    </properties>
  </class>
  <class type="dijit.popup">
    <description>This class is used to show/hide widgets as popups.</description>
    <methods>
      <method name="prepare" scope="instance">
        <description>Prepares a node to be used as a popup</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <description>Popup the widget at the specified position</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>popup: Widget
	widget to display,
	parent: Widget
	the button etc. that is displaying this popup
	around: DomNode
	DOM node (typically a button); place popup relative to this node
	orient: Object
	structure specifying possible positions of popup relative to &amp;quot;around&amp;quot; node
	onCancel: Function
	callback when user has canceled the popup by
	1. hitting ESC or
	2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	ie: whenever popupWidget.onCancel() is called, args.onCancel is called
	onClose: Function
	callback whenever this popup is closed
	onExecute: Function
	callback when user &amp;quot;executed&amp;quot; on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	examples:
	1. opening at the mouse position
	dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
	2. opening the widget as a dropdown
	dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}  });
	Note that whatever widget called dijit.popup.open() should also listen to it's own _onBlur callback
	(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Close specified popup and any popups that it parented</description>
        <parameters>
          <parameter name="popup" type="Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._frames">
    <description>cache of iframes</description>
    <methods>
      <method name="pop" scope="instance"/>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="iframe" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.BackgroundIframe">
    <description>For IE z-index schenanigans. id attribute is required.</description>
    <methods>
      <method name="destroy" scope="prototype">
        <description>destroy the iframe</description>
      </method>
    </methods>
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.doc.documentElement">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic">
    <description>These functions are used to repetitively call a user specified callback
	method when a specific key or mouse click over a specific DOM node is
	held down for a specific amount of time.
	Only 1 such event is allowed to occur on the browser page at 1 time.</description>
    <methods>
      <method name="_fireEventAndReload" scope="instance"/>
      <method name="trigger" scope="instance">
        <description>Start a timed, repeating callback sequence.
	If already started, the function call is ignored.
	This method is not normally called by the user but can be
	when the normal listener code is insufficient.
	Parameters:</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>key or mouse event object</description>
          </parameter>
          <parameter name="_this" type="Object" usage="required">
            <description>pointer to the user's widget space.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the DOM node object passed in</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>function to call until the sequence is stopped called with 3 parameters:
	count: integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped</description>
          </parameter>
          <parameter name="obj" type="Object" usage="required">
            <description>user space object used to uniquely identify each typematic sequence</description>
          </parameter>
          <parameter name="subsequentDelay" type="Number" usage="required">
            <description>if &amp;gt; 1, the number of milliseconds until the 3-&amp;gt;n events occur
	or else the fractional time multiplier for the next event's delay, default=0.9</description>
          </parameter>
          <parameter name="initialDelay" type="Number" usage="required">
            <description>the number of milliseconds until the 2nd event occurs, default=500ms</description>
          </parameter>
        </parameters>
      </method>
      <method name="stop" scope="instance">
        <description>Stop an ongoing timed, repeating callback sequence.</description>
      </method>
      <method name="addKeyListener" scope="instance">
        <description>Start listening for a specific typematic key.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required">
            <description>an object defining the key to listen for.
	charOrCode: the printable character (string) or keyCode (number) to listen for.
	keyCode: (deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
	charCode: (deprecated - use charOrCode) the charCode (number) to listen for.
	ctrlKey: desired ctrl key state to initiate the calback sequence:
	pressed (true)
	released (false)
	either (unspecified)
	altKey: same as ctrlKey but for the alt key
	shiftKey: same as ctrlKey but for the shift key
	See the trigger method for other parameters.
	Returns an array of dojo.connect handles</description>
          </parameter>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="addMouseListener" scope="instance">
        <description>Start listening for a typematic mouse click.
	See the trigger method for other parameters.
	Returns an array of dojo.connect handles</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="addListener" scope="instance">
        <description>Start listening for a specific typematic key and mouseclick.
	This is a thin wrapper to addKeyListener and addMouseListener.</description>
        <parameters>
          <parameter name="mouseNode" type="Node" usage="required">
            <description>the DOM node object to listen on for mouse events.</description>
          </parameter>
          <parameter name="keyNode" type="Node" usage="required">
            <description>the DOM node object to listen on for key events.
	See the addMouseListener and addKeyListener methods for other parameters.
	Returns an array of dojo.connect handles</description>
          </parameter>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.wai">
    <methods>
      <method name="onload" scope="instance">
        <description>Detects if we are in high-contrast mode or not</description>
      </method>
    </methods>
  </class>
  <class type="dijit._editor">
    <methods>
      <method name="escapeXml" scope="instance">
        <description>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'
	Optionally skips escapes for single quotes</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getChildrenHtml" scope="instance">
        <description>Returns the html content of a DomNode and children</description>
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="html" scope="instance" type="Object"/>
      <property name="range" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText" superclass="dijit._Widget">
    <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features.</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="setupDefaultShortcuts" scope="prototype">
        <description>add some default key handlers</description>
      </method>
      <method name="_localizeEditorCommands" scope="prototype"/>
      <method name="open" scope="prototype">
        <description>Transforms the node referenced in this.domNode into a rich text editing
	node.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="_getIframeDocTxt" scope="prototype">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_drawIframe" scope="prototype">
        <description>Draws an iFrame using the existing one if one exists.
	Used by Mozilla, Safari, and Opera</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEditingAreaStyleSheets" scope="prototype">
        <description>apply the specified css files in styleSheets</description>
      </method>
      <method name="addStyleSheet" scope="prototype">
        <description>add an external stylesheet for the editing area</description>
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required">
            <description>a dojo.uri.Uri pointing to the url of the external css file</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeStyleSheet" scope="prototype">
        <description>remove an external stylesheet for the editing area</description>
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isResized" scope="prototype"/>
      <method name="onKeyDown" scope="prototype">
        <description>Fired on keydown</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <description>Fired on keyup</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>registers that attr(&amp;quot;value&amp;quot;, foo) should call setValue(foo)</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addKeyHandler" scope="prototype">
        <description>add a handler for a keyboard shortcut</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="ctrl" type="Boolean" usage="required"/>
          <parameter name="shift" type="Boolean" usage="required"/>
          <parameter name="handler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="prototype"/>
      <method name="onClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onIEMouseDown" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <description>Fired on focus</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="blur" scope="prototype">
        <description>remove focus from this instance</description>
      </method>
      <method name="focus" scope="prototype">
        <description>move focus to this instance</description>
      </method>
      <method name="onDisplayChanged" scope="prototype">
        <description>This event will be fired everytime the display context
	changes and the result needs to be reflected in the UI.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onNormalizedDisplayChanged" scope="prototype">
        <description>This event is fired every updateInterval ms or more</description>
      </method>
      <method name="onChange" scope="prototype">
        <description>this is fired if and only if the editor loses focus and
	the content is changed</description>
        <parameters>
          <parameter name="newContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeCommand" scope="prototype">
        <description>Used as the advice function by dojo.connect to map our
	normalized set of commands to those supported by the target
	browser</description>
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandAvailable" scope="prototype">
        <description>Tests whether a command is supported by the host. Clients
	SHOULD check whether a command is supported before attempting
	to use it, behaviour for unsupported commands is undefined.</description>
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to test for</description>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandAvailable" scope="prototype">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean return true if the command is supported, false otherwise"/>
        </return-types>
      </method>
      <method name="execCommand" scope="prototype">
        <description>Executes a command in the Rich Text area</description>
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to execute</description>
          </parameter>
          <parameter name="argument" type="An" usage="required">
            <description>optional argument to the command</description>
          </parameter>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="prototype">
        <description>check whether a command is enabled or not</description>
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="mozilla returns true always"/>
        </return-types>
      </method>
      <method name="queryCommandState" scope="prototype">
        <description>check the state of a given command and returns true or false</description>
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandValue" scope="prototype">
        <description>check the value of a given command. This matters most for
	custom selections and complex values like font value setting</description>
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sCall" scope="prototype">
        <description>run the named method of dijit._editor.selection over the
	current editor instance's window, with the passed args</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeCursorAtStart" scope="prototype">
        <description>place the cursor at the start of the editing area</description>
      </method>
      <method name="placeCursorAtEnd" scope="prototype">
        <description>place the cursor at the end of the editing area</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>return the current content of the editing area (post filters
	are applied)</description>
        <parameters>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to false. Should the post-filtering be run over a copy
	of the live DOM? Most users should pass &amp;quot;true&amp;quot; here unless they
	*really* know that none of the installed filters are going to
	mess up the editing session.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>hook to make attr(&amp;quot;value&amp;quot;) work</description>
      </method>
      <method name="setValue" scope="prototype">
        <description>This function sets the content. No undo history is preserved.</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="replaceValue" scope="prototype">
        <description>this function set the content while trying to maintain the undo stack
	(now only works fine with Moz, this is identical to setValue in all
	other browsers)</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterContent" scope="prototype">
        <description>filter the input before setting the content of the editing
	area. DOM pre-filtering may happen after this
	string-based filtering takes place but as of 1.2, this is not
	gauranteed for operations such as the inserthtml command.</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilterContent" scope="prototype">
        <description>filter the input's live DOM. All filter operations should be
	considered to be &amp;quot;live&amp;quot; and operating on the DOM that the user
	will be interacting with in their editing session.</description>
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterContent" scope="prototype">
        <description>filter the output after getting the content of the editing area</description>
        <parameters>
          <parameter name="dom" type="DomNode|DomNode[]|String" usage="optional">
            <description>a node, set of nodes, which to filter using each of the current
	members of the contentDomPostFilters and contentPostFilters arrays.</description>
          </parameter>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to &amp;quot;false&amp;quot;. If true, ensures that filtering happens on
	a clone of the passed-in content and not the actual node
	itself.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_saveContent" scope="prototype">
        <description>Saves the content in an onunload event if the editor has not been closed</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="escapeXml" scope="prototype">
        <description>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'
	Optionally skips escapes for single quotes</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="prototype">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNodeChildrenHtml" scope="prototype">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>Kills the editor and optionally writes back the modified contents to the
	element from which it originated.</description>
        <parameters>
          <parameter name="save" type="Boolean" usage="required">
            <description>Whether or not to save the changes. If false, the changes are discarded.</description>
          </parameter>
          <parameter name="force" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean: whether the content has been modified"/>
        </return-types>
      </method>
      <method name="destroyRendering" scope="prototype">
        <description>stub</description>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="_removeMozBogus" scope="prototype">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_removeSafariBogus" scope="prototype">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_fixContentForMoz" scope="prototype">
        <description>Moz can not handle strong/em tags correctly, convert them to b/i</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFixUrlAttributes" scope="prototype">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="inheritWidth" scope="prototype" type="Boolean">
        <description>whether to inherit the parent's width or simply use 100%</description>
      </property>
      <property name="focusOnLoad" scope="prototype" type="Boolean">
        <description>whether focusing into this instance of richtext when page onload</description>
      </property>
      <property name="name" scope="instance-prototype" type="String">
        <description>If a save name is specified the content is saved and restored when the user
	leave this page can come back, or if the editor is not properly closed after
	editing has started.</description>
      </property>
      <property name="styleSheets" scope="instance-prototype" type="String">
        <description>semicolon (&amp;quot;;&amp;quot;) separated list of css files for the editing area</description>
      </property>
      <property name="_content" scope="instance-prototype" type="String">
        <description>temporary content storage</description>
      </property>
      <property name="height" scope="prototype" type="String">
        <description>set height to fix the editor at a specific height, with scrolling.
	By default, this is 300px. If you want to have the editor always
	resizes to accommodate the content, use AlwaysShowToolbar plugin
	and set height=&amp;quot;&amp;quot;. If this editor is used within a layout widget,
	set height=&amp;quot;100%&amp;quot;.</description>
      </property>
      <property name="minHeight" scope="prototype" type="String">
        <description>The minimum height that the editor should have</description>
      </property>
      <property name="isClosed" scope="instance-prototype" type="Boolean"/>
      <property name="isLoaded" scope="instance-prototype" type="Boolean"/>
      <property name="_SEPARATOR" scope="prototype" type="String">
        <description>used to concat contents from multiple textareas into a single string</description>
      </property>
      <property name="onLoadDeferred" scope="instance-prototype" type="dojo.Deferred">
        <description>deferred which is fired when the editor finishes loading</description>
      </property>
      <property name="isTabIndent" scope="instance-prototype" type="Boolean">
        <description>used to allow tab key and shift-tab to indent and outdent rather than navigate</description>
      </property>
      <property name="events" scope="prototype" type="Array">
        <description>events which should be connected to the underlying editing
	area, events in this array will be addListener with
	capture=true</description>
      </property>
      <property name="captureEvents" scope="prototype" type="Object"/>
      <property name="_editorCommandsLocalized" scope="instance-prototype" type="Object"/>
      <property name="_local2NativeFormatNames" scope="prototype" type="Object"/>
      <property name="_native2LocalFormatNames" scope="prototype" type="Object"/>
      <property name="disabled" scope="instance-prototype" type="Object"/>
      <property name="_mozSettingProps" scope="prototype" type="Object"/>
      <property name="_initialFocus" scope="instance-prototype" type="Object"/>
      <property name="updateInterval" scope="prototype" type="Object"/>
      <property name="_updateTimer" scope="instance-prototype" type="Object"/>
      <property name="_qcaCache" scope="prototype" type="Object"/>
      <property name="__overflow" scope="instance" type="Object"/>
      <property name="_oldHeight" scope="instance" type="Object"/>
      <property name="_oldWidth" scope="instance" type="Object"/>
      <property name="savedContent" scope="instance" type="Object"/>
      <property name="editingArea" scope="instance" type="Object"/>
      <property name="editorObject" scope="instance" type="Object"/>
      <property name="editingAreaStyleSheets" scope="instance" type="Object"/>
      <property name="_delayedDisabled" scope="instance" type="Object"/>
      <property name="_mozSettings" scope="instance" type="Object"/>
      <property name="tabStop" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="_onKeyHitch" scope="instance" type="Object"/>
      <property name="_updateHandler" scope="instance" type="Object"/>
      <property name="contentPreFilters" scope="instance" type="Array">
        <description>pre content filter function register array.
	these filters will be executed before the actual
	editing area get the html content</description>
      </property>
      <property name="contentPostFilters" scope="instance" type="Object"/>
      <property name="contentDomPreFilters" scope="instance" type="Object"/>
      <property name="contentDomPostFilters" scope="instance" type="Object"/>
      <property name="_keyHandlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.onLoad">
    <description>handler after the content of the document finishes loading</description>
  </class>
  <class type="dijit._editor.RichText.domNode">
    <properties>
      <property name="nodeName" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText._localizedIframeTitles">
    <properties>
      <property name="iframeEditTitle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.iframe.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.iframe">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="onfocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="unselectable" scope="instance" type="Object"/>
      <property name="contentEditable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.document">
    <properties>
      <property name="designMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.window">
    <properties>
      <property name="__registeredWindow" scope="instance" type="Object"/>
      <property name="_frameElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode.style">
    <properties>
      <property name="zoom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.onLoad.iframe">
    <methods>
      <method name="onfocus" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.RichText.document.selection">
    <properties>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="savetextarea">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="savetextarea.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
      <property name="position" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin">
    <methods>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="prototype">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="prototype"/>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="editor" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="toolbar" type="Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editor" scope="instance-prototype" type="Object"/>
      <property name="iconClassPrefix" scope="prototype" type="Object"/>
      <property name="queryCommand" scope="prototype" type="Object"/>
      <property name="command" scope="prototype" type="Object"/>
      <property name="commandArg" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="enabled" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin.button">
    <properties>
      <property name="checked" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin.button.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar" superclass="dijit._editor._Plugin">
    <description>For auto-expanding editors, this plugin will keep the
	editor's toolbar visible even when the top of the editor
	has scrolled off the top of the viewport (usually when editing a long
	document).</description>
    <example>
		&lt;div dojoType="dijit.Editor" height=""
		extraPlugins="['dijit._editor.plugins.AlwaysShowToolbar']"&gt;</example>
    <methods>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="prototype">
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHeight" scope="prototype">
        <description>Updates the height of the editor area to fit the contents.</description>
        <return-types>
          <return-type type="prevent setting height to 0"/>
        </return-types>
      </method>
      <method name="globalOnScrollHandler" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="_handleScroll" scope="instance-prototype" type="Object"/>
      <property name="_lastHeight" scope="instance-prototype" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_scrollSetUp" scope="instance" type="Object"/>
      <property name="_scrollThreshold" scope="instance" type="Object"/>
      <property name="_IEOriginalPos" scope="instance" type="Object"/>
      <property name="_fixEnabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.iframe.style">
    <properties>
      <property name="marginTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling" superclass="dijit._editor._Plugin">
    <description>This plugin tries to make all browsers have identical behavior
	when the user presses the ENTER key.
	Specifically, it fixes the double-spaced line problem on IE.</description>
    <methods>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="onKeyPressed" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleEnterKey" scope="prototype">
        <description>Manually handle enter key event to make the behavior consistant across
	all supported browsers. See property blockNodeForEnter for available options
	let browser handle this
	TODO: delete.  this code will never fire because
	onKeyPress --&amp;gt; handleEnterKey is only called when blockNodeForEnter != null</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="let brower handle"/>
        </return-types>
      </method>
      <method name="removeTrailingBr" scope="prototype">
        <parameters>
          <parameter name="container" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fixNewLineBehaviorForIE" scope="prototype">
        <description>Insert CSS so &amp;lt;p&amp;gt; nodes don't have spacing around them,
	thus hiding the fact that ENTER key on IE is creating new
	paragraphs</description>
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="HTMLStyleElement"/>
        </return-types>
      </method>
      <method name="regularPsToSingleLinePs" scope="prototype">
        <description>Converts a &amp;lt;p&amp;gt; node containing &amp;lt;br&amp;gt;'s into multiple &amp;lt;p&amp;gt; nodes.</description>
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="noWhiteSpaceInEmptyP" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="singleLinePsToRegularPs" scope="prototype">
        <description>Called as post-filter.
	Apparently collapses adjacent &amp;lt;p&amp;gt; nodes into a single &amp;lt;p&amp;gt;
	nodes with &amp;lt;br&amp;gt; separating each line.</description>
        <example>Given this input:
		&lt;p&gt;line 1&lt;/p&gt;
		&lt;p&gt;line 2&lt;/p&gt;
		&lt;ol&gt;
			&lt;li&gt;item 1
			&lt;li&gt;item 2
		&lt;/ol&gt;
		&lt;p&gt;line 3&lt;/p&gt;
		&lt;p&gt;line 4&lt;/p&gt;
	Will convert to:
		&lt;p&gt;line 1&lt;br&gt;line 2&lt;/p&gt;
		&lt;ol&gt;
			&lt;li&gt;item 1
			&lt;li&gt;item 2
		&lt;/ol&gt;
		&lt;p&gt;line 3&lt;br&gt;line 4&lt;/p&gt;
	Not sure why this situation would even come up after the pre-filter and
	the enter-key-handling code.</example>
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="blockNodeForEnter" scope="instance-prototype" type="Object"/>
      <property name="bogusHtmlContent" scope="prototype" type="Object"/>
      <property name="blockNodes" scope="prototype" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
      <property name="_checkListLater" scope="instance" type="Object"/>
      <property name="_pressedEnterInBlock" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling.editor.document">
    <properties>
      <property name="__INSERTED_EDITIOR_NEWLINE_CSS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice" superclass="dijit._editor._Plugin">
    <description>This plugin provides three dropdowns for setting font information in the editor</description>
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="updateState" scope="prototype"/>
      <method name="setToolbar" scope="prototype"/>
    </methods>
    <properties>
      <property name="_uniqueId" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="_availableValues" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="updating" scope="instance" type="Object"/>
      <property name="_focusHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog" superclass="dijit._editor._Plugin">
    <description>This plugin provides dialogs for inserting links and images into the editor</description>
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="staticPanel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>callback from the dialog when user hits &amp;quot;set&amp;quot; button
	TODO: prevent closing popup if the text is empty</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="prototype"/>
      <method name="_onOpenDialog" scope="prototype"/>
    </methods>
    <properties>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="urlRegExp" scope="prototype" type="Object"/>
      <property name="linkDialogTemplate" scope="prototype" type="Object"/>
      <property name="tag" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TabIndent" superclass="dijit._editor._Plugin">
    <description>This plugin is used to allow the use of the tab and shift-tab keys
	to indent/outdent list items.  This overrides the default behavior
	of moving focus from/to the toolbar</description>
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="updateState" scope="prototype"/>
      <method name="_tabIndent" scope="prototype"/>
    </methods>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="command" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TabIndent.button">
    <properties>
      <property name="checked" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TabIndent.editor">
    <properties>
      <property name="isTabIndent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>This plugin provides dropdown color pickers for setting text color and background color</description>
    <properties>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ToggleDir" superclass="dijit._editor._Plugin">
    <description>This plugin is used to toggle direction of the edited document only,
	no matter what direction the whole page is.</description>
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="updateState" scope="prototype"/>
      <method name="_toggleDir" scope="prototype"/>
    </methods>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="command" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range">
    <methods>
      <method name="getIndex" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="index" type="Array" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="terminate dojo.every"/>
          <return-type type="carry on the every loop"/>
        </return-types>
      </method>
      <method name="getCommonAncestor" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getBlockAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="atBeginningOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="atEndOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="adjacentNoneTextNode" scope="instance">
        <parameters>
          <parameter name="startnode" type="Object" usage="required"/>
          <parameter name="next" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="getSelection" scope="instance">
        <parameters>
          <parameter name="win" type="Object" usage="required"/>
          <parameter name="ignoreUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="BlockTagNames" scope="instance" type="Object"/>
      <property name="_w3c" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.W3CRange">
    <methods>
      <method name="_simpleSetEndPoint" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateInternal" scope="prototype"/>
      <method name="setStart" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEnd" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartAfter" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartBefore" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndAfter" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndBefore" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="prototype">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="ext" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIERange" scope="prototype"/>
      <method name="getBookmark" scope="prototype">
        <parameters>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_select" scope="prototype"/>
      <method name="deleteContents" scope="prototype"/>
      <method name="cloneRange" scope="prototype"/>
      <method name="detach" scope="prototype"/>
    </methods>
    <properties>
      <property name="commonAncestorContainer" scope="instance" type="Object"/>
      <property name="collapsed" scope="instance" type="Object"/>
      <property name="startContainer" scope="instance" type="Object"/>
      <property name="startOffset" scope="instance" type="Object"/>
      <property name="endContainer" scope="instance" type="Object"/>
      <property name="endOffset" scope="instance" type="Object"/>
      <property name="_body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie">
    <methods>
      <method name="decomposeControlRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="container" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeTextRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="startContainter" type="Object" usage="required"/>
          <parameter name="startOffset" type="Object" usage="required"/>
          <parameter name="endContainter" type="Object" usage="required"/>
          <parameter name="endOffset" type="Object" usage="required"/>
          <parameter name="collapsed" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cachedSelection" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie.selection">
    <methods>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="internal" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="removeAllRanges" scope="instance"/>
      <method name="getRangeAt" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentSelection" scope="instance"/>
    </methods>
    <properties>
      <property name="_ranges" scope="instance" type="Object"/>
      <property name="rangeCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.selection">
    <methods>
      <method name="getType" scope="instance">
        <description>Get the selection type (like dojo.doc.select.type in IE).</description>
      </method>
      <method name="getSelectedText" scope="instance">
        <description>Return the text (no html tags) included in the current selection or null if no text is selected</description>
      </method>
      <method name="getSelectedHtml" scope="instance">
        <description>Return the html of the current selection or null if unavailable</description>
      </method>
      <method name="getSelectedElement" scope="instance">
        <description>Retrieves the selected element (if any), just in the case that
	a single element (object like and image or a table) is
	selected.</description>
      </method>
      <method name="getParentElement" scope="instance">
        <description>Get the parent element of the current selection</description>
      </method>
      <method name="hasAncestorElement" scope="instance">
        <description>Check whether current selection has a  parent element which is
	of type tagName (or one of the other specified tagName)</description>
        <parameters>
          <parameter name="tagName" type="String " usage="one-or-more"/>
        </parameters>
      </method>
      <method name="getAncestorElement" scope="instance">
        <description>Return the parent element of the current selection which is of
	type tagName (or one of the other specified tagName)</description>
        <parameters>
          <parameter name="tagName" type="String " usage="one-or-more"/>
        </parameters>
      </method>
      <method name="isTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="tags" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getParentOfType" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="tags" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="collapse" scope="instance">
        <description>clear current selection</description>
        <parameters>
          <parameter name="beginning" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <description>delete current selection</description>
      </method>
      <method name="selectElementChildren" scope="instance">
        <description>clear previous selection and select the content of the node
	(excluding the node itself)</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="nochangefocus" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="selectElement" scope="instance">
        <description>clear previous selection and select element (including all its children)</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="nochangefocus" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._tree">
    <properties>
      <property name="model" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tree.dndContainer">
    <description>a constructor of the Container</description>
    <methods>
      <method name="getItem" scope="prototype">
        <description>returns a data item by its key (id)
	console.log(&amp;quot;Container getItem()&amp;quot;, arguments,this.map, this.map[key], this.selection[key]);</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>event processor for onmouseover</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <description>event processor for onmouseout</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_changeState" scope="prototype">
        <description>changes a named state to new state value</description>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>a name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="prototype">
        <description>gets a child, which is under the mouse at the moment, or null</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItemClass" scope="prototype">
        <description>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="prototype">
        <description>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <description>this function is called once, when mouse is over our container</description>
      </method>
      <method name="onOutEvent" scope="prototype">
        <description>this function is called once, when mouse is out of our container</description>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="tree" scope="instance" type="Node">
        <description>node or node's id to build the container on</description>
      </property>
      <property name="map" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tree.dndSelector" superclass="dijit._tree.dndContainer">
    <methods>
      <method name="getSelectedItems" scope="prototype"/>
      <method name="getSelectedNodes" scope="prototype"/>
      <method name="selectNone" scope="prototype">
        <description>unselects all items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertItems" scope="prototype">
        <description>inserts new data items (see Container's insertNodes method for details)
	we actually need to add things to the store here instead of adding nodes directly to the tree</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype"/>
      <method name="onOverEvent" scope="prototype"/>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeSelection" scope="prototype">
        <description>unselects all items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="prototype">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="singular" scope="prototype" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="simpleSelection" scope="instance" type="Object"/>
      <property name="anchor" scope="instance" type="Object"/>
      <property name="onmousemoveEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tree.dndSelector.current">
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tree.dndSource" superclass="dijit._tree.dndSelector">
    <description>a constructor of the Source</description>
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="checkAcceptance" scope="prototype">
        <description>checks, if the target can accept nodes from this source</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="prototype">
        <description>Returns true, if we need to copy items, false to move.
	It is separated to be overwritten dynamically, if needed.</description>
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>the &amp;quot;copy&amp;quot; was pressed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>event processor for onmouseover</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkItemAcceptance" scope="prototype">
        <description>stub funciton to be overridden if one wants to check for the ability to drop at the node/item level</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="prototype">
        <description>topic event processor for /dnd/source/over, called when detected a current source</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="prototype">
        <description>topic event processor for /dnd/start, called to initiate the DnD operation</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="itemCreator" scope="prototype">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndDrop" scope="prototype">
        <description>Topic event processor for /dnd/drop, called to finish the DnD operation..
	Updates data store items according to where node was dragged from and dropped
	to.   The tree will then respond to those data store updates and redraw itself.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <description>topic event processor for /dnd/cancel, called to cancel the DnD operation</description>
      </method>
      <method name="onOverEvent" scope="prototype">
        <description>this function is called once, when mouse is over our container</description>
      </method>
      <method name="onOutEvent" scope="prototype">
        <description>this function is called once, when mouse is out of our container</description>
      </method>
      <method name="_markTargetAnchor" scope="prototype">
        <description>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status</description>
        <parameters>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before, if true, after otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <description>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status</description>
      </method>
      <method name="_markDndStatus" scope="prototype">
        <description>changes source's state based on &amp;quot;copy&amp;quot; status</description>
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isSource" scope="instance-prototype" type="Boolean">
        <description>can be used as a DnD source, if true; assumed to be &amp;quot;true&amp;quot; if omitted</description>
      </property>
      <property name="copyOnly" scope="prototype" type="Object"/>
      <property name="skipForm" scope="prototype" type="Object"/>
      <property name="dragThreshold" scope="prototype" type="Object"/>
      <property name="accept" scope="instance-prototype" type="Array">
        <description>list of accepted types (text strings) for a target; assumed to be [&amp;quot;text&amp;quot;] if omitted
	horizontal: Boolean: a horizontal container, if true, vertical otherwise or when omitted
	copyOnly: Boolean: always copy items, if true, use a state of Ctrl key otherwise
	skipForm: Boolean: don't start the drag operation, if clicked on form elements
	the rest of parameters are passed to the selector</description>
      </property>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="targetState" scope="instance" type="Object"/>
      <property name="targetBox" scope="instance" type="Object"/>
      <property name="mouseDown" scope="instance" type="Object"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="sourceState" scope="instance" type="Object"/>
      <property name="topics" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._tree.dndTarget" superclass="dijit._tree.dndSource">
    <description>a constructor of the Target --- see the Source constructor for details</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.model">
    <methods>
      <method name="destroy" scope="prototype">
        <description>destroys this object, releasing connections to the store</description>
      </method>
      <method name="getRoot" scope="prototype">
        <description>Calls onItem with the root item for the tree, possibly a fabricated item.
	Throws exception on error.</description>
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>returns identity for an item</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>get the label for an item</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="parent" type="Item" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="prototype">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form">
    <properties>
      <property name="Slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button" superclass="dijit.form._FormWidget">
    <description>Basically the same thing as a normal HTML button, but with special styling.</description>
    <example>
		&lt;button dojoType="dijit.form.Button" onClick="..."&gt;Hello world&lt;/button&gt;</example>
    <methods>
      <method name="_onClick" scope="prototype">
        <description>internal function to handle click actions</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="user click actions"/>
        </return-types>
      </method>
      <method name="_onButtonClick" scope="prototype">
        <description>callback when the user activates the button portion
	if is activated via a keystroke, stop the event</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="returning nothing is same as true"/>
        </return-types>
      </method>
      <method name="_fillContent" scope="prototype">
        <description>If button label is specified as srcNodeRef.innerHTML rather than
	this.params.label, handle it here.</description>
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="onClick" scope="prototype">
        <description>user callback for when button is clicked
	if type=&amp;quot;submit&amp;quot;, return true to perform submit</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="prototype">
        <description>internal replaceable function for when the button is clicked</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="prototype">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="prototype">
        <description>Hook for attr('label', ...) to work.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="label" scope="prototype" type="Object"/>
      <property name="showLabel" scope="instance-prototype" type="Boolean">
        <description>Set this to true to hide the label text and display only the icon.
	(If showLabel=false then iconClass must be specified.)
	Especially useful for toolbars.
	If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	The exception case is for computers in high-contrast mode, where the label
	will still be displayed, since the icon doesn't appear.</description>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <description>Class to apply to div in button to make it display an icon</description>
      </property>
      <property name="type" scope="instance-prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.DropDownButton" superclass="dijit.form.Button">
    <description>A button with a popup</description>
    <example>
		&lt;button dojoType="dijit.form.DropDownButton" label="Hello world"&gt;
			&lt;div dojotype="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
    <methods>
      <method name="_fillContent" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="destroyDescendants" scope="prototype"/>
      <method name="_onArrowClick" scope="prototype">
        <description>callback when the user mouse clicks on menu popup node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownKeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <description>callback when the user presses a key on menu popup node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>called magically when focus has shifted away from this widget and it's dropdown</description>
      </method>
      <method name="_toggleDropDown" scope="prototype">
        <description>toggle the drop-down widget; if it is up, close it, if not, open it</description>
      </method>
      <method name="_openDropDown" scope="prototype"/>
      <method name="_closeDropDown" scope="prototype">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_seenKeydown" scope="instance" type="Object"/>
      <property name="_opened" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.DropDownButton.dropDown.domNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton" superclass="dijit.form.DropDownButton">
    <description>A Normal Button with a DropDown</description>
    <example>
		&lt;button dojoType="dijit.form.ComboButton" onClick="..."&gt;
			&lt;span&gt;Hello world&lt;/span&gt;
			&lt;div dojoType="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="focusFocalNode" scope="prototype">
        <description>Focus the focal node node.</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasNextFocalNode" scope="prototype">
        <description>Returns true if this widget has no node currently
	focused or if there is a node following the focused one.
	False is returned if the last node has focus.</description>
      </method>
      <method name="focusNext" scope="prototype">
        <description>Focus the focal node following the current node with focus
	or the first one if no node currently has focus.</description>
      </method>
      <method name="hasPrevFocalNode" scope="prototype">
        <description>Returns true if this widget has no node currently
	focused or if there is a node before the focused one.
	False is returned if the first node has focus.</description>
      </method>
      <method name="focusPrev" scope="prototype">
        <description>Focus the focal node before the current node with focus
	or the last one if no node currently has focus.</description>
      </method>
      <method name="getFocalNodes" scope="prototype">
        <description>Returns an array of focal nodes for this widget.</description>
      </method>
      <method name="_onNodeFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeBlur" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype"/>
    </methods>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="optionsTitle" scope="prototype" type="String">
        <description>text that describes the options menu (accessibility)</description>
      </property>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_focusedNode" scope="instance-prototype" type="Object"/>
      <property name="_focalNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ToggleButton" superclass="dijit.form.Button">
    <description>A button that can be in two states (checked or not).
	Can be base class for things like tabs or checkbox or radio buttons</description>
    <methods>
      <method name="_clicked" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setChecked" scope="prototype">
        <description>Programatically deselect the button</description>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
    </methods>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="checked" scope="instance-prototype" type="Boolean">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.
	In markup, specified as &amp;quot;checked='checked'&amp;quot; or just &amp;quot;checked&amp;quot;.
	True if the button is depressed, or the checkbox is checked,
	or the radio button is selected, etc.</description>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.CheckBox" superclass="dijit.form.ToggleButton">
    <description>Same as an HTML checkbox, but with fancy styling.</description>
    <methods>
      <method name="_setValueAttr" scope="prototype">
        <description>Handler for value= attribute to constructor, and also calls to
	attr('value', val).</description>
        <parameters>
          <parameter name="newValue" type="String or Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works.</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="_onFocus" scope="prototype"/>
      <method name="_onBlur" scope="prototype"/>
    </methods>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="type" scope="prototype" type="Object"/>
      <property name="value" scope="instance-prototype" type="String">
        <description>As an initialization parameter, equivalent to value field on normal checkbox
	(if checked, the value is passed as the value when form is submitted).
	However, attr('value') will return either the string or false depending on
	whether or not the checkbox is checked.
	attr('value', string) will check the checkbox and change the value to the
	specified string
	attr('value', boolean) will change the checked state.</description>
      </property>
      <property name="_hasBeenBlurred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.RadioButton" superclass="dijit.form.CheckBox">
    <description>Same as an HTML radio, but with fancy styling.</description>
    <methods>
      <method name="_setCheckedAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="type" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin">
    <description>Implements the base functionality for ComboBox/FilteringSelect</description>
    <properties>
      <property name="item" scope="prototype" type="Object"/>
      <property name="pageSize" scope="prototype" type="Integer">
        <description>Argument to data provider.
	Specifies number of search results per page (before hitting &amp;quot;next&amp;quot; button)</description>
      </property>
      <property name="store" scope="prototype" type="Object">
        <description>Reference to data provider object used by this ComboBox</description>
      </property>
      <property name="fetchProperties" scope="prototype" type="Object">
        <description>Mixin to the dojo.data store's fetch.
	For example, to set the sort order of the ComboBox menu, pass:
	{sort:{attribute:&amp;quot;name&amp;quot;,descending:true}}</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu" superclass="dijit._Widget">
    <description>Focus-less div based menu for internal use in ComboBox</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPage" scope="prototype">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="createOptions" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
          <parameter name="labelFunc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearResultList" scope="prototype"/>
      <method name="getItems" scope="prototype"/>
      <method name="getListLength" scope="prototype"/>
      <method name="_onMouseDown" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="pageUp" scope="prototype"/>
      <method name="pageDown" scope="prototype"/>
      <method name="getHighlightedOption" scope="prototype">
        <description>Returns the highlighted option.</description>
      </method>
      <method name="handleKey" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_messages" scope="instance-prototype" type="Object"/>
      <property name="postCreate" scope="prototype" type="Object"/>
      <property name="onClose" scope="prototype" type="Object"/>
      <property name="_createOption" scope="prototype" type="Object"/>
      <property name="_onMouseOut" scope="prototype" type="Object"/>
      <property name="_focusOptionNode" scope="prototype" type="Object"/>
      <property name="_blurOptionNode" scope="prototype" type="Object"/>
      <property name="_highlightNextOption" scope="prototype" type="Object"/>
      <property name="highlightFirstOption" scope="prototype" type="Object"/>
      <property name="highlightLastOption" scope="prototype" type="Object"/>
      <property name="_highlightPrevOption" scope="prototype" type="Object"/>
      <property name="_page" scope="prototype" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.previousButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.nextButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBox" superclass="dijit.form.ValidationTextBox">
    <description>Auto-completing text box, and base class for dijit.form.FilteringSelect.</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', value) works.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit.form.ComboBoxMixin" scope="prototype"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ComboBoxDataStore">
    <description>Inefficient but small data store specialized for inlined ComboBox data</description>
    <methods>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype"/>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || args || null" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>Given the identity of an item, this method returns the item that has
	that identity through the onItem callback.
	Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchSelectedItem" scope="prototype">
        <description>Get the option marked as selected, like `&amp;lt;option selected&amp;gt;`.
	Not part of dojo.data API.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox" superclass="dijit.form.NumberTextBox">
    <description>A validating currency textbox</description>
    <methods>
      <method name="parse" scope="prototype">
        <description>parses the value as a Currency, according to constraints</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.currency.__ParseOptions" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
    </methods>
    <properties>
      <property name="currency" scope="prototype" type="String">
        <description>the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;</description>
      </property>
      <property name="regExpGen" scope="prototype" type="Object"/>
      <property name="_formatter" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox.__Constraints" superclass="dijit.form.NumberTextBox.__Constraints">
    <mixins scope="prototype">
      <mixin type="dojo.currency.__FormatOptions" scope="prototype"/>
      <mixin type="dojo.currency.__ParseOptions" scope="prototype"/>
      <mixin type="dojo.currency.__FormatOptions" scope="instance"/>
      <mixin type="dojo.currency.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.CurrencyTextBox.constraints">
    <properties>
      <property name="currency" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <description>A validating, serializable, range-bound date text box with a popup calendar</description>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="popupClass" scope="prototype" type="Object"/>
      <property name="_selector" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect" superclass="dijit.form.MappedTextBox">
    <methods>
      <method name="_callbackSetLabel" scope="prototype">
        <description>Callback function that dynamically sets the label of the
	ComboBox</description>
        <parameters>
          <parameter name="result" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook for attr('value') to work.</description>
      </method>
      <method name="_setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="displayedValue" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', value) works.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueFromItem" scope="prototype">
        <description>Set the displayed valued in the input box, based on a
	selected item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="labelFunc" scope="prototype">
        <description>Event handler called when the label changes
	return: the label that the ComboBox should display</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="store" type="dojo.data.store" usage="required"/>
        </parameters>
      </method>
      <method name="_doSelect" scope="prototype">
        <description>ComboBox's menu callback function</description>
        <parameters>
          <parameter name="tgt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <description>Hook so attr('displayedValue', label) works.</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="undo" scope="prototype"/>
      <method name="_valueChanged" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit.form.ComboBoxMixin" scope="prototype"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_isvalid" scope="instance-prototype" type="Object"/>
      <property name="required" scope="prototype" type="Object"/>
      <property name="_lastDisplayedValue" scope="instance-prototype" type="Object"/>
      <property name="isValid" scope="prototype" type="Object"/>
      <property name="_getValueField" scope="prototype" type="Object"/>
      <property name="item" scope="instance" type="Object"/>
      <property name="_lastQuery" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormMixin">
    <description>Widget corresponding to HTML form tag, for validation and serialization</description>
    <example>
		&lt;form dojoType="dijit.form.Form" id="myForm"&gt;
			Name: &lt;input type="text" name="name" /&gt;
		&lt;/form&gt;
		myObj = {name: "John Doe"};
		dijit.byId('myForm').attr('value', myObj);
		myObj=dijit.byId('myForm').attr('value');</example>
    <methods>
      <method name="reset" scope="prototype"/>
      <method name="validate" scope="prototype">
        <description>returns if the form is valid - same as isValid - but
	provides a few additional (ui-specific) features.
	1 - it will highlight any sub-widgets that are not
	valid
	2 - it will call focus() on the first invalid
	sub-widget</description>
      </method>
      <method name="setValues" scope="prototype">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Fill in form values from according to an Object (in the format returned by attr('value'))</description>
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="like &quot;continue&quot;"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype"/>
      <method name="_getValueAttr" scope="prototype">
        <description>Returns Object representing form values.</description>
        <example>
	 { name: "John Smith", interests: ["sports", "movies"] }</example>
        <return-types>
          <return-type type="like &quot;continue&quot;"/>
        </return-types>
      </method>
      <method name="isValid" scope="prototype">
        <description>make sure that every widget that has a validator function returns true</description>
      </method>
      <method name="onValidStateChange" scope="prototype">
        <description>stub function to connect to if you want to do something
	(like disable/enable a submit button) when the valid
	state changes on the form as a whole.</description>
        <parameters>
          <parameter name="isValid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_widgetChange" scope="prototype">
        <description>connected to a widgets onChange function - update our
	valid state, if needed.</description>
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectChildren" scope="prototype">
        <description>connects to the onChange function of all children to
	track valid state changes.  You can call this function
	directly, ie. in the event that you programmatically
	add a widget to the form *after* the form has been
	initialized</description>
      </method>
      <method name="startup" scope="prototype"/>
    </methods>
    <properties>
      <property name="_lastValidState" scope="instance" type="Object"/>
      <property name="_changeConnections" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormMixin._invalidWidgets">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form" superclass="dijit._Widget">
    <description>Adds conveniences to regular HTML form</description>
    <methods>
      <method name="execute" scope="prototype">
        <description>Deprecated: use submit()</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onExecute" scope="prototype">
        <description>Deprecated: use onSubmit()</description>
      </method>
      <method name="_setEncTypeAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="onReset" scope="prototype">
        <description>Callback when user resets the form. This method is intended
	to be over-ridden. When the `reset` method is called
	programmatically, the return value from `onReset` is used
	to compute whether or not resetting should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_onReset" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="the IE way"/>
        </return-types>
      </method>
      <method name="_onSubmit" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="prototype">
        <description>Callback when user submits the form. This method is
	intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the `submit`
	method is called programmatically, the return value from
	`onSubmit` is used to compute whether or not submission
	should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="prototype">
        <description>programmatically submit form if and only if the `onSubmit` returns true</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit.form._FormMixin" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="prototype" type="Object"/>
      <property name="action" scope="prototype" type="Object"/>
      <property name="method" scope="prototype" type="Object"/>
      <property name="encType" scope="instance-prototype" type="Object"/>
      <property name="accept-charset" scope="prototype" type="Object"/>
      <property name="accept" scope="prototype" type="Object"/>
      <property name="target" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="returnValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form.domNode">
    <properties>
      <property name="encoding" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MultiSelect" superclass="dijit.form._FormWidget">
    <description>Wrapper for a native select multiple=&amp;quot;true&amp;quot; element to
	interact with dijit.form.Form</description>
    <methods>
      <method name="reset" scope="prototype"/>
      <method name="addSelected" scope="prototype">
        <description>Move the selected nodes af an passed Select widget
	instance to this Select widget.</description>
        <example>
		// move all the selected values from "bar" to "foo"
	 	dijit.byId("foo").addSelected(dijit.byId("bar"));</example>
        <parameters>
          <parameter name="select" type="dijit.form.MultiSelect" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype">
        <description>Access the NodeList of the selected options directly</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works.</description>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', values) works.</description>
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="invertSelection" scope="prototype">
        <description>Invert the selection</description>
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <description>If null, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onChange" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <properties>
      <property name="size" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_multiValue" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MultiSelect.domNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberSpinner" superclass="dijit.form._Spinner">
    <description>extends NumberTextBox to add up/down arrows and pageup/pagedown for incremental change to the value</description>
    <methods>
      <method name="adjust" scope="prototype">
        <description>change Number val by the given amount</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit.form.NumberTextBoxMixin" scope="prototype"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberSpinner.constraints">
    <properties>
      <property name="max" scope="instance" type="Object"/>
      <property name="min" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox" superclass="dijit.form.RangeBoundTextBox">
    <description>A validating, serializable, range-bound text box.</description>
    <mixins scope="prototype">
      <mixin type="dijit.form.NumberTextBoxMixin" scope="prototype"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <mixins scope="prototype">
      <mixin type="dojo.number.__FormatOptions" scope="prototype"/>
      <mixin type="dojo.number.__ParseOptions" scope="prototype"/>
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBoxMixin">
    <description>A mixin for all number textboxes</description>
    <methods>
      <method name="_onFocus" scope="prototype"/>
      <method name="format" scope="prototype">
        <description>formats the value as a Number, according to constraints</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <description>parses the value as a Number, according to constraints</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.number.__ParseOptions" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="attr('value', null"/>
          <return-type type="Object"/>
          <return-type type="''"/>
          <return-type type="undefined) should fire onChange(NaN)"/>
        </return-types>
      </method>
      <method name="serialize" scope="prototype">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works.</description>
      </method>
    </methods>
    <properties>
      <property name="regExpGen" scope="prototype" type="Object"/>
      <property name="constraints" scope="prototype" type="dijit.form.NumberTextBox.__Constraints"/>
      <property name="_formatter" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.editOptions">
    <description>properties to mix into constraints when the value is being edited</description>
    <properties>
      <property name="pattern" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea" superclass="dijit.form.TextBox">
    <description>A simple textarea that degrades, and responds to
	minimal LayoutContainer usage, and works with dijit.form.Form.
	Doesn't automatically size according to input, like Textarea.</description>
    <example>
		&lt;textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40/&gt;</example>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="rows" scope="prototype" type="Number">
        <description>The number of characters per line.</description>
      </property>
      <property name="cols" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversed" scope="prototype"/>
      <method name="_onBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', value) works.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="_bumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="prototype"/>
      <method name="_onClkDecBumper" scope="prototype"/>
      <method name="decrement" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="increment" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="prototype">
        <description>Event handler for mousewheel where supported</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_typematicCallback" scope="prototype">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="button" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="Object"/>
      <property name="showButtons" scope="prototype" type="boolean">
        <description>Show increment/decrement buttons at the ends of the slider?</description>
      </property>
      <property name="minimum" scope="prototype" type="integer">
        <description>The minimum value allowed.</description>
      </property>
      <property name="maximum" scope="prototype" type="integer">
        <description>The maximum allowed value.</description>
      </property>
      <property name="discreteValues" scope="prototype" type="integer">
        <description>The maximum allowed values dispersed evenly between minimum and maximum (inclusive).</description>
      </property>
      <property name="pageIncrement" scope="prototype" type="integer">
        <description>The amount of change via pageup/down</description>
      </property>
      <property name="clickSelect" scope="prototype" type="boolean">
        <description>If clicking the progress bar changes the value or not</description>
      </property>
      <property name="slideDuration" scope="prototype" type="Number">
        <description>The time in ms to take to animate the slider handle from 0% to 100%</description>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_mousePixelCoord" scope="prototype" type="Object"/>
      <property name="_pixelCount" scope="prototype" type="Object"/>
      <property name="_startingPixelCoord" scope="prototype" type="Object"/>
      <property name="_startingPixelCount" scope="prototype" type="Object"/>
      <property name="_handleOffsetCoord" scope="prototype" type="Object"/>
      <property name="_progressPixelSize" scope="prototype" type="Object"/>
      <property name="_descending" scope="instance" type="Object"/>
      <property name="_inProgressAnim" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="_movable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.incrementButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.decrementButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalSlider" superclass="dijit.form.HorizontalSlider">
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="_isReversed" scope="prototype"/>
      <method name="_rtlRectify" scope="prototype">
        <description>Rectify children nodes for left/right decoration in rtl case.
	Simply switch the rule and label child for each decoration node.</description>
        <parameters>
          <parameter name="decorationNode" type="NodeList" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_mousePixelCoord" scope="prototype" type="Object"/>
      <property name="_pixelCount" scope="prototype" type="Object"/>
      <property name="_startingPixelCoord" scope="prototype" type="Object"/>
      <property name="_startingPixelCount" scope="prototype" type="Object"/>
      <property name="_handleOffsetCoord" scope="prototype" type="Object"/>
      <property name="_progressPixelSize" scope="prototype" type="Object"/>
      <property name="_descending" scope="prototype" type="boolean">
        <description>Specifies if the slider values go from high-on-top (true), or low-on-top (false)
	TODO: expose this in 1.2 - the css progress/remaining bar classes need to be reversed</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._SliderMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form.HorizontalRule" superclass="dijit._Widget">
    <methods>
      <method name="_genHTML" scope="prototype">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="count" scope="instance-prototype" type="Integer">
        <description>Number of hash marks to generate</description>
      </property>
      <property name="container" scope="prototype" type="Node">
        <description>If this is a child widget, connect it to this parent node</description>
      </property>
      <property name="ruleStyle" scope="prototype" type="String">
        <description>CSS style to apply to individual hash marks</description>
      </property>
      <property name="_positionPrefix" scope="prototype" type="Object"/>
      <property name="_positionSuffix" scope="prototype" type="Object"/>
      <property name="_suffix" scope="prototype" type="Object"/>
      <property name="_isHorizontal" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalRule" superclass="dijit.form.HorizontalRule">
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_positionPrefix" scope="prototype" type="Object"/>
      <property name="_isHorizontal" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels" superclass="dijit.form.HorizontalRule">
    <methods>
      <method name="_calcPosition" scope="prototype">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_genHTML" scope="prototype">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabels" scope="prototype">
        <description>user replaceable function to return the labels array</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="labelStyle" scope="prototype" type="String">
        <description>CSS style to apply to individual text labels</description>
      </property>
      <property name="labels" scope="instance-prototype" type="Array">
        <description>Array of text labels to render - evenly spaced from left-to-right or bottom-to-top</description>
      </property>
      <property name="numericMargin" scope="prototype" type="Integer">
        <description>Number of generated numeric labels that should be rendered as '' on the ends when labels[] are not specified</description>
      </property>
      <property name="minimum" scope="prototype" type="Object"/>
      <property name="maximum" scope="prototype" type="Object"/>
      <property name="_positionPrefix" scope="prototype" type="Object"/>
      <property name="_labelPrefix" scope="prototype" type="Object"/>
      <property name="_suffix" scope="prototype" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.constraints">
    <description>pattern, places, lang, et al (see dojo.number) for generated numeric labels when labels[] are not specified</description>
    <properties>
      <property name="pattern" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.srcNodeRef">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalRuleLabels" superclass="dijit.form.HorizontalRuleLabels">
    <methods>
      <method name="_calcPosition" scope="prototype">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_positionPrefix" scope="prototype" type="Object"/>
      <property name="_labelPrefix" scope="prototype" type="Object"/>
      <property name="_isHorizontal" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox" superclass="dijit.form._FormValueWidget">
    <description>A base class for textbox form inputs</description>
    <methods>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works as we like.</description>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', ...) works.</description>
        <parameters>
          <parameter name="value" type="The" usage="required">
            <description>visual element value is also set to a corresponding,
	but not necessarily the same, value.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>If true, an onChange event is fired immediately instead of
	waiting for the next blur event.</description>
          </parameter>
          <parameter name="formattedValue" type="String" usage="optional">
            <description>If specified, used to set the visual element value,
	otherwise a computed visual value is used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getDisplayedValue" scope="prototype"/>
      <method name="_getDisplayedValueAttr" scope="prototype">
        <description>Hook so attr('displayedValue') works.</description>
      </method>
      <method name="setDisplayedValue" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <description>Hook so attr('displayedValue', ...) works.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <description>Replacable function to convert a value to a properly formatted string</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <description>Replacable function to convert a formatted string to a value</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="filter" scope="prototype">
        <description>Auto-corrections (such as trimming) that are applied to textbox
	value on blur or form submit</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="prototype"/>
      <method name="_onBlur" scope="prototype"/>
    </methods>
    <properties>
      <property name="trim" scope="prototype" type="Object"/>
      <property name="uppercase" scope="prototype" type="Boolean">
        <description>Converts all characters to uppercase if true.  Default is false.</description>
      </property>
      <property name="lowercase" scope="prototype" type="Boolean">
        <description>Converts all characters to lowercase if true.  Default is false.</description>
      </property>
      <property name="propercase" scope="prototype" type="Boolean">
        <description>Converts the first character of each word to uppercase if true.</description>
      </property>
      <property name="maxLength" scope="prototype" type="String">
        <description>HTML INPUT tag maxLength declaration.</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="displayedValue" scope="prototype" type="String">
        <description>For subclasses like ComboBox where the displayed value
	(ex: Kentucky) and the serialized value (ex: KY) are different,
	this represents the displayed value.
	Setting 'displayedValue' through attr('displayedValue', ...)
	updates 'value', and vice-versa.  Othewise 'value' is updated
	from 'displayedValue' periodically, like onBlur etc.
	TODO: move declaration to MappedTextBox?
	Problem is that ComboBox references displayedValue,
	for benefit of FilteringSelect.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.TextBox.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea" superclass="dijit.form._FormValueWidget">
    <description>A resizing textarea widget</description>
    <example>
		&lt;textarea dojoType="dijit.form.TextArea"&gt;...&lt;/textarea&gt;</example>
    <methods>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustWritable" scope="prototype">
        <description>set whether user can write into textbox, based on this.disabled and this.readOnly</description>
      </method>
      <method name="focus" scope="prototype">
        <description>Received focus, needed for the InlineEditBox widget</description>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', ...) works.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works.</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_focusedEventNode" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurredEventNode" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onIframeBlur" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changing" scope="prototype">
        <description>event handler for when a change is imminent</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changed" scope="prototype">
        <description>event handler for when a change has already happened</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="readOnly" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="lastHeight" scope="instance" type="Object"/>
      <property name="_iframeEditTitle" scope="instance" type="Object"/>
      <property name="_iframeFocusTitle" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="eventNode" scope="instance" type="Object"/>
      <property name="_focused" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.formValueNode">
    <properties>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.editNode">
    <properties>
      <property name="contentEditable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.iframe.contentDocument">
    <properties>
      <property name="designMode" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.srcNodeRef">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.domNode.style">
    <properties>
      <property name="overflowY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.iframe">
    <properties>
      <property name="postCreate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.iframe.style">
    <properties>
      <property name="overflowY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox" superclass="dijit.form._DateTimeTextBox">
    <description>A validating, serializable, range-bound time text box with a popup time picker</description>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="popupClass" scope="prototype" type="Object"/>
      <property name="_selector" scope="prototype" type="Object"/>
      <property name="constraints" scope="prototype" type="dijit.form.TimeTextBox.__Constraints"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox.__Constraints" superclass="dijit.form._DateTimeTextBox.__Constraints">
    <mixins scope="prototype">
      <mixin type="dijit._TimePicker.__Constraints" scope="prototype"/>
      <mixin type="dijit._TimePicker.__Constraints" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ValidationTextBox" superclass="dijit.form.TextBox">
    <description>A TextBox subclass with the ability to validate content of various types and provide user feedback.</description>
    <methods>
      <method name="regExpGen" scope="prototype">
        <description>user replaceable function used to generate regExp when dependent on constraints
	Do not specify both regExp and regExpGen</description>
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', ...) works.</description>
      </method>
      <method name="validator" scope="prototype">
        <description>user replaceable function used to validate the text input against the regular expression.</description>
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="prototype">
        <description>Returns true if the value is either already valid or could be made valid by appending characters.</description>
      </method>
      <method name="isValid" scope="prototype">
        <description>Need to over-ride with your own validation code in subclasses</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="prototype">
        <description>Checks for whitespace</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getErrorMessage" scope="prototype">
        <description>return an error message to show if appropriate</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getPromptMessage" scope="prototype">
        <description>return a hint to show if appropriate</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="prototype">
        <description>Called by oninit, onblur, and onkeypress.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="prototype">
        <description>User overridable method to display validation errors/hints.
	By default uses a tooltip.</description>
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="prototype"/>
      <method name="_update" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="required" scope="instance-prototype" type="default">
        <description>values for new subclass properties
	Boolean
	Can be true or false, default is false.</description>
      </property>
      <property name="promptMessage" scope="prototype" type="String">
        <description>Hint string</description>
      </property>
      <property name="invalidMessage" scope="instance-prototype" type="String">
        <description>The message to display if value is invalid.</description>
      </property>
      <property name="regExp" scope="instance-prototype" type="String">
        <description>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</description>
      </property>
      <property name="state" scope="instance-prototype" type="String">
        <description>Shows current state (ie, validation result) of input (Normal, Warning, or Error)</description>
      </property>
      <property name="tooltipPosition" scope="prototype" type="String[]">
        <description>See description of dijit.Tooltip.defaultPosition for details on this parameter.</description>
      </property>
      <property name="_maskValidSubsetError" scope="instance-prototype" type="Object"/>
      <property name="_message" scope="instance-prototype" type="Object"/>
      <property name="messages" scope="instance" type="Object"/>
      <property name="_partialre" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.constraints">
    <description>user-defined object needed to pass parameters to the validator functions</description>
    <properties>
      <property name="locale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.valueNode">
    <properties>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.focusNode.style">
    <properties>
      <property name="fontFamily" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox" superclass="dijit.form.ValidationTextBox">
    <description>A dijit.form.ValidationTextBox subclass which provides a visible formatted display and a serializable
	value in a hidden input field which is actually sent to the server.  The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the serveris defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
    <methods>
      <method name="serialize" scope="prototype">
        <description>user replaceable function used to convert the attr('value') result to a String</description>
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <description>display the widget as a printable string using the widget's value
	TODO: seems like the filter() call here is unnecessary as attr('value') should do that</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="prototype"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form.MappedTextBox.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox.textbox">
    <properties>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox" superclass="dijit.form.MappedTextBox">
    <description>A dijit.form.MappedTextBox subclass which defines a range of valid values</description>
    <methods>
      <method name="rangeCheck" scope="prototype">
        <description>user replaceable function used to validate the range of the numeric input value</description>
        <parameters>
          <parameter name="primitive" type="Number" usage="required"/>
          <parameter name="constraints" type="dijit.form.RangeBoundTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="prototype">
        <description>Need to over-ride with your own validation code in subclasses</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isDefinitelyOutOfRange" scope="prototype">
        <description>Returns true if the value is out of range and will remain
	out of range even if the user types more characters</description>
      </method>
      <method name="_isValidSubset" scope="prototype"/>
      <method name="isValid" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', ...) works.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="constraints" scope="prototype" type="dijit.form.RangeBoundTextBox.__Constraints"/>
      <property name="rangeMessage" scope="instance-prototype" type="String">
        <description>The message to display if value is out-of-range</description>
      </property>
      <property name="messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.__Constraints">
    <properties>
      <property name="locale" scope="instance" type="String">
        <description>locale used for validation, picks up value from this widget's lang attribute</description>
      </property>
      <property name="_flags_" scope="instance" type="anything">
        <description>various flags passed to regExpGen function</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox.__Constraints">
    <properties>
      <property name="min" scope="instance" type="Number">
        <description>Minimum signed value.  Default is -Infinity</description>
      </property>
      <property name="max" scope="instance" type="Number">
        <description>Maximum signed value.  Default is +Infinity</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox" superclass="dijit.form.RangeBoundTextBox">
    <description>A validating, serializable, range-bound date or time text box.</description>
    <methods>
      <method name="format" scope="prototype">
        <description>formats the value as a Date, according to constraints</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <description>parses the value as a Date, according to constraints</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_onFocus" scope="prototype">
        <description>open the TimePicker popup</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>Sets the date on this textbox.  Note that `value` must be a Javascript Date object.</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype">
        <description>opens the TimePicker, and sets the onValueSelected value</description>
      </method>
      <method name="_close" scope="prototype"/>
      <method name="_onBlur" scope="prototype">
        <description>called magically when focus has shifted away from this widget and it's dropdown</description>
      </method>
      <method name="_getDisplayedValueAttr" scope="prototype"/>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="constraints" scope="prototype" type="dijit.form._DateTimeTextBox.__Constraints"/>
      <property name="regExpGen" scope="prototype" type="Object"/>
      <property name="compare" scope="prototype" type="Object"/>
      <property name="serialize" scope="prototype" type="Object"/>
      <property name="value" scope="instance-prototype" type="Date">
        <description>The value of this widget as a JavaScript Date object.  Use attr(&amp;quot;value&amp;quot;) / attr(&amp;quot;value&amp;quot;, val) to manipulate.
	When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`</description>
      </property>
      <property name="popupClass" scope="prototype" type="String">
        <description>Name of the popup widget class used to select a date/time</description>
      </property>
      <property name="_selector" scope="prototype" type="Object"/>
      <property name="_picker" scope="instance" type="Object"/>
      <property name="_opened" scope="instance" type="Object"/>
      <property name="_tabbingAway" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <mixins scope="prototype">
      <mixin type="dojo.date.locale.__FormatOptions" scope="prototype"/>
      <mixin type="dojo.date.locale.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._FormWidget" superclass="dijit._Widget">
    <description>_FormWidget's correspond to native HTML elements such as &amp;lt;checkbox&amp;gt; or &amp;lt;button&amp;gt;.</description>
    <methods>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <description>Set disabled state of widget (Deprecated).</description>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="prototype">
        <description>Sets _hovering, _active, and stateModifier properties depending on mouse state,
	then calls setStateClass() to set appropriate CSS classes for this.domNode.
	To get a different CSS class for hover, send onmouseover and onmouseout events to this method.
	To get a different CSS class while mouse button is depressed, send onmousedown to this method.</description>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="prototype"/>
      <method name="focus" scope="prototype"/>
      <method name="_setStateClass" scope="prototype"/>
      <method name="compare" scope="prototype">
        <description>compare 2 values</description>
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>callback when value is changed</description>
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="prototype">
        <description>set the value of the widget.</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype"/>
      <method name="_layoutHack" scope="prototype">
        <description>work around table sizing bugs on FF2 by forcing redraw</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String">
        <description>Root CSS class of the widget (ex: dijitTextBox), used to add CSS classes of widget
	(ex: &amp;quot;dijitTextBox dijitTextBoxInvalid dijitTextBoxFocused dijitTextBoxInvalidFocused&amp;quot;)
	See _setStateClass().</description>
      </property>
      <property name="name" scope="prototype" type="String">
        <description>Name used when submitting form; same as &amp;quot;name&amp;quot; attribute or plain HTML elements</description>
      </property>
      <property name="alt" scope="prototype" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="value" scope="prototype" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="type" scope="prototype" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="tabIndex" scope="prototype" type="Integer">
        <description>Order fields are traversed when user hits the tab key</description>
      </property>
      <property name="disabled" scope="instance-prototype" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;disabled='disabled'&amp;quot;, or just &amp;quot;disabled&amp;quot;.</description>
      </property>
      <property name="readOnly" scope="prototype" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted</description>
      </property>
      <property name="intermediateChanges" scope="prototype" type="Boolean">
        <description>Fires onChange for each value change or only on demand</description>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_scroll" scope="prototype" type="Object"/>
      <property name="_onChangeActive" scope="instance-prototype" type="Object"/>
      <property name="_hovering" scope="instance" type="Object"/>
      <property name="_active" scope="instance" type="Object"/>
      <property name="stateModifier" scope="instance" type="Object"/>
      <property name="_mouseDown" scope="instance" type="Object"/>
      <property name="_stateClasses" scope="instance" type="Object"/>
      <property name="_lastValue" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_layoutHackHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget" superclass="dijit.form._FormWidget">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <description>Hook so attr('value', value) works.</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <description>Hook so attr('value') works.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="undo" scope="prototype">
        <description>restore the value to the last value passed to onChange</description>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="_valueChanged" scope="prototype"/>
      <method name="_onKeyDown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner" superclass="dijit.form.RangeBoundTextBox">
    <methods>
      <method name="adjust" scope="prototype">
        <description>user replaceable function used to adjust a primitive value(Number/Date/...) by the delta amount specified
	the val is adjusted in a way that makes sense to the object type</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowState" scope="prototype">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="pressed" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowPressed" scope="prototype">
        <parameters>
          <parameter name="nodePressed" type="Node" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="increment" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowReleased" scope="prototype">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_typematicCallback" scope="prototype">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="prototype">
        <description>Mouse wheel listener where supported</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <properties>
      <property name="defaultTimeout" scope="prototype" type="Object"/>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <description>fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</description>
      </property>
      <property name="smallDelta" scope="prototype" type="Number">
        <description>adjust the value by this much when spinning using the arrow keys/buttons</description>
      </property>
      <property name="largeDelta" scope="prototype" type="Number">
        <description>adjust the value by this much when spinning using the PgUp/Dn keys</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_wheelTimer" scope="instance-prototype" type="Object"/>
      <property name="_active" scope="instance" type="Object"/>
      <property name="stateModifier" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner.upArrowNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner.downArrowNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner.focusNode.parentNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout"/>
  <class type="dijit.layout.AccordionContainer" superclass="dijit.layout.StackContainer">
    <description>Holds a set of panes where every pane's title is visible, but only one pane's content is visible at a time,
	and switching between panes is visualized by sliding the other panes up/down.</description>
    <example>
	 	&lt;div dojoType="dijit.layout.AccordionContainer"&gt;
			&lt;div dojoType="dijit.layout.AccordionPane" title="pane 1"&gt;
				&lt;div dojoType="dijit.layout.ContentPane"&gt;...&lt;/div&gt;
	 	&lt;/div&gt;
			&lt;div dojoType="dijit.layout.AccordionPane" title="pane 2"&gt;
				&lt;p&gt;This is some text&lt;/p&gt;
	|		...
		&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_getTargetHeight" scope="prototype">
        <description>For the given node, returns the height that should be
	set to achieve our vertical space (subtract any padding
	we may have)</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype">
        <description>Set the height of the open pane based on what room remains</description>
      </method>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="page" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <parameters>
          <parameter name="newWidget" type="Widget" usage="optional"/>
          <parameter name="oldWidget" type="Widget" usage="optional"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="duration" scope="prototype" type="Integer">
        <description>Amount of time (in ms) it takes to slide panes</description>
      </property>
      <property name="_verticalSpace" scope="instance-prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_inTransition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionPane" superclass="dijit.layout.ContentPane">
    <description>AccordionPane is a ContentPane with a title that may contain another widget.
	Nested layout widgets, such as SplitContainer, are not supported at this time.</description>
    <example>
	 see dijit.layout.AccordionContainer</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="getTitleHeight" scope="prototype">
        <description>returns the height of the title dom node</description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_onTitleClick" scope="prototype">
        <description>callback when someone clicks my title</description>
      </method>
      <method name="_onTitleEnter" scope="prototype">
        <description>callback when someone hovers over my title</description>
      </method>
      <method name="_onTitleLeave" scope="prototype">
        <description>callback when someone stops hovering over my title</description>
      </method>
      <method name="_onTitleKeyPress" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedState" scope="prototype">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_handleFocus" scope="prototype">
        <description>handle the blur and focus state of this widget</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <description>change the selected state on this pane</description>
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <description>called when this pane is selected</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer" superclass="dijit.layout._LayoutWidget">
    <description>Provides layout in 5 regions, a center and borders along its 4 sides.</description>
    <example>
		&lt;style&gt;
			html, body { height: 100%; width: 100%; }
		&lt;/style&gt;
		&lt;div dojoType="BorderContainer" design="sidebar" style="width: 100%; height: 100%"&gt;
			&lt;div dojoType="ContentPane" region="top"&gt;header text&lt;/div&gt;
			&lt;div dojoType="ContentPane" region="right" style="width: 200px;"&gt;table of contents&lt;/div&gt;
			&lt;div dojoType="ContentPane" region="center"&gt;client area&lt;/div&gt;
		&lt;/div&gt;</example>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_computeSplitterThickness" scope="prototype">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype"/>
      <method name="getSplitter" scope="prototype">
        <description>returns the widget responsible for rendering the splitter associated with region</description>
        <parameters>
          <parameter name="region" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="newSize" type="Object" usage="required"/>
          <parameter name="currentSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="prototype">
        <parameters>
          <parameter name="changedRegion" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="design" scope="instance-prototype" type="Object"/>
      <property name="gutters" scope="prototype" type="Boolean">
        <description>Give each pane a border and margin.
	Margin determined by domNode.paddingLeft.
	When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.</description>
      </property>
      <property name="liveSplitters" scope="prototype" type="Boolean">
        <description>specifies whether splitters resize as you drag (true) or only upon mouseup (false)</description>
      </property>
      <property name="persist" scope="prototype" type="Boolean">
        <description>Save splitter positions in a cookie.</description>
      </property>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_splitterClass" scope="prototype" type="String">
        <description>Optional hook to override the default Splitter widget used by BorderContainer</description>
      </property>
      <property name="_splitters" scope="instance" type="Object"/>
      <property name="_splitterThickness" scope="instance" type="Object"/>
      <property name="cs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer.pe">
    <properties>
      <property name="r" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter" superclass="dijit._Widget">
    <description>A draggable spacer between two items in a BorderContainer</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_computeMaxSize" scope="prototype"/>
      <method name="_stopDrag" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupHandlers" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="container" scope="prototype" type="Object"/>
      <property name="child" scope="prototype" type="Object"/>
      <property name="region" scope="prototype" type="Object"/>
      <property name="live" scope="prototype" type="Boolean">
        <description>If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	otherwise, the size doesn't change until you drop the splitter (by mouse-up)</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="_factor" scope="instance" type="Object"/>
      <property name="_minSize" scope="instance" type="Object"/>
      <property name="_cookieName" scope="instance" type="Object"/>
      <property name="_maxSize" scope="instance" type="Object"/>
      <property name="cover" scope="instance" type="Object"/>
      <property name="_resize" scope="instance" type="Object"/>
      <property name="fake" scope="instance" type="Object"/>
      <property name="_handlers" scope="instance" type="Object"/>
      <property name="_drag" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter._startDrag">
    <methods>
      <method name="_drag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="forceResize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.layout._Splitter.child.domNode">
    <properties>
      <property name="_recalc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.cover.style">
    <properties>
      <property name="zIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.oppNode">
    <properties>
      <property name="_recalc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Gutter" superclass="dijit._Widget">
    <description>Just a spacer div to separate side pane from center pane.
	Basically a trick to lookup the gutter/splitter width from the theme.</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="horizontal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="topSplitter">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="bottomSplitter">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="leftSplitter">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="rightSplitter">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="centerStyle">
    <properties>
      <property name="top" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="bottom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane" superclass="dijit._Widget">
    <description>A widget that acts as a Container for other widgets, and includes a ajax interface</description>
    <example>Some quick samples:
	To change the innerHTML use .attr('content', '&lt;b&gt;new content&lt;/b&gt;')
	Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	please note that the nodes in NodeList will copied, not moved
	To do a ajax update use .attr('href', url)</example>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_checkIfSingleChild" scope="prototype">
        <description>Test if we have exactly one visible widget as a child,
	and if so assume that we are a container for that widget,
	and should propogate startup() and resize() calls to it.
	Skips over things like data stores since they aren't visible.</description>
      </method>
      <method name="refresh" scope="prototype">
        <description>Force a refresh (re-download) of content, be sure to turn off cache</description>
      </method>
      <method name="setHref" scope="prototype">
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="_setHrefAttr" scope="prototype">
        <description>Hook so attr(&amp;quot;href&amp;quot;, ...) works.</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <description>url to the page you want to get, must be within the same domain as your mainpage</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="prototype">
        <description>Hook to make attr(&amp;quot;content&amp;quot;, ...) work.
	Replaces old content with data content, include style classes from old content</description>
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required">
            <description>the new Content may be String, DomNode or NodeList
	if data is a NodeList (or an array of nodes) nodes are copied
	so you can import nodes from another document implicitly</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getContentAttr" scope="prototype">
        <description>hook to make attr(&amp;quot;content&amp;quot;) work</description>
      </method>
      <method name="cancel" scope="prototype">
        <description>Cancels a inflight download of content</description>
      </method>
      <method name="destroyRecursive" scope="prototype">
        <description>Destroy the ContentPane and it's contents</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareLoad" scope="prototype">
        <parameters>
          <parameter name="forceLoad" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isShown" scope="prototype">
        <description>returns true if the content is currently shown</description>
        <return-types>
          <return-type type="for TitlePane, etc."/>
        </return-types>
      </method>
      <method name="_loadCheck" scope="prototype">
        <parameters>
          <parameter name="forceLoad" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_downloadExternalContent" scope="prototype"/>
      <method name="_onLoadHandler" scope="prototype">
        <description>This is called whenever new content is being loaded</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnloadHandler" scope="prototype">
        <description>This is called whenever the content is being unloaded</description>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <description>Destroy all the widgets inside the ContentPane and empty containerNode</description>
      </method>
      <method name="_setContent" scope="prototype">
        <description>Insert the content into the container node</description>
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
          <parameter name="isFakeContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onError" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSubWidgets" scope="prototype">
        <description>scan my contents and create subwidgets</description>
      </method>
      <method name="onLoad" scope="prototype">
        <description>Event hook, is called after everything is loaded and widgetified</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUnload" scope="prototype">
        <description>Event hook, is called before old content is cleared</description>
      </method>
      <method name="onDownloadStart" scope="prototype">
        <description>called before download starts
	the string returned by this function will be the html
	that tells the user we are loading something
	override with your own function if you want to change text</description>
      </method>
      <method name="onContentError" scope="prototype">
        <description>called on DOM faults, require fault etc in content
	default is to display errormessage inside pane</description>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadError" scope="prototype">
        <description>Called when download error occurs, default is to display
	errormessage inside pane. Overide function to change that.
	The string returned by this function will be the html
	that tells the user a error happend</description>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadEnd" scope="prototype">
        <description>called when download is finished</description>
      </method>
    </methods>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="content" scope="prototype" type="String">
        <description>The innerHTML of the ContentPane.
	Note that the initialization parameter / argument to attr(&amp;quot;content&amp;quot;, ...)
	can be a String, DomNode, Nodelist, or widget.</description>
      </property>
      <property name="extractContent" scope="prototype" type="Boolean">
        <description>Extract visible content from inside of &amp;lt;body&amp;gt; .... &amp;lt;/body&amp;gt;</description>
      </property>
      <property name="parseOnLoad" scope="prototype" type="Boolean">
        <description>parse content and create the widgets, if any</description>
      </property>
      <property name="preventCache" scope="prototype" type="Boolean">
        <description>Cache content retreived externally</description>
      </property>
      <property name="preload" scope="prototype" type="Boolean">
        <description>Force load of data even if pane is hidden.</description>
      </property>
      <property name="refreshOnShow" scope="prototype" type="Boolean">
        <description>Refresh (re-download) content when pane goes from hidden to shown</description>
      </property>
      <property name="loadingMessage" scope="instance-prototype" type="String">
        <description>Message that shows while downloading</description>
      </property>
      <property name="errorMessage" scope="instance-prototype" type="String">
        <description>Message that shows if an error occurs</description>
      </property>
      <property name="isLoaded" scope="instance-prototype" type="Boolean">
        <description>Tells loading status see onLoad|onUnload for event hooks</description>
      </property>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="doLayout" scope="prototype" type="Boolean">
        <description>- false - don't adjust size of children
	- true - if there is a single visible child widget, set it's size to
	however big the ContentPane is</description>
      </property>
      <property name="_isRealContent" scope="instance-prototype" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="isContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane.domNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo">
    <methods>
      <method name="blendColors" scope="instance">
        <description>blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
	can reuse a previously allocated dojo.Color object for the result</description>
        <parameters>
          <parameter name="start" type="dojo.Color" usage="required"/>
          <parameter name="end" type="dojo.Color" usage="required"/>
          <parameter name="weight" type="Number" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromRgb" scope="instance">
        <description>get rgb(a) array from css-style color declarations</description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromHex" scope="instance">
        <description>converts a hex string with a '#' prefix to a color object.
	Supports 12-bit #rgb shorthand.</description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromArray" scope="instance">
        <description>builds a color from 1, 2, 3, or 4 element array</description>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromString" scope="instance">
        <description>parses str for a color value.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>a dojo.Color object. If obj is passed, it will be the return value.</return-description>
      </method>
      <method name="deprecated" scope="instance">
        <description>Log a debug message to indicate that a behavior has been
	deprecated.</description>
        <example>
		dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");</example>
        <parameters>
          <parameter name="behaviour" type="String" usage="required">
            <description>The API or behavior being deprecated. Usually in the form
	of &amp;quot;myApp.someFunction()&amp;quot;.</description>
          </parameter>
          <parameter name="extra" type="String" usage="optional">
            <description>Text to append to the message.</description>
          </parameter>
          <parameter name="removal" type="String" usage="optional">
            <description>Text to indicate when in the future the behavior will be removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <description>Adds all properties and methods of props to obj. This addition
	is &amp;quot;prototype extension safe&amp;quot;, so that instances of objects
	will not pass along prototype defaults.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="instance">
        <description>Adds all properties and methods of props to obj and returns the
	(now modified) obj.</description>
        <example>make a shallow copy of an object
		var copy = dojo.mixin({}, source);</example>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>The object to mix properties into. Also the return value.</description>
          </parameter>
          <parameter name="props" type="Object" usage="one-or-more">
            <description>One or more objects whose values are successively copied into
	obj. If more than one of these objects contain the same value,
	the one specified last in the function call will &amp;quot;win&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getProp" scope="instance">
        <parameters>
          <parameter name="parts" type="Array" usage="required"/>
          <parameter name="create" type="Boolean" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="setObject" scope="instance">
        <description>Set a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;</description>
        <example>set the value of `foo.bar.baz`, regardless of whether
	intermediate objects already exist:
		dojo.setObject("foo.bar.baz", value);</example>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to a property, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="optional">
            <description>Optional. Object to use as root of path. Defaults to
	`dojo.global`.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getObject" scope="instance">
        <description>Get a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to an property, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="create" type="Boolean" usage="required">
            <description>Optional. Defaults to `false`. If `true`, Objects will be
	created at any point along the 'path' that is undefined.</description>
          </parameter>
          <parameter name="context" type="Object" usage="required">
            <description>Optional. Object to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="exists" scope="instance">
        <description>determine if an object supports a given method</description>
        <example>
		// define an object
		var foo = {
			bar: { }
		};
		// search the global scope
		dojo.exists("foo.bar"); // true
		dojo.exists("foo.bar.baz"); // false
		// search from a particular scope
		dojo.exists("bar", foo); // true
		dojo.exists("bar.baz", foo); // false</example>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to an object, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <description>to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="eval" scope="instance">
        <description>Perform an evaluation in the global scope. Use this rather than
	calling 'eval()' directly.</description>
        <parameters>
          <parameter name="scriptFragment" type="String" usage="required"/>
        </parameters>
        <return-description>The result of the evaluation. Often `undefined`</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="experimental" scope="instance">
        <description>Marks code as experimental.</description>
        <example>
		dojo.experimental("dojo.data.Result");</example>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>The name of a module, or the name of a module file or a specific
	function</description>
          </parameter>
          <parameter name="extra" type="String" usage="optional">
            <description>some additional message for the user</description>
          </parameter>
        </parameters>
      </method>
      <method name="_loadInit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fakeLoadInit" scope="instance"/>
      <method name="_xhrObj" scope="instance">
        <description>does the work of portably generating a new XMLHTTPRequest
	object.</description>
        <return-types>
          <return-type type="XMLHTTPRequest instance"/>
        </return-types>
      </method>
      <method name="_isDocumentOk" scope="instance">
        <parameters>
          <parameter name="http" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getText" scope="instance">
        <description>Read the contents of the specified uri and return those contents.</description>
        <parameters>
          <parameter name="uri" type="URI" usage="required">
            <description>A relative or absolute uri. If absolute, it still must be in
	the same &amp;quot;domain&amp;quot; as we are.</description>
          </parameter>
          <parameter name="fail_ok" type="Boolean" usage="required">
            <description>Default false. If fail_ok and loading fails, return null
	instead of throwing.</description>
          </parameter>
        </parameters>
        <return-description>The response text. null is returned when there is a
	failure and failure is okay (an exception otherwise)</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="windowUnloaded" scope="instance">
        <description>signal fired by impending window destruction. You may use
	dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
	page/application cleanup methods. See dojo.addOnWindowUnload for more info.</description>
      </method>
      <method name="addOnWindowUnload" scope="instance">
        <description>registers a function to be triggered when window.onunload fires.
	Be careful trying to modify the DOM or access JavaScript properties
	during this phase of page unloading: they may not always be available.
	Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
	JavaScript work.</description>
        <example>
		dojo.addOnWindowUnload(functionPointer)
		dojo.addOnWindowUnload(object, "functionName")
		dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <description>Returns DOM node with matching `id` attribute or `null`
	if not found, similar to &amp;quot;$&amp;quot; function in another library.
	If `id` is a DomNode, this function is a no-op.</description>
        <parameters>
          <parameter name="id" type="String|DOMNode" usage="required">
            <description>A string to match an HTML id attribute or a reference to a DOM Node</description>
          </parameter>
          <parameter name="doc" type="Document" usage="required">
            <description>Document to work in. Defaults to the current value of
	dojo.doc.  Can be used to retrieve
	node references from other documents.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="assume it's a node"/>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_loadUri" scope="instance">
        <description>Internal xd loader function. Overrides loadUri() from loader.js.
	xd loading requires slightly different behavior from loadPath().</description>
        <parameters>
          <parameter name="uri" type="String" usage="required">
            <description>a uri which points at the script to be loaded</description>
          </parameter>
          <parameter name="cb" type="Function" usage="required">
            <description>a callback function to process the result of evaluating the script
	as an expression, typically used by the resource bundle loader to
	load JSON-style resources</description>
          </parameter>
          <parameter name="currentIsXDomain" type="boolean" usage="required"/>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="exit" scope="instance">
        <parameters>
          <parameter name="exitcode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rhinoCurrentScriptViaJava" scope="instance">
        <parameters>
          <parameter name="depth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="body" scope="instance">
        <description>Return the body element of the document
	return the body object associated with dojo.doc</description>
        <example>
		dojo.body().appendChild(dojo.doc.createElement('div'));</example>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_spidermonkeyCurrentFile" scope="instance">
        <parameters>
          <parameter name="depth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadPath" scope="instance">
        <description>Internal xd loader function. Overrides loadPath() from loader.js.
	xd loading requires slightly different behavior from loadPath().</description>
        <parameters>
          <parameter name="relpath" type="String" usage="required">
            <description>A relative path to a script (no leading '/', and typically ending
	in '.js').</description>
          </parameter>
          <parameter name="module" type="String" usage="optional">
            <description>A module whose existance to check for after loading a path.  Can be
	used to determine success or failure of the load.</description>
          </parameter>
          <parameter name="cb" type="Function" usage="optional">
            <description>a callback function to pass the result of evaluating the script</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_loadUriAndCheck" scope="instance">
        <description>calls loadUri then findModule and returns true if both succeed</description>
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="cb" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loaded" scope="instance">
        <description>signal fired when initial environment and package loading is
	complete. You may use dojo.addOnLoad() or dojo.connect() to
	this method in order to handle initialization tasks that
	require the environment to be initialized. In a browser host,
	declarative widgets will be constructed when this function
	finishes runing.</description>
      </method>
      <method name="unloaded" scope="instance">
        <description>signal fired by impending environment destruction. You may use
	dojo.addOnUnload() or dojo.connect() to this method to perform
	page/application cleanup methods. See dojo.addOnUnload for more info.</description>
      </method>
      <method name="_onto" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addOnLoad" scope="instance">
        <description>Registers a function to be triggered after the DOM has finished
	loading and widgets declared in markup have been instantiated.
	Images and CSS files may or may not have finished downloading when
	the specified function is called.  (Note that widgets' CSS and HTML
	code is guaranteed to be downloaded before said widgets are
	instantiated.)</description>
        <example>
		dojo.addOnLoad(functionPointer);
		dojo.addOnLoad(object, "functionName");
		dojo.addOnLoad(object, function(){ /* ... */});</example>
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="addOnUnload" scope="instance">
        <description>registers a function to be triggered when the page unloads. In a browser
	enviroment, the functions will be triggered during the window.onbeforeunload
	event. Be careful doing work during window.onbeforeunload. onbeforeunload
	can be triggered if a link to download a file is clicked, or if the link is a
	javascript: link. In these cases, the onbeforeunload event fires, but the
	document is not actually destroyed. So be careful about doing destructive
	operations in a dojo.addOnUnload callback.</description>
        <example>
		dojo.addOnUnload(functionPointer)
		dojo.addOnUnload(object, "functionName")
		dojo.addOnUnload(object, function(){ /* ... */});</example>
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_modulesLoaded" scope="instance"/>
      <method name="_callLoaded" scope="instance"/>
      <method name="_getModuleSymbols" scope="instance">
        <description>Converts a module name in dotted JS notation to an array
	representing the path in the source tree</description>
        <parameters>
          <parameter name="modulename" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="loadInit" scope="instance">
        <description>Executes a function that needs to be executed for the loader's dojo.requireIf
	resolutions to work. This is needed mostly for the xdomain loader case where
	a function needs to be executed to set up the possible values for a dojo.requireIf
	call.</description>
        <parameters>
          <parameter name="init" type="Function" usage="required">
            <description>a function reference. Executed immediately.</description>
          </parameter>
        </parameters>
      </method>
      <method name="require" scope="instance">
        <description>loads a Javascript module from the appropriate URI</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>module name to load, using periods for separators,
	e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo's
	internal mapping of locations to names and are disambiguated by
	longest prefix. See `dojo.registerModulePath()` for details on
	registering new modules.</description>
          </parameter>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional">
            <description>if `true`, omitModuleCheck skips the step of ensuring that the
	loaded file actually defines the symbol it is referenced by.
	For example if it called as `dojo.require(&amp;quot;a.b.c&amp;quot;)` and the
	file located at `a/b/c.js` does not define an object `a.b.c`,
	and exception will be throws whereas no exception is raised
	when called as `dojo.require(&amp;quot;a.b.c&amp;quot;, true)`</description>
          </parameter>
        </parameters>
        <return-description>the required namespace object</return-description>
      </method>
      <method name="provide" scope="instance">
        <description>Each javascript source file must have at least one
	`dojo.provide()` call at the top of the file, corresponding to
	the file name.  For example, `js/dojo/foo.js` must have
	`dojo.provide(&amp;quot;dojo.foo&amp;quot;);` before any calls to
	`dojo.require()` are made.</description>
        <parameters>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="platformRequire" scope="instance">
        <description>require one or more modules based on which host environment
	Dojo is currently operating in</description>
        <example>
		dojo.platformRequire({
			browser: [
				"foo.sample", // simple module
				"foo.test",
				["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
			],
			default: [ "foo.sample._base" ],
			common: [ "important.module.common" ]
		});</example>
        <parameters>
          <parameter name="modMap" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requireIf" scope="instance">
        <description>If the condition is true then call dojo.require() for the specified
	resource</description>
        <parameters>
          <parameter name="condition" type="Boolean" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerModulePath" scope="instance">
        <description>maps a module name to a path</description>
        <example>If your dojo.js is located at this location in the web root:
		/myapp/js/dojo/dojo/dojo.js
	and your modules are located at:
		/myapp/js/foo/bar.js
		/myapp/js/foo/baz.js
		/myapp/js/foo/thud/xyzzy.js
	Your application can tell Dojo to locate the "foo" namespace by calling:
		dojo.registerModulePath("foo", "../../foo");
	At which point you can then use dojo.require() to load the
	modules (assuming they provide() the same things which are
	required). The full code might be:
		&lt;script type="text/javascript"
			src="/myapp/js/dojo/dojo/dojo.js"&gt;&lt;/script&gt;
		&lt;script type="text/javascript"&gt;
			dojo.registerModulePath("foo", "../../foo");
			dojo.require("foo.bar");
			dojo.require("foo.baz");
			dojo.require("foo.thud.xyzzy");
		&lt;/script&gt;</example>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="prefix" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="requireLocalization" scope="instance">
        <description>loads a bundle intelligently based on whether the module is
	local or xd. Overrides the local-case implementation.</description>
        <example>A particular widget may define one or more resource bundles,
	structured in a program as follows, where moduleName is
	mycode.mywidget and bundleNames available include bundleone and
	bundletwo:
			...
		mycode/
			mywidget/
				nls/
					bundleone.js (the fallback translation, English in this example)
					bundletwo.js (also a fallback translation)
					de/
						bundleone.js
						bundletwo.js
					de-at/
						bundleone.js
					en/
						(empty; use the fallback translation)
					en-us/
						bundleone.js
					en-gb/
						bundleone.js
					es/
						bundleone.js
						bundletwo.js
					  ...etc
					...</example>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>name of the package containing the &amp;quot;nls&amp;quot; directory in which the
	bundle is found</description>
          </parameter>
          <parameter name="bundleName" type="String" usage="required">
            <description>bundle name, i.e. the filename without the '.js' suffix</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>the locale to load (optional)  By default, the browser's user
	locale as defined by dojo.locale</description>
          </parameter>
          <parameter name="availableFlatLocales" type="String" usage="optional">
            <description>A comma-separated list of the available, flattened locales for this
	bundle. This argument should only be set by the build process.</description>
          </parameter>
        </parameters>
      </method>
      <method name="moduleUrl" scope="instance">
        <description>Returns a `dojo._Url` object relative to a module.</description>
        <example>
		var pngPath = dojo.moduleUrl("acme","images/small.png");
		console.dir(pngPath); // list the object properties
		// create an image and set it's source to pngPath's value:
		var img = document.createElement("img");
		// NOTE: we assign the string representation of the url object
		img.src = pngPath.toString();
		// add our image to the document
		dojo.body().appendChild(img);</example>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="url" type="dojo._Url||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_xdDebugFileLoaded" scope="instance">
        <parameters>
          <parameter name="resourceName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdReset" scope="instance">
        <description>Internal xd loader function. Resets the xd state.</description>
      </method>
      <method name="_xdCreateResource" scope="instance">
        <description>Internal xd loader function. Creates an xd module source given an
	non-xd module contents.</description>
        <parameters>
          <parameter name="contents" type="String" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
          <parameter name="resourcePath" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_xdExtractLoadInits" scope="instance">
        <parameters>
          <parameter name="fileContents" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdIsXDomainPath" scope="instance">
        <description>Figure out whether the path is local or x-domain
	If there is a colon before the first / then, we have a URL with a protocol.</description>
        <parameters>
          <parameter name="relpath" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_xdResourceLoaded" scope="instance">
        <description>Internal xd loader function. Called by an xd module resource when
	it has been loaded via a script tag.
	Evaluate the function with scopeArgs for multiversion support.</description>
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdLoadFlattenedBundle" scope="instance">
        <description>Internal xd loader function. Used when loading
	a flattened localized bundle via a script tag.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="bundleData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdInitExtraLocales" scope="instance"/>
      <method name="xdRequireLocalization" scope="instance">
        <description>Internal xd loader function. The xd version of dojo.requireLocalization.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdUnpackDependency" scope="instance">
        <description>Internal xd loader function. Determines what to do with a dependency
	that was listed in an xd version of a module contents.</description>
        <parameters>
          <parameter name="dep" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_xdWalkReqs" scope="instance">
        <description>Internal xd loader function.
	Walks the requires and evaluates module resource contents in
	the right order.</description>
      </method>
      <method name="_xdEvalReqs" scope="instance">
        <description>Internal xd loader function.
	Does a depth first, breadth second search and eval of required modules.</description>
        <parameters>
          <parameter name="reqChain" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_xdClearInterval" scope="instance">
        <description>Internal xd loader function.
	Clears the interval timer used to check on the
	status of in-flight xd module resource requests.</description>
      </method>
      <method name="_xdWatchInFlight" scope="instance">
        <description>Internal xd loader function.
	Monitors in-flight requests for xd module resources.</description>
      </method>
      <method name="_xdNotifyLoaded" scope="instance"/>
      <method name="indexOf" scope="instance">
        <description>locates the first index of the provided value in the
	passed array. If the value is not found, -1 is returned.</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
          <parameter name="findLast" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>locates the last index of the provided value in the passed
	array. If the value is not found, -1 is returned.</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <description>for every item in arr, callback is invoked. Return values are ignored.</description>
        <example>
		// log out all members of the array:
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item){
				console.debug(item);
			}
		);</example>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate over. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index, and array</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
      </method>
      <method name="_everyOrSome" scope="instance">
        <parameters>
          <parameter name="every" type="Boolean" usage="required"/>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <description>Determines whether or not every item in arr satisfies the
	condition implemented by callback.</description>
        <example>
		// returns false
		dojo.every([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <description>Determines whether or not any item in arr satisfies the
	condition implemented by callback.</description>
        <example>
		// is true
		dojo.some([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate over. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <description>applies callback to each element of arr and returns
	an Array with the results</description>
        <example>
		// returns [2, 3, 4, 5]
		dojo.map([1, 2, 3, 4], function(item){ return item+1 });</example>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on
	individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments, (item, index,
	array),  and returns a value</description>
          </parameter>
          <parameter name="thisObject" type="Function" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <description>Returns a new Array with those items from arr that match the
	condition implemented by callback.</description>
        <example>
		// returns [2, 3, 4]
		dojo.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        <parameters>
          <parameter name="arr" type="Array" usage="required">
            <description>the array to iterate over.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function that is invoked with three arguments (item,
	index, array). The return of this function is expected to
	be a boolean which determines whether the passed-in item
	will be included in the returned array.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Create a link that calls one function when another executes.</description>
        <example>When obj.onchange(), do ui.update():
		dojo.connect(obj, "onchange", ui, "update");
		dojo.connect(obj, "onchange", ui, ui.update); // same</example>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function.
	Defaults to dojo.global if null.
	If obj is a DOM node, the connection is delegated
	to the DOM event manager (unless dontFix is true).</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>name of the event function in obj.
	I.e. identifies a property obj[event].</description>
          </parameter>
          <parameter name="context" type="Object|null" usage="required">
            <description>The object that method will receive as &amp;quot;this&amp;quot;.
	If context is null and method is a function, then method
	inherits the context of event.
	If method is a string then context must be the source
	object object for method (context[method]). If context is null,
	dojo.global is used.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>A function reference, or name of a function in context.
	The function identified by method fires after event does.
	method receives the same arguments as the event.
	See context argument comments for information on method's scope.</description>
          </parameter>
          <parameter name="dontFix" type="Boolean" usage="required">
            <description>If obj is a DOM node, set dontFix to true to prevent delegation
	of this connection to the DOM event manager.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="_connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="dontFix" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Remove a link created by dojo.connect.</description>
        <parameters>
          <parameter name="handle" type="Handle" usage="required">
            <description>the return value of the dojo.connect call that created the connection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_disconnect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="handle" type="Object" usage="required"/>
          <parameter name="listener" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectPublisher" scope="instance">
        <description>Ensure that everytime obj.event() is called, a message is published
	on the topic. Returns a handle which can be passed to
	dojo.disconnect() to disable subsequent automatic publication on
	the topic.</description>
        <example>
		dojo.connectPublisher("/ajax/start", dojo, "xhrGet");</example>
        <parameters>
          <parameter name="topic" type="String" usage="required">
            <description>The name of the topic to publish.</description>
          </parameter>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function. Defaults to dojo.global
	if null.</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>The name of the event function in obj.
	I.e. identifies a property obj[event].</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="_ieDispatcher" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIeDispatcher" scope="instance">
        <return-types>
          <return-type type="function"/>
        </return-types>
      </method>
      <method name="fixEvent" scope="instance">
        <description>normalizes properties on the event object including event
	bubbling methods, keystroke normalization, and x/y positions</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>native event object</description>
          </parameter>
          <parameter name="sender" type="DOMNode" usage="required">
            <description>node to treat as &amp;quot;currentTarget&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="stopEvent" scope="instance">
        <description>prevents propagation and clobbers the default action of the
	passed event</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object. If omitted, window.event is used on IE.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fade" scope="instance">
        <description>Returns an animation that will fade the node defined by
	args.node from the start to end values passed (args.start
	args.end) (end is mandatory, start is optional)</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <description>Returns an animation that will fade node defined in 'args' from
	its current opacity to fully opaque.</description>
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <description>Returns an animation that will fade node defined in 'args'
	from its current opacity to fully transparent.</description>
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_defaultEasing" scope="instance">
        <description>The default easing function for dojo._Animation(s)</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="anim" scope="instance">
        <description>A simpler interface to `dojo.animateProperty()`, also returns
	an instance of `dojo._Animation` but begins the animation
	immediately, unlike nearly every other Dojo animation API.</description>
        <example>Fade out a node
		dojo.anim("id", { opacity: 0 });</example>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>a DOM node or the id of a node to animate CSS properties on</description>
          </parameter>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional">
            <description>The number of milliseconds over which the animation
	should run. Defaults to the global animation default duration
	(350ms).</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>An easing function over which to calculate acceleration
	and deceleration of the animation through its duration.
	A default easing algorithm is provided, but you may
	plug in any you wish. A large selection of easing algorithms
	are available in `dojo.fx.easing`.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation finishes
	running.</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>The number of milliseconds to delay beginning the
	animation by. The default is 0.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getComputedStyle" scope="instance">
        <description>Returns a &amp;quot;computed style&amp;quot; object.</description>
        <example>
		dojo.getComputedStyle(dojo.byId('foo')).borderWidth;</example>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="CSS2Properties"/>
        </return-types>
      </method>
      <method name="_getOpacity" scope="instance">
        <description>Returns the current opacity of the passed node as a
	floating-point value between 0 and 1.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>a reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</description>
          </parameter>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_setOpacity" scope="instance">
        <description>set the opacity of the passed node portably. Returns the
	new opacity of the node.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a reference to a DOM node. Does NOT support taking an
	ID string for performance reasons.</description>
          </parameter>
          <parameter name="opacity" type="Number" usage="required">
            <description>A Number between 0 and 1. 0 specifies transparent.</description>
          </parameter>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_destroyElement" scope="instance">
        <description>removes node from its parent, clobbers it and all of its
	children.</description>
        <parameters>
          <parameter name="node" type="String||DomNode" usage="required">
            <description>the element to be destroyed, either as an ID or a reference</description>
          </parameter>
        </parameters>
      </method>
      <method name="isDescendant" scope="instance">
        <description>Returns true if node is a descendant of ancestor</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or node reference to test</description>
          </parameter>
          <parameter name="ancestor" type="DomNode|String" usage="required">
            <description>id or node reference of potential parent to test against</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setSelectable" scope="instance">
        <description>enable or disable selection on a node</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to node</description>
          </parameter>
          <parameter name="selectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <description>Attempt to insert node into the DOM, choosing from various positioning options.
	Returns true if successful, false otherwise.</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>id or node reference to place relative to refNode</description>
          </parameter>
          <parameter name="refNode" type="String|DomNode" usage="required">
            <description>id or node reference to use as basis for placement</description>
          </parameter>
          <parameter name="position" type="String?|Number" usage="optional">
            <description>string noting the position of node relative to refNode or a
	number indicating the location in the childNodes collection of refNode.
	Accepted string values are:
	* before
	* after
	* first
	* last
	&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode.  position defaults
	to &amp;quot;last&amp;quot; if not specified</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_toPixelValue" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="avalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="style" scope="instance">
        <description>Accesses styles on a node. If 2 arguments are
	passed, acts as a getter. If 3 arguments are passed, acts
	as a setter.</description>
        <example>Passing only an ID or node returns the computed style object of
	the node:
		dojo.style("thinger");</example>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to node to get/set style for</description>
          </parameter>
          <parameter name="style" type="String?|Object" usage="optional">
            <description>the style property to set in DOM-accessor format
	(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
	pairs suitable for setting each property.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>If passed, sets value on the node for style, handling
	cross-browser concerns.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="CSS2Properties"/>
          <return-type type="Object"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getPadExtents" scope="instance">
        <description>Returns object with special values specifically useful for node
	fitting.
	* l/t = left/top padding (respectively)
	* w = the total of the left and right padding
	* h = the total of the top and bottom padding
	If 'node' has position, l/t forms the origin for child nodes.
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderExtents" scope="instance">
        <description>returns an object with properties useful for noting the border
	dimensions.
	* l/t = the sum of left/top border (respectively)
	* w = the sum of the left and right border
	* h = the sum of the top and bottom border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorderExtents" scope="instance">
        <description>returns object with properties useful for box fitting with
	regards to padding.
	* l/t = the sum of left/top padding and left/top border (respectively)
	* w = the sum of the left and right padding and border
	* h = the sum of the top and bottom padding and border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginExtents" scope="instance">
        <description>returns object with properties useful for box fitting with
	regards to box margins (i.e., the outer-box).
	* l/t = marginLeft, marginTop, respectively
	* w = total width, margin inclusive
	* h = total height, margin inclusive
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginBox" scope="instance">
        <description>returns an object that encodes the width, height, left and top
	positions of the node's margin box.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContentBox" scope="instance">
        <description>Returns an object that encodes the width, height, left and top
	positions of the node's content box, irrespective of the
	current box model.</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBox" scope="instance">
        <description>sets width/height/left/top in the current (native) box-model
	dimentions. Uses the unit passed in u.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>DOM Node reference. Id string not supported for performance reasons.</description>
          </parameter>
          <parameter name="l" type="Number" usage="optional">
            <description>optional. left offset from parent.</description>
          </parameter>
          <parameter name="t" type="Number" usage="optional">
            <description>optional. top offset from parent.</description>
          </parameter>
          <parameter name="w" type="Number" usage="optional">
            <description>optional. width in current box model.</description>
          </parameter>
          <parameter name="h" type="Number" usage="optional">
            <description>optional. width in current box model.</description>
          </parameter>
          <parameter name="u" type="String" usage="optional">
            <description>optional. unit measure to use for other measures. Defaults to &amp;quot;px&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isButtonTag" scope="instance">
        <description>True if the node is BUTTON or INPUT.type=&amp;quot;button&amp;quot;.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_usesBorderBox" scope="instance">
        <description>True if the node uses border-box layout.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_setContentSize" scope="instance">
        <description>Sets the size of the node's contents, irrespective of margins,
	padding, or borders.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="widthPx" type="Number" usage="required"/>
          <parameter name="heightPx" type="Number" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMarginBox" scope="instance">
        <description>sets the size of the node's margin box and placement
	(left/top), irrespective of box model. Think of it as a
	passthrough to dojo._setBox that handles box-model vagaries for
	you.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="leftPx" type="Number" usage="optional"/>
          <parameter name="topPx" type="Number" usage="optional"/>
          <parameter name="widthPx" type="Number" usage="optional"/>
          <parameter name="heightPx" type="Number" usage="optional"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="marginBox" scope="instance">
        <description>Getter/setter for the margin-box of node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.marginBox() should
	update/set the margin box for node. Box is an object in the
	above format. All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="contentBox" scope="instance">
        <description>Getter/setter for the content-box of node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.contentBox() should
	update/set the content box for node. Box is an object in the
	above format. All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_docScroll" scope="instance"/>
      <method name="_isBodyLtr" scope="instance"/>
      <method name="_getIeDocumentElementOffset" scope="instance"/>
      <method name="_fixIeBiDiScrollLeft" scope="instance">
        <parameters>
          <parameter name="scrollLeft" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_abs" scope="instance">
        <description>Gets the position of the passed element relative to
	the viewport (if includeScroll==false), or relative to the
	document root (if includeScroll==true).
	Returns an object of the form:
	{ x: 100, y: 300 }
	if includeScroll is passed, the x and y values will include any
	document offsets that may affect the position relative to the
	viewport.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="coords" scope="instance">
        <description>Returns an object that measures margin box width/height and
	absolute positioning data from dojo._abs().</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="hasAttr" scope="instance">
        <description>Returns true if the requested attribute is specified on the
	given element, and false otherwise.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to check</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute</description>
          </parameter>
        </parameters>
        <return-description>true if the requested attribute is specified on the
	given element, and false otherwise</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="attr" scope="instance">
        <description>Gets or sets an attribute on an HTML element.</description>
        <example>
		// get the current value of the "foo" attribute on a node
		dojo.attr(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.attr("nodeId", "foo");</example>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to get or set the attribute on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the attribute to get or set.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>The value to set for the attribute</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, the value of the requested attribute
	or null if that attribute does not have a specified or
	default value;
	when user as a setter, undefined</return-description>
      </method>
      <method name="removeAttr" scope="instance">
        <description>Removes an attribute from an HTML element.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to remove the attribute from</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasClass" scope="instance">
        <description>Returns whether or not the specified classes are a portion of the
	class list currently applied to the node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <description>Adds the specified classes to the end of the class list on the
	passed node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeClass" scope="instance">
        <description>Removes the specified classes from node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="toggleClass" scope="instance">
        <description>Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fromJson" scope="instance">
        <description>Parses a [JSON](http://json.org) string to return a JavaScript object.  Throws for invalid JSON strings.</description>
        <parameters>
          <parameter name="json" type="String" usage="required">
            <description>a string literal of a JSON item, for instance:
	`'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'`</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_escapeString" scope="instance">
        <description>Adds escape sequences for non-visual characters, double quote and
	backslash and surrounds with double quotes to form a valid string
	literal.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="toJson" scope="instance">
        <description>Returns a [JSON](http://json.org) serialization of an object.</description>
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <description>an object to be serialized. Objects may define their own
	serialization via a special &amp;quot;__json__&amp;quot; or &amp;quot;json&amp;quot; function
	property. If a specialized serializer has been defined, it will
	be used as a fallback.</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <description>if true, we indent objects and arrays to make the output prettier.
	The variable dojo.toJsonIndentStr is used as the indent string
	-- to use something other than the default (tab),
	change that variable before calling dojo.toJson().</description>
          </parameter>
          <parameter name="_indentStr" type="String" usage="optional">
            <description>private variable for recursive calls when pretty printing, do not use.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isString" scope="instance">
        <description>Return true if it is a String</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isArray" scope="instance">
        <description>Return true if it is an Array</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFunction" scope="instance">
        <description>Return true if it is a Function</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isObject" scope="instance">
        <description>Returns true if it is a JavaScript object (or an Array, a Function
	or null)</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isArrayLike" scope="instance">
        <description>similar to dojo.isArray() but more permissive</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-description>If it walks like a duck and quicks like a duck, return `true`</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isAlien" scope="instance">
        <description>Returns true if it is a built-in function or some other kind of
	oddball that *should* report as a function but doesn't</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <description>Adds all properties and methods of props to constructor's
	prototype, making them available to all instances created with
	constructor.</description>
        <parameters>
          <parameter name="constructor" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hitchArgs" scope="instance">
        <parameters>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="method" type="," usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="hitch" scope="instance">
        <description>Returns a function that will only ever execute in the a given scope.
	This allows for easy use of object member functions
	in callbacks and other places in which the &amp;quot;this&amp;quot; keyword may
	otherwise not reference the expected scope.
	Any number of default positional arguments may be passed as parameters
	beyond &amp;quot;method&amp;quot;.
	Each of these values will be used to &amp;quot;placehold&amp;quot; (similar to curry)
	for the hitched function.</description>
        <example>
		dojo.hitch(foo, "bar")();
	runs foo.bar() in the scope of foo</example>
        <parameters>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use when method executes. If method is a string,
	scope is also the object containing method.</description>
          </parameter>
          <parameter name="method" type="Function|String ," usage="one-or-more">
            <description>A function to be hitched to scope, or the name of the method in
	scope to be hitched.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="delegate" scope="instance">
        <description>returns a new object which &amp;quot;looks&amp;quot; to obj for properties which it
	does not have a value for. Optionally takes a bag of properties to
	seed the returned object with initially.</description>
        <example>
		var foo = { bar: "baz" };
		var thinger = dojo.delegate(foo, { thud: "xyzzy"});
		thinger.bar == "baz"; // delegated to foo
		foo.thud == undefined; // by definition
		thinger.thud == "xyzzy"; // mixed in from props
		foo.bar = "thonk";
		thinger.bar == "thonk"; // still delegated to foo's bar</example>
        <parameters>
          <parameter name="obj" type="The" usage="required">
            <description>object to delegate to for properties not found directly on the
	return object or in props.</description>
          </parameter>
          <parameter name="props" type="an" usage="required">
            <description>object containing properties to assign to the returned object</description>
          </parameter>
        </parameters>
        <return-description>an Object of anonymous type</return-description>
      </method>
      <method name="_toArray" scope="instance">
        <description>Converts an array-like object (i.e. arguments, DOMCollection) to an
	array. Returns a new Array with the elements of obj.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>the object to &amp;quot;arrayify&amp;quot;. We expect the object to have, at a
	minimum, a length property which corresponds to integer-indexed
	properties.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="optional">
            <description>the location in obj to start iterating from. Defaults to 0.
	Optional.</description>
          </parameter>
          <parameter name="startWith" type="Array" usage="optional">
            <description>An array to pack with the properties of obj. If provided,
	properties in obj are appended at the end of startWith and
	startWith is the returned array.</description>
          </parameter>
        </parameters>
      </method>
      <method name="partial" scope="instance">
        <description>similar to hitch() except that the scope object is left to be
	whatever the execution context eventually becomes.</description>
        <parameters>
          <parameter name="method" type="Function|String , " usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <description>Clones objects (including DOM nodes) and all children.
	Warning: do not clone cyclic structures.</description>
        <parameters>
          <parameter name="o" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="anything"/>
          <return-type type="Node"/>
          <return-type type="Date"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="trim" scope="instance">
        <description>trims whitespaces from both sides of the string</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_delegate" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="query" scope="instance">
        <description>Returns nodes which match the given CSS3 selector, searching the
	entire document by default but optionally taking a node to scope
	the search by. Returns an instance of dojo.NodeList.</description>
        <example>search the entire document for elements with the class "foo":
		dojo.query(".foo");
	these elements will match:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;span class="foo bar"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>The CSS3 expression to match against. For details on the syntax of
	CSS3 selectors, see &amp;lt;http://www.w3.org/TR/css3-selectors/#selectors&amp;gt;</description>
          </parameter>
          <parameter name="root" type="String|DOMNode" usage="optional">
            <description>A DOMNode (or node id) to scope the search from. Optional.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList
	An instance of `dojo.NodeList`. Many methods are available on
	NodeLists for searching, iterating, manipulating, and handling
	events on the matched nodes in the returned list.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_filterQueryResult" scope="instance">
        <parameters>
          <parameter name="nodeList" type="Object" usage="required"/>
          <parameter name="simpleFilter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContext" scope="instance">
        <description>changes the behavior of many core Dojo functions that deal with
	namespace and DOM lookup, changing them to work in a new global
	context (e.g., an iframe). The varibles dojo.global and dojo.doc
	are modified as a result of calling this function and the result of
	`dojo.body()` likewise differs.</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="globalDocument" type="DocumentElement" usage="required"/>
        </parameters>
      </method>
      <method name="_fireCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="cbArguments" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="withGlobal" scope="instance">
        <description>Call callback with globalObject as dojo.global and
	globalObject.document as dojo.doc. If provided, globalObject
	will be executed in the context of object thisObject</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="withDoc" scope="instance">
        <description>Call callback with documentObject as dojo.doc. If provided,
	callback will be executed in the context of object thisObject</description>
        <parameters>
          <parameter name="documentObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="formToObject" scope="instance">
        <description>dojo.formToObject returns the values encoded in an HTML form as
	string properties in an object which it then returns. Disabled form
	elements, buttons, and other non-value form elements are skipped.
	Multi-select elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="objectToQuery" scope="instance">
        <description>takes a name/value mapping object and returns a string representing
	a URL-encoded version of that object.</description>
        <example>this object:
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};
	yields the following query string:
		"blah=blah&amp;multi=thud&amp;multi=thonk"</example>
        <parameters>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToQuery" scope="instance">
        <description>Returns a URL-encoded string representing the form passed as either a
	node or string ID identifying the form to serialize</description>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToJson" scope="instance">
        <description>return a serialized JSON string from a form node or string
	ID identifying the form to serialize</description>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="queryToObject" scope="instance">
        <description>returns an object representing a de-serialized query section of a
	URL. Query keys with multiple values are returned in an array.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_ioSetArgs" scope="instance">
        <description>sets up the Deferred and ioArgs property on the Deferred so it
	can be used in an io call.</description>
        <parameters>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>The args object passed into the public io call. Recognized properties on
	the args object are:</description>
          </parameter>
          <parameter name="canceller" type="Function" usage="required">
            <description>The canceller function used for the Deferred object. The function
	will receive one argument, the Deferred object that is related to the
	canceller.</description>
          </parameter>
          <parameter name="okHandler" type="Function" usage="required">
            <description>The first OK callback to be registered with Deferred. It has the opportunity
	to transform the OK response. It will receive one argument -- the Deferred
	object returned from this function.</description>
          </parameter>
          <parameter name="errHandler" type="Function" usage="required">
            <description>The first error callback to be registered with Deferred. It has the opportunity
	to do cleanup on an error. It will receive two arguments: error (the
	Error object) and dfd, the Deferred object returned from this function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioCancelAll" scope="instance">
        <description>Cancels all pending IO requests, regardless of IO type
	(xhr, script, iframe).</description>
      </method>
      <method name="_ioWatch" scope="instance">
        <description>watches the io request represented by dfd to see if it completes.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required">
            <description>The Deferred object to watch.</description>
          </parameter>
          <parameter name="validCheck" type="Function" usage="required">
            <description>used to check if the IO request is still valid. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="ioCheck" type="Function" usage="required">
            <description>used to check if basic IO call worked. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="resHandle" type="Function" usage="required">
            <description>used to process response. Gets the dfd
	object as its only argument.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioAddQueryToUrl" scope="instance">
        <description>Adds query params discovered by the io deferred construction to the URL.
	Only use this for operations which are fundamentally GET-type operations.</description>
        <parameters>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhr" scope="instance">
        <description>Sends an HTTP request with the given method.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>HTTP method to be used, such as GET, POST, PUT, DELETE.  Should be uppercase.</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
          <parameter name="hasBody" type="Boolean" usage="optional">
            <description>If the request has an HTTP body, then pass true for hasBody.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrGet" scope="instance">
        <description>Sends an HTTP GET request to the server.</description>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrPost" scope="instance">
        <description>Sends an HTTP POST request to the server. In addtion to the properties
	listed for the dojo.__XhrArgs type, the following property is allowed:
	postData:
	String. Send raw data in the body of the POST request.</description>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrPut" scope="instance">
        <description>Sends an HTTP PUT request to the server. In addtion to the properties
	listed for the dojo.__XhrArgs type, the following property is allowed:
	putData:
	String. Send raw data in the body of the PUT request.</description>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrDelete" scope="instance">
        <description>Sends an HTTP DELETE request to the server.</description>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="__backArgs" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__cookieProps" scope="instance"/>
    </methods>
    <properties>
      <property name="NodeList-fx" scope="instance" type="Object"/>
      <property name="NodeList-html" scope="instance" type="Object"/>
      <property name="OpenAjax" scope="instance" type="Object"/>
      <property name="_scopeArgs" scope="instance" type="Object"/>
      <property name="global" scope="instance" type="Object">
        <description>Alias for the global scope
	(e.g. the window object in a browser).</description>
      </property>
      <property name="locale" scope="instance" type="Object">
        <description>the locale as defined by Dojo (read-only)</description>
      </property>
      <property name="isBrowser" scope="instance" type="Boolean">
        <description>True if the client is a web-browser</description>
      </property>
      <property name="isFF" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is FireFox. undefined otherwise. Corresponds to
	major detected FireFox version (1.5, 2, 3, etc.)</description>
      </property>
      <property name="isIE" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
	major detected IE version (6, 7, 8, etc.)</description>
      </property>
      <property name="isSafari" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is Safari or iPhone. undefined otherwise.</description>
      </property>
      <property name="isKhtml" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is a KTHML-derived browser (Konqueror,
	Safari, etc.). undefined otherwise. Corresponds to major detected version.</description>
      </property>
      <property name="isMozilla" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is a Mozilla-based browser (Firefox,
	SeaMonkey). undefined otherwise. Corresponds to major detected version.</description>
      </property>
      <property name="isOpera" scope="instance" type="Number">
        <description>| undefined
	Version as a Number if client is Opera. undefined otherwise. Corresponds to
	major detected version.</description>
      </property>
      <property name="baseUrl" scope="instance" type="Object">
        <description>The root relative path to dojo.js (as a string)</description>
      </property>
      <property name="isAIR" scope="instance" type="Object"/>
      <property name="isQuirks" scope="instance" type="Object"/>
      <property name="_XMLHTTP_PROGIDS" scope="instance" type="Object"/>
      <property name="_windowUnloaders" scope="instance" type="Object"/>
      <property name="_name" scope="instance" type="Object"/>
      <property name="_initFired" scope="instance" type="Object"/>
      <property name="_khtmlTimer" scope="instance" type="Object"/>
      <property name="isRhino" scope="instance" type="Object"/>
      <property name="doc" scope="instance" type="Object">
        <description>Alias for the current document. 'dojo.doc' can be modified
	for temporary context shifting. Also see dojo.withDoc().</description>
      </property>
      <property name="_timeouts" scope="instance" type="Object"/>
      <property name="isSpidermonkey" scope="instance" type="Object">
        <description>Detect spidermonkey</description>
      </property>
      <property name="_global_omit_module_check" scope="instance" type="Object"/>
      <property name="_loadModule" scope="instance" type="Object"/>
      <property name="requireAfterIf" scope="instance" type="Object"/>
      <property name="nonDebugProvide" scope="instance" type="Object"/>
      <property name="_xdBundleMap" scope="instance" type="Object"/>
      <property name="_xdRealRequireLocalization" scope="instance" type="Object"/>
      <property name="_topics" scope="instance" type="Object"/>
      <property name="subscribe" scope="instance" type="Object"/>
      <property name="unsubscribe" scope="instance" type="Object"/>
      <property name="publish" scope="instance" type="Object"/>
      <property name="boxModel" scope="instance" type="Object"/>
      <property name="toJsonIndentStr" scope="instance" type="Object"/>
      <property name="_blockAsync" scope="instance" type="Object"/>
      <property name="rawXhrPost" scope="instance" type="Object"/>
      <property name="rawXhrPut" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="_defaultXhr" scope="instance" type="Object"/>
      <property name="dojo" scope="instance" type="Object"/>
      <property name="jaxer" scope="instance" type="Object"/>
      <property name="robot" scope="instance" type="Object"/>
      <property name="robotx" scope="instance" type="Object"/>
      <property name="tests" scope="instance" type="Object">
        <description>D.O.H. Test files for Dojo unit testing.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.AdapterRegistry">
    <description>A registry to make contextual calling/searching easier.</description>
    <example>
		// create a new registry
		var reg = new dojo.AdapterRegistry();
		reg.register("handleString",
			dojo.isString,
			function(str){
				// do something with the string here
			}
		);
		reg.register("handleArr",
			dojo.isArray,
			function(arr){
				// do something with the array here
			}
		);
		// now we can pass reg.match() *either* an array or a string and
		// the value we pass will get handled by the right function
		reg.match("someValue"); // will call the first function
		reg.match(["someValue"]); // will call the second</example>
    <methods>
      <method name="register" scope="prototype">
        <description>register a check function to determine if the wrap function or
	object gets selected</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>a way to identify this matcher.</description>
          </parameter>
          <parameter name="check" type="Function" usage="required">
            <description>a function that arguments are passed to from the adapter's
	match() function.  The check function should return true if the
	given arguments are appropriate for the wrap function.</description>
          </parameter>
          <parameter name="wrap" type="Function" usage="required"/>
          <parameter name="directReturn" type="Boolean" usage="optional">
            <description>If directReturn is true, the value passed in for wrap will be
	returned instead of being called. Alternately, the
	AdapterRegistry can be set globally to &amp;quot;return not call&amp;quot; using
	the returnWrappers property. Either way, this behavior allows
	the registry to act as a &amp;quot;search&amp;quot; function instead of a
	function interception library.</description>
          </parameter>
          <parameter name="override" type="Boolean" usage="optional">
            <description>If override is given and true, the check function will be given
	highest priority. Otherwise, it will be the lowest priority
	adapter.</description>
          </parameter>
        </parameters>
      </method>
      <method name="match" scope="prototype">
        <description>Find an adapter for the given arguments. If no suitable adapter
	is found, throws an exception. match() accepts any number of
	arguments, all of which are passed to all matching functions
	from the registered pairs.</description>
      </method>
      <method name="unregister" scope="prototype">
        <description>Remove a named adapter from the registry</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="pairs" scope="instance" type="Object"/>
      <property name="returnWrappers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.DeferredList" superclass="dojo.Deferred">
    <description>Provides event handling for a group of Deferred objects.</description>
    <methods>
      <method name="_cbDeferred" scope="prototype">
        <description>The DeferredLists' callback handler</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="succeeded" type="Object" usage="required"/>
          <parameter name="result" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="gatherResults" scope="prototype">
        <description>Gathers the results of the deferreds for packaging
	as the parameters to the Deferred Lists' callback</description>
        <parameters>
          <parameter name="deferredList" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="finishedCount" scope="instance" type="Object"/>
      <property name="resultList" scope="instance" type="Object"/>
      <property name="chain" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="fired" scope="instance" type="Object"/>
      <property name="paused" scope="instance" type="Object"/>
      <property name="results" scope="instance" type="Object"/>
      <property name="canceller" scope="instance" type="A">
        <description>deferred canceller function, see dojo.Deferred</description>
      </property>
      <property name="silentlyCancelled" scope="instance" type="Object"/>
      <property name="fireOnOneCallback" scope="instance" type="Will">
        <description>cause the DeferredLists callback to be fired as soon as any
	of the deferreds in its list have been fired instead of waiting until
	the entire list has finished
	fireonOneErrback:
	Will cause the errback to fire upon any of the deferreds errback</description>
      </property>
      <property name="fireOnOneErrback" scope="instance" type="Object"/>
      <property name="consumeErrors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.DeferredList.list">
    <description>list of deferreds to be synchronizied with this DeferredList</description>
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList">
    <description>dojo.NodeList is as subclass of Array which adds syntactic
	sugar for chaining, common iteration operations, animation,
	and node manipulation. NodeLists are most often returned as
	the result of dojo.query() calls.</description>
    <example>create a node list from a node
		new dojo.NodeList(dojo.byId("foo"));</example>
    <methods>
      <method name="_anim" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeIn" scope="prototype">
        <description>wipe in all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>Fade in all tables with class "blah":
		dojo.query("table.blah").wipeIn().play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="prototype">
        <description>wipe out all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>Wipe out all tables with class "blah":
		dojo.query("table.blah").wipeOut().play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="prototype">
        <description>slide all elements of the node list to the specified place.
	Returns an instance of dojo._Animation</description>
        <example>
		Move all tables with class "blah" to 300/300:
		dojo.query("table.blah").slideTo({
			left: 40,
			top: 50
		}).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="prototype">
        <description>fade in all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>Fade in all tables with class "blah":
		dojo.query("table.blah").fadeIn().play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="prototype">
        <description>fade out all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>Fade out all elements with class "zork":
		dojo.query(".zork").fadeOut().play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="animateProperty" scope="prototype">
        <description>see dojo.animateProperty(). Animate all elements of this
	NodeList across the properties specified.</description>
        <example>
		dojo.query(".zork").animateProperty({
			duration: 500,
			properties: {
				color:		{ start: "black", end: "white" },
				left:		{ end: 300 }
			}
		}).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="prototype">
        <description>Animate one or more CSS properties for all nodes in this list.
	The returned animation object will already be playing when it
	is returned. See the docs for `dojo.anim` for full details.</description>
        <example>Another way to fade out:
		dojo.query(".thinger").anim({ opacity: 0 });</example>
        <parameters>
          <parameter name="properties" type="Object" usage="required">
            <description>the properties to animate</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <description>Optional. The time to run the animations for</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>Optional. The easing function to use.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation ends</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>how long to delay playing the returned animation</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="html" scope="prototype">
        <description>see `dojo.html.set()`. Set the content of all elements of this NodeList</description>
        <example>
	 dojo.query(".thingList").html("&lt;li dojoType='dojo.dnd.Moveable'&gt;1&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;2&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;3&lt;/li&gt;",
	 {
	 	parseContent: true,
	 	onBegin: function(){
	 		this.content = this.content.replace(/([0-9])/g, this.id + ": $1");
	 		this.inherited("onBegin", arguments);
	 	}
	 }).removeClass("notdone").addClass("done");</example>
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="slice" scope="prototype">
        <description>Returns a new NodeList, maintaining this one in place</description>
        <parameters>
          <parameter name="begin" type="Integer" usage="required">
            <description>Can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="end" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
        </parameters>
      </method>
      <method name="splice" scope="prototype">
        <description>Returns a new NodeList, manipulating this NodeList based on
	the arguments passed, potentially splicing in new elements
	at an offset, optionally deleting elements</description>
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>begin can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="howmany" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="concat" scope="prototype">
        <description>Returns a new NodeList comprised of items in this NodeList
	as well as items passed in as parameters</description>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="indexOf" scope="prototype">
        <description>see dojo.indexOf(). The primary difference is that the acted-on
	array is implicitly this NodeList</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The loction to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="prototype">
        <description>see dojo.lastIndexOf(). The primary difference is that the
	acted-on array is implicitly this NodeList</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The loction to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="every" scope="prototype">
        <description>see `dojo.every()` and:
	&amp;lt;http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every&amp;gt;
	Takes the same structure of arguments and returns as
	dojo.every() with the caveat that the passed array is
	implicitly this NodeList</description>
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="prototype">
        <description>see dojo.some() and:
	http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some
	Takes the same structure of arguments and returns as
	dojo.some() with the caveat that the passed array is
	implicitly this NodeList</description>
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="map" scope="prototype">
        <description>see dojo.map(). The primary difference is that the acted-on
	array is implicitly this NodeList and the return is a
	dojo.NodeList (a subclass of Array)</description>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="obj" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="forEach" scope="prototype">
        <description>see dojo.forEach(). The primary difference is that the acted-on
	array is implicitly this NodeList</description>
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="thisObj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="coords" scope="prototype">
        <description>Returns the box objects all elements in a node list as
	an Array (*not* a NodeList)</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="attr" scope="prototype">
        <description>gets or sets the DOM attribute for every element in the
	NodeList</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>the attribute to get/set</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>optional. The value to set the property to</description>
          </parameter>
        </parameters>
        <return-description>if no value is passed, the result is an array of attribute values
	If a value is passed, the return is this NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="style" scope="prototype">
        <description>gets or sets the CSS property for every element in the NodeList</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>the CSS property to get/set, in JavaScript notation
	(&amp;quot;lineHieght&amp;quot; instead of &amp;quot;line-height&amp;quot;)</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>optional. The value to set the property to</description>
          </parameter>
        </parameters>
        <return-description>if no value is passed, the result is an array of strings.
	If a value is passed, the return is this NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="addClass" scope="prototype">
        <description>adds the specified class to every node in the list</description>
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>the CSS class to add</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="removeClass" scope="prototype">
        <description>removes the specified class from every node in the list</description>
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>the CSS class to add</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, this list</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="prototype">
        <description>Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</description>
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>the CSS class to add</description>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="connect" scope="prototype">
        <description>attach event handlers to every item of the NodeList. Uses dojo.connect()
	so event properties are normalized</description>
        <example>add an onclick handler to every button on the page
		dojo.query("div:nth-child(odd)").connect("onclick", function(e){
			console.debug("clicked!");
		});</example>
        <parameters>
          <parameter name="methodName" type="String" usage="required">
            <description>the name of the method to attach to. For DOM events, this should be
	the lower-case name of the event</description>
          </parameter>
          <parameter name="objOrFunc" type="Object|Function|String" usage="required">
            <description>if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
	reference a function or be the name of the function in the global
	namespace to attach. If 3 arguments are provided
	(methodName, objOrFunc, funcName), objOrFunc must be the scope to
	locate the bound function in</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>optional. A string naming the function in objOrFunc to bind to the
	event. May also be a function reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="place" scope="prototype">
        <description>places elements of this node list relative to the first element matched
	by queryOrNode. Returns the original NodeList.</description>
        <parameters>
          <parameter name="queryOrNode" type="String||Node" usage="required">
            <description>may be a string representing any valid CSS3 selector or a DOM node.
	In the selector case, only the first matching element will be used
	for relative positioning.</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>can be one of:
	* &amp;quot;last&amp;quot;||&amp;quot;end&amp;quot; (default)
	* &amp;quot;first||&amp;quot;start&amp;quot;
	* &amp;quot;before&amp;quot;
	* &amp;quot;after&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="orphan" scope="prototype">
        <description>removes elements in this list that match the simple
	filter from their parents and returns them as a new
	NodeList.</description>
        <parameters>
          <parameter name="simpleFilter" type="String" usage="optional">
            <description>single-expression CSS filter</description>
          </parameter>
        </parameters>
        <return-description>`dojo.NodeList` containing the orpahned elements</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="adopt" scope="prototype">
        <description>places any/all elements in queryOrListOrNode at a
	position relative to the first element in this list.
	Returns a dojo.NodeList of the adopted elements.</description>
        <parameters>
          <parameter name="queryOrListOrNode" type="String||Array||DomNode" usage="required">
            <description>a DOM node or a query string or a query result.
	Represents the nodes to be adopted relative to the
	first element of this NodeList.</description>
          </parameter>
          <parameter name="position" type="String" usage="optional">
            <description>can be one of:
	* &amp;quot;last&amp;quot;||&amp;quot;end&amp;quot; (default)
	* &amp;quot;first||&amp;quot;start&amp;quot;
	* &amp;quot;before&amp;quot;
	* &amp;quot;after&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="query" scope="prototype">
        <description>Returns a new, flattened NodeList. Elements of the new list
	satisfy the passed query but use elements of the
	current NodeList as query roots.</description>
        <parameters>
          <parameter name="queryStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="prototype">
        <description>&amp;quot;masks&amp;quot; the built-in javascript filter() method to support
	passing a simple string filter in addition to supporting
	filtering function objects.</description>
        <example>"regular" JS filter syntax as exposed in dojo.filter:
		dojo.query("*").filter(function(item){
			// highlight every paragraph
			return (item.nodeName == "p");
		}).styles("backgroundColor", "yellow");</example>
        <parameters>
          <parameter name="simpleQuery" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="addContent" scope="prototype">
        <description>add a node or some HTML as a string to every item in the list.
	Returns the original list.</description>
        <example>appends content to the end if the position is ommitted
		dojo.query("h3 &gt; p").addContent("hey there!");</example>
        <parameters>
          <parameter name="content" type="String" usage="required">
            <description>the HTML in string format to add at position to every item</description>
          </parameter>
          <parameter name="position" type="String||Integer" usage="optional">
            <description>can be one of:
	* &amp;quot;last&amp;quot;||&amp;quot;end&amp;quot; (default)
	* &amp;quot;first||&amp;quot;start&amp;quot;
	* &amp;quot;before&amp;quot;
	* &amp;quot;after&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="empty" scope="prototype">
        <description>clears all content from each node in the list</description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="instantiate" scope="prototype">
        <description>Create a new instance of a specified class, using the
	specified properties and each node in the nodeList as a
	srcNodeRef</description>
        <parameters>
          <parameter name="declaredClass" type="String|Object" usage="required"/>
          <parameter name="properties" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="at" scope="prototype">
        <description>Returns a new NodeList comprised of items in this NodeList
	at the given index or indices.</description>
        <parameters>
          <parameter name="index" type="Integer" usage="one-or-more">
            <description>One or more 0-based indices of items in the current NodeList.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="dtl" scope="prototype">
        <parameters>
          <parameter name="template" type="dojox.dtl.__StringArgs|String" usage="required">
            <description>The template string or location</description>
          </parameter>
          <parameter name="context" type="dojox.dtl.__ObjectArgs|Object" usage="required">
            <description>The context object or location</description>
          </parameter>
        </parameters>
      </method>
      <method name="sizeTo" scope="prototype">
        <description>size all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>
		// size all divs with class "blah"
		dojo.query("div.blah").sizeTo({
			width:50,
			height:50
		}).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="prototype">
        <description>slide all elements of this NodeList. Returns an instance of dojo._Animation</description>
        <example>
		// slide all tables with class "blah" 10 px
		dojo.query("table.blah").slideBy({ top:10, left:10 }).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="prototype">
        <description>highlight all elements of the node list.
	Returns an instance of dojo._Animation</description>
        <example>
		// highlight all links with class "foo"
		dojo.query("a.foo").hightlight().play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="fadeTo" scope="prototype">
        <description>fade all elements of the node list to a specified opacity</description>
        <example>
		// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").fadeTo({ end: 0.5 }).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeTo" scope="prototype">
        <description>Wipe all elements of the NodeList to a specified width: or height:</description>
        <example>
	 dojo.query(".box").wipeTo({ width: 300px }).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="Array" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wrap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="OpenAjax.hub">
    <methods>
      <method name="registerLibrary" scope="instance">
        <parameters>
          <parameter name="prefix" type="Object" usage="required"/>
          <parameter name="nsURL" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="extra" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterLibrary" scope="instance">
        <parameters>
          <parameter name="prefix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="subscriberData" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="sub" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_subscribe" scope="instance">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="sub" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_publish" scope="instance">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unsubscribe" scope="instance">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="sid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reinit" scope="instance"/>
    </methods>
    <properties>
      <property name="implementer" scope="instance" type="Object"/>
      <property name="implVersion" scope="instance" type="Object"/>
      <property name="specVersion" scope="instance" type="Object"/>
      <property name="implExtraData" scope="instance" type="Object"/>
      <property name="libraries" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
      <property name="_cleanup" scope="instance" type="Object"/>
      <property name="_subIndex" scope="instance" type="Object"/>
      <property name="_pubDepth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="OpenAjax">
    <description>the OpenAjax hub</description>
    <properties>
      <property name="_pubDepth" scope="instance" type="Object"/>
      <property name="_cleanup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Color">
    <description>takes a named string, hex string, array of rgb or rgba values,
	an object with r, g, b, and a properties, or another dojo.Color object</description>
    <methods>
      <method name="_set" scope="prototype">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="prototype">
        <description>takes a named string, hex string, array of rgb or rgba values,
	an object with r, g, b, and a properties, or another dojo.Color object</description>
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="sanitize" scope="prototype">
        <description>makes sure that the object has correct attributes</description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="toRgb" scope="prototype">
        <description>returns 3 component array of rgb values</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toRgba" scope="prototype">
        <description>returns a 4 component array of rgba values</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toHex" scope="prototype">
        <description>returns a css color string in hexadecimal representation</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toCss" scope="prototype">
        <description>returns a css color string in rgb(a) representation</description>
        <parameters>
          <parameter name="includeAlpha" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <description>returns a visual representation of the color</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="r" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Color.named">
    <properties>
      <property name="black" scope="instance" type="Object"/>
      <property name="silver" scope="instance" type="Object"/>
      <property name="gray" scope="instance" type="Object"/>
      <property name="white" scope="instance" type="Object"/>
      <property name="maroon" scope="instance" type="Object"/>
      <property name="red" scope="instance" type="Object"/>
      <property name="purple" scope="instance" type="Object"/>
      <property name="fuchsia" scope="instance" type="Object"/>
      <property name="green" scope="instance" type="Object"/>
      <property name="lime" scope="instance" type="Object"/>
      <property name="olive" scope="instance" type="Object"/>
      <property name="yellow" scope="instance" type="Object"/>
      <property name="navy" scope="instance" type="Object"/>
      <property name="blue" scope="instance" type="Object"/>
      <property name="teal" scope="instance" type="Object"/>
      <property name="aqua" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Deferred">
    <description>Encapsulates a sequence of callbacks in response to a value that
	may not yet be available.  This is modeled after the Deferred class
	from Twisted &amp;lt;http://twistedmatrix.com&amp;gt;.</description>
    <example>
		var deferred = new dojo.Deferred();
		setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		return deferred;</example>
    <methods>
      <method name="cancel" scope="prototype">
        <description>Cancels a Deferred that has not yet received a value, or is
	waiting on another Deferred as its value.</description>
      </method>
      <method name="_resback" scope="prototype">
        <description>The private primitive that means either callback or errback</description>
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_check" scope="prototype"/>
      <method name="callback" scope="prototype">
        <description>Begin the callback sequence with a non-error value.</description>
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="errback" scope="prototype">
        <description>Begin the callback sequence with an error result.</description>
        <parameters>
          <parameter name="res" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="addBoth" scope="prototype">
        <description>Add the same function as both a callback and an errback as the
	next element on the callback sequence.This is useful for code
	that you want to guarantee to run, e.g. a finalizer.</description>
        <parameters>
          <parameter name="cb" type="Function|Object" usage="required"/>
          <parameter name="cbfn" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallback" scope="prototype">
        <description>Add a single callback to the end of the callback sequence.</description>
        <parameters>
          <parameter name="cb" type="Function|Object" usage="required"/>
          <parameter name="cbfn" type="String? .." usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addErrback" scope="prototype">
        <description>Add a single callback to the end of the callback sequence.</description>
        <parameters>
          <parameter name="cb" type="Object" usage="required"/>
          <parameter name="cbfn" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallbacks" scope="prototype">
        <description>Add separate callback and errback to the end of the callback
	sequence.</description>
        <parameters>
          <parameter name="cb" type="Object" usage="required"/>
          <parameter name="eb" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_fire" scope="prototype">
        <description>Used internally to exhaust the callback sequence when a result
	is available.</description>
      </method>
    </methods>
    <properties>
      <property name="chain" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="fired" scope="instance" type="Object"/>
      <property name="paused" scope="instance" type="Object"/>
      <property name="results" scope="instance" type="Object"/>
      <property name="canceller" scope="instance" type="Object"/>
      <property name="silentlyCancelled" scope="instance" type="Object"/>
      <property name="_nextId" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="djConfig">
    <description>Application code can set the global 'djConfig' prior to loading
	the library to override certain global settings for how dojo works.</description>
    <methods>
      <method name="addOnLoad" scope="instance">
        <description>or Array
	Adds a callback via dojo.addOnLoad. Useful when Dojo is added after
	the page loads and djConfig.afterOnLoad is true. Supports the same
	arguments as dojo.addOnLoad. When using a function reference, use
	`djConfig.addOnLoad = function(){};`. For object with function name use
	`djConfig.addOnLoad = [myObject, &amp;quot;functionName&amp;quot;];` and for object with
	function reference use
	`djConfig.addOnLoad = [myObject, function(){}];`</description>
      </method>
    </methods>
    <properties>
      <property name="isDebug" scope="instance" type="Boolean">
        <description>Defaults to `false`. If set to `true`, ensures that Dojo provides
	extended debugging feedback via Firebug. If Firebug is not available
	on your platform, setting `isDebug` to `true` will force Dojo to
	pull in (and display) the version of Firebug Lite which is
	integrated into the Dojo distribution, thereby always providing a
	debugging/logging console when `isDebug` is enabled. Note that
	Firebug's `console.*` methods are ALWAYS defined by Dojo. If
	`isDebug` is false and you are on a platform without Firebug, these
	methods will be defined as no-ops.</description>
      </property>
      <property name="debugAtAllCosts" scope="instance" type="Boolean">
        <description>Defaults to `false`. If set to `true`, this triggers an alternate
	mode of the package system in which dependencies are detected and
	only then are resources evaluated in dependency order via
	`&amp;lt;script&amp;gt;` tag inclusion. This may double-request resources and
	cause problems with scripts which expect `dojo.require()` to
	preform synchronously. `debugAtAllCosts` can be an invaluable
	debugging aid, but when using it, ensure that all code which
	depends on Dojo modules is wrapped in `dojo.addOnLoad()` handlers.
	Due to the somewhat unpredictable side-effects of using
	`debugAtAllCosts`, it is strongly recommended that you enable this
	flag as a last resort. `debugAtAllCosts` has no effect when loading
	resources across domains. For usage information, see the
	[Dojo Book](http://dojotoolkit.org/book/book-dojo/part-4-meta-dojo-making-your-dojo-code-run-faster-and-better/debugging-facilities/deb)</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>The locale to assume for loading localized resources in this page,
	specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	for details on loading localized resources. If no locale is specified,
	Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	or `navigator.language` properties.</description>
      </property>
      <property name="extraLocale" scope="instance" type="Array">
        <description>No default value. Specifies additional locales whose
	resources should also be loaded alongside the default locale when
	calls to `dojo.requireLocalization()` are processed.</description>
      </property>
      <property name="baseUrl" scope="instance" type="String">
        <description>The directory in which `dojo.js` is located. Under normal
	conditions, Dojo auto-detects the correct location from which it
	was loaded. You may need to manually configure `baseUrl` in cases
	where you have renamed `dojo.js` or in which `&amp;lt;base&amp;gt;` tags confuse
	some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	either the value of `djConfig.baseUrl` if one is provided or the
	auto-detected root if not. Other modules are located relative to
	this path.</description>
      </property>
      <property name="modulePaths" scope="instance" type="Object"/>
      <property name="afterOnLoad" scope="instance" type="Boolean">
        <description>Indicates Dojo was added to the page after the page load. In this case
	Dojo will not wait for the page DOMContentLoad/load events and fire
	its dojo.addOnLoad callbacks after making sure all outstanding
	dojo.required modules have loaded.</description>
      </property>
      <property name="require" scope="instance" type="Array">
        <description>An array of module names to be loaded immediately after dojo.js has been included
	in a page.</description>
      </property>
      <property name="urchin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.version">
    <description>version number of dojo</description>
    <methods>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="major" scope="instance" type="Integer">
        <description>Major version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 1
	minor: Integer
	Minor version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 2
	patch: Integer
	Patch version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 0
	flag: String
	Descriptor flag. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be &amp;quot;beta1&amp;quot;</description>
      </property>
      <property name="revision" scope="instance" type="Number">
        <description>The SVN rev from which dojo was pulled</description>
      </property>
    </properties>
  </class>
  <class type="dojo.config">
    <properties>
      <property name="baseUrl" scope="instance" type="Object"/>
      <property name="ieForceActiveXXhr" scope="instance" type="Object"/>
      <property name="useXDomain" scope="instance" type="Object"/>
      <property name="libraryScriptUri" scope="instance" type="Object"/>
      <property name="debugContainerId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="setTimeout">
    <description>provides timed callbacks using Java threads</description>
    <properties>
      <property name="hasSlept" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="console">
    <methods>
      <method name="debug" scope="instance">
        <description>Sends arguments to console. Missing finctionality to show script line of trace.</description>
      </method>
      <method name="log" scope="instance">
        <description>Sends arguments to console.</description>
      </method>
      <method name="info" scope="instance">
        <description>Sends arguments to console, highlighted with (I) icon.</description>
      </method>
      <method name="warn" scope="instance">
        <description>Sends warning arguments to console, highlighted with (!) icon and blue style.</description>
      </method>
      <method name="error" scope="instance">
        <description>Sends error arguments (object) to console, highlighted with (X) icon and yellow style
	NEW: error object now displays in object inspector</description>
      </method>
      <method name="assert" scope="instance">
        <description>Tests for true. Throws exception if false.</description>
        <parameters>
          <parameter name="truth" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dir" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dirxml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="group" scope="instance">
        <description>collects log messages into a group, starting with this call and ending with
	groupEnd(). Missing collapse functionality</description>
      </method>
      <method name="groupEnd" scope="instance">
        <description>Closes group. See above</description>
      </method>
      <method name="time" scope="instance">
        <description>Starts timers assigned to name given in argument. Timer stops and displays on timeEnd(title);</description>
        <example>
		console.time("load");
		console.time("myFunction");
		console.timeEnd("load");
		console.timeEnd("myFunction");</example>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeEnd" scope="instance">
        <description>See above.</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="count" scope="instance">
        <description>Not supported</description>
      </method>
      <method name="trace" scope="instance">
        <description>Not supported</description>
      </method>
      <method name="profile" scope="instance">
        <description>Not supported</description>
      </method>
      <method name="profileEnd" scope="instance"/>
      <method name="clear" scope="instance">
        <description>Clears message console. Do not call this directly</description>
      </method>
      <method name="open" scope="instance">
        <description>Opens message console. Do not call this directly</description>
      </method>
      <method name="close" scope="instance">
        <description>Closes message console. Do not call this directly</description>
      </method>
      <method name="_restoreBorder" scope="instance"/>
      <method name="openDomInspector" scope="instance"/>
      <method name="_closeDomInspector" scope="instance"/>
      <method name="recss" scope="instance"/>
    </methods>
  </class>
  <class type="dojo._Url">
    <description>Constructor to create an object representing a URL.
	It is marked as private, since we might consider removing
	or simplifying it.</description>
    <methods>
      <method name="toString" scope="prototype"/>
    </methods>
    <properties>
      <property name="uri" scope="instance" type="Object"/>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="authority" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="fragment" scope="instance" type="Object"/>
      <property name="user" scope="instance" type="Object"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="host" scope="instance" type="Object"/>
      <property name="port" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._listener">
    <methods>
      <method name="getDispatcher" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.declare">
    <description>Create a feature-rich constructor from compact notation</description>
    <example>
		dojo.declare("my.classes.bar", my.classes.foo, {
			// properties to be added to the class prototype
			someValue: 2,
			// initialization function
			constructor: function(){
				this.myComplicatedObject = new ReallyComplicatedObject();
			},
			// other functions
			someMethod: function(){
				doStuff();
			}
		);</example>
    <methods>
      <method name="_delegate" scope="instance">
        <parameters>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extend" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeCtor" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.declare._core">
    <methods>
      <method name="_construct" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_findMixin" scope="instance">
        <parameters>
          <parameter name="mixin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_findMethod" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="ptype" type="Object" usage="required"/>
          <parameter name="has" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="inherited" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="newArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="ctor">
    <mixins scope="prototype">
      <mixin type="dd._core" scope="instance"/>
      <mixin type="mp||0" scope="instance"/>
    </mixins>
    <properties>
      <property name="_constructor" scope="prototype" type="Object"/>
      <property name="preamble" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo._event_listener">
    <methods>
      <method name="_fixCallback" scope="instance">
        <parameters>
          <parameter name="fp" type="Object" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>clobbers the listener from the node</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>DOM node to attach the event to</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>the name of the handler to remove the function from</description>
          </parameter>
          <parameter name="handle" type="Handle" usage="required">
            <description>the handle returned from add</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizeEventName" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setKeyChar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="del">
    <properties>
      <property name="_synthesizeEvent" scope="instance" type="Object"/>
      <property name="_add" scope="instance" type="Object"/>
      <property name="_remove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._event_listener._punctMap">
    <properties>
      <property name="106" scope="instance" type="Object"/>
      <property name="111" scope="instance" type="Object"/>
      <property name="186" scope="instance" type="Object"/>
      <property name="187" scope="instance" type="Object"/>
      <property name="188" scope="instance" type="Object"/>
      <property name="189" scope="instance" type="Object"/>
      <property name="190" scope="instance" type="Object"/>
      <property name="191" scope="instance" type="Object"/>
      <property name="192" scope="instance" type="Object"/>
      <property name="219" scope="instance" type="Object"/>
      <property name="220" scope="instance" type="Object"/>
      <property name="221" scope="instance" type="Object"/>
      <property name="222" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.keys">
    <description>definitions for common key values</description>
    <properties>
      <property name="BACKSPACE" scope="instance" type="Object"/>
      <property name="TAB" scope="instance" type="Object"/>
      <property name="CLEAR" scope="instance" type="Object"/>
      <property name="ENTER" scope="instance" type="Object"/>
      <property name="SHIFT" scope="instance" type="Object"/>
      <property name="CTRL" scope="instance" type="Object"/>
      <property name="ALT" scope="instance" type="Object"/>
      <property name="PAUSE" scope="instance" type="Object"/>
      <property name="CAPS_LOCK" scope="instance" type="Object"/>
      <property name="ESCAPE" scope="instance" type="Object"/>
      <property name="SPACE" scope="instance" type="Object"/>
      <property name="PAGE_UP" scope="instance" type="Object"/>
      <property name="PAGE_DOWN" scope="instance" type="Object"/>
      <property name="END" scope="instance" type="Object"/>
      <property name="HOME" scope="instance" type="Object"/>
      <property name="LEFT_ARROW" scope="instance" type="Object"/>
      <property name="UP_ARROW" scope="instance" type="Object"/>
      <property name="RIGHT_ARROW" scope="instance" type="Object"/>
      <property name="DOWN_ARROW" scope="instance" type="Object"/>
      <property name="INSERT" scope="instance" type="Object"/>
      <property name="DELETE" scope="instance" type="Object"/>
      <property name="HELP" scope="instance" type="Object"/>
      <property name="LEFT_WINDOW" scope="instance" type="Object"/>
      <property name="RIGHT_WINDOW" scope="instance" type="Object"/>
      <property name="SELECT" scope="instance" type="Object"/>
      <property name="NUMPAD_0" scope="instance" type="Object"/>
      <property name="NUMPAD_1" scope="instance" type="Object"/>
      <property name="NUMPAD_2" scope="instance" type="Object"/>
      <property name="NUMPAD_3" scope="instance" type="Object"/>
      <property name="NUMPAD_4" scope="instance" type="Object"/>
      <property name="NUMPAD_5" scope="instance" type="Object"/>
      <property name="NUMPAD_6" scope="instance" type="Object"/>
      <property name="NUMPAD_7" scope="instance" type="Object"/>
      <property name="NUMPAD_8" scope="instance" type="Object"/>
      <property name="NUMPAD_9" scope="instance" type="Object"/>
      <property name="NUMPAD_MULTIPLY" scope="instance" type="Object"/>
      <property name="NUMPAD_PLUS" scope="instance" type="Object"/>
      <property name="NUMPAD_ENTER" scope="instance" type="Object"/>
      <property name="NUMPAD_MINUS" scope="instance" type="Object"/>
      <property name="NUMPAD_PERIOD" scope="instance" type="Object"/>
      <property name="NUMPAD_DIVIDE" scope="instance" type="Object"/>
      <property name="F1" scope="instance" type="Object"/>
      <property name="F2" scope="instance" type="Object"/>
      <property name="F3" scope="instance" type="Object"/>
      <property name="F4" scope="instance" type="Object"/>
      <property name="F5" scope="instance" type="Object"/>
      <property name="F6" scope="instance" type="Object"/>
      <property name="F7" scope="instance" type="Object"/>
      <property name="F8" scope="instance" type="Object"/>
      <property name="F9" scope="instance" type="Object"/>
      <property name="F10" scope="instance" type="Object"/>
      <property name="F11" scope="instance" type="Object"/>
      <property name="F12" scope="instance" type="Object"/>
      <property name="F13" scope="instance" type="Object"/>
      <property name="F14" scope="instance" type="Object"/>
      <property name="F15" scope="instance" type="Object"/>
      <property name="NUM_LOCK" scope="instance" type="Object"/>
      <property name="SCROLL_LOCK" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._ie_listener">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__AnimArgs" superclass="dojo.__FadeArgs">
    <properties>
      <property name="properties" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo._Animation">
    <methods>
      <method name="easing" scope="prototype">
        <description>A Function to adjust the acceleration (or deceleration) of the progress
	across a dojo._Line</description>
      </method>
      <method name="_fire" scope="prototype">
        <description>Convenience function.  Fire event &amp;quot;evt&amp;quot; and pass it the
	arguments specified in &amp;quot;args&amp;quot;.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event to fire.</description>
          </parameter>
          <parameter name="args" type="Array" usage="optional">
            <description>The arguments to pass to the event.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="play" scope="prototype">
        <description>Start the animation.</description>
        <parameters>
          <parameter name="delay" type="int" usage="optional">
            <description>How many milliseconds to delay before starting.</description>
          </parameter>
          <parameter name="gotoStart" type="Boolean" usage="optional">
            <description>If true, starts the animation from the beginning; otherwise,
	starts it from its current position.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_play" scope="prototype">
        <parameters>
          <parameter name="gotoStart" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="pause" scope="prototype">
        <description>Pauses a running animation.</description>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="gotoPercent" scope="prototype">
        <description>Sets the progress of the animation.</description>
        <parameters>
          <parameter name="percent" type="Decimal" usage="required">
            <description>A percentage in decimal notation (between and including 0.0 and 1.0).</description>
          </parameter>
          <parameter name="andPlay" type="Boolean" usage="optional">
            <description>If true, play the animation after setting the progress.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="stop" scope="prototype">
        <description>Stops a running animation.</description>
        <parameters>
          <parameter name="gotoEnd" type="boolean" usage="optional">
            <description>If true, the animation will end.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="status" scope="prototype">
        <description>Returns a string token representation of the status of
	the animation, one of: &amp;quot;paused&amp;quot;, &amp;quot;playing&amp;quot;, &amp;quot;stopped&amp;quot;</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cycle" scope="prototype">
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_startTimer" scope="prototype"/>
      <method name="_stopTimer" scope="prototype"/>
    </methods>
    <properties>
      <property name="duration" scope="prototype" type="Integer">
        <description>The time in milliseonds the animation will take to run</description>
      </property>
      <property name="curve" scope="instance-prototype" type="dojo._Line||Array">
        <description>A two element array of start and end values, or a dojo._Line instance to be
	used in the Animation.</description>
      </property>
      <property name="repeat" scope="prototype" type="Integer">
        <description>The number of times to loop the animation</description>
      </property>
      <property name="rate" scope="prototype" type="Integer">
        <description>the time in milliseconds to wait before advancing to next frame
	(used as a fps timer: rate/1000 = fps)</description>
      </property>
      <property name="delay" scope="prototype" type="Integer">
        <description>The time in milliseconds to wait before starting animation after it has been .play()'ed</description>
      </property>
      <property name="beforeBegin" scope="prototype" type="events">
        <description>Event
	Synthetic event fired before a dojo._Animation begins playing (synchronous)</description>
      </property>
      <property name="onBegin" scope="prototype" type="Event">
        <description>Synthetic event fired as a dojo._Animation begins playing (useful?)</description>
      </property>
      <property name="onAnimate" scope="prototype" type="Event">
        <description>Synthetic event fired at each interval of a dojo._Animation</description>
      </property>
      <property name="onEnd" scope="prototype" type="Event">
        <description>Synthetic event fired after the final frame of a dojo._Animation</description>
      </property>
      <property name="onPlay" scope="prototype" type="Event">
        <description>Synthetic event fired any time a dojo._Animation is play()'ed</description>
      </property>
      <property name="onPause" scope="prototype" type="Event">
        <description>Synthetic event fired when a dojo._Animation is paused</description>
      </property>
      <property name="onStop" scope="prototype" type="Event">
        <description>Synthetic event fires when a dojo._Animation is stopped</description>
      </property>
      <property name="_percent" scope="instance-prototype" type="Object"/>
      <property name="_startRepeatCount" scope="prototype" type="Object"/>
      <property name="_paused" scope="instance" type="Object"/>
      <property name="_active" scope="instance" type="Object"/>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._Line">
    <description>dojo._Line is the object used to generate values from a start value
	to an end value</description>
    <methods>
      <method name="getValue" scope="instance">
        <description>returns the point on the line</description>
        <parameters>
          <parameter name="n" type="float" usage="required">
            <description>a floating point number greater than 0 and less than 1</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="int">
        <description>Beginning value for range</description>
      </property>
      <property name="end" scope="instance" type="int">
        <description>Ending value for range</description>
      </property>
    </properties>
  </class>
  <class type="dojo.__FadeArgs">
    <properties>
      <property name="node" scope="instance" type="DOMNode|String">
        <description>The node referenced in the animation</description>
      </property>
      <property name="duration" scope="instance" type="Integer?">
        <description>Duration of the animation in milliseconds.</description>
      </property>
      <property name="easing" scope="instance" type="Function?">
        <description>An easing function.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.animateProperty">
    <description>Returns an animation that will transition the properties of
	node defined in 'args' depending how they are defined in
	'args.properties'</description>
    <example>A simple animation that changes the width of the specified node.
		dojo.animateProperty({
			node: "nodeId",
			properties: { width: 400 },
		}).play();
	Dojo figures out the start value for the width and converts the
	integer specified for the width to the more expressive but
	verbose form `{ width: { end: '400', units: 'px' } }` which you
	can also specify directly</example>
    <properties>
      <property name="curve" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.animateProperty.node">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="1.style">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__XhrArgs" superclass="dojo.__IoArgs">
    <description>In addition to the properties listed for the dojo._IoArgs type,
	the following properties are allowed for dojo.xhr* methods.</description>
    <properties>
      <property name="handleAs" scope="instance" type="String?">
        <description>Acceptable values are: text (default), json, json-comment-optional,
	json-comment-filtered, javascript, xml</description>
      </property>
      <property name="sync" scope="instance" type="Boolean?">
        <description>false is default. Indicates whether the request should
	be a synchronous (blocking) request.</description>
      </property>
      <property name="headers" scope="instance" type="Object?">
        <description>Additional HTTP headers to send in the request.</description>
      </property>
    </properties>
  </class>
  <class type="dojo._contentHandlers">
    <methods>
      <method name="json-comment-optional" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="text" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-filtered" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="javascript" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="xml" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="auto" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__IoArgs">
    <properties>
      <property name="url" scope="instance" type="String">
        <description>URL to server endpoint.</description>
      </property>
      <property name="content" scope="instance" type="Object?">
        <description>Contains properties with string values. These
	properties will be serialized as name1=value2 and
	passed in the request.</description>
      </property>
      <property name="timeout" scope="instance" type="Integer?">
        <description>Milliseconds to wait for the response. If this time
	passes, the then error callbacks are called.</description>
      </property>
      <property name="form" scope="instance" type="DOMNode?">
        <description>DOM node for a form. Used to extract the form values
	and send to the server.</description>
      </property>
      <property name="preventCache" scope="instance" type="Boolean?">
        <description>Default is false. If true, then a
	&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
	with a value that changes with each request
	(timestamp). Useful only with GET-type requests.</description>
      </property>
      <property name="handleAs" scope="instance" type="String?">
        <description>Acceptable values depend on the type of IO
	transport (see specific IO calls for more information).</description>
      </property>
      <property name="load" scope="instance" type="Function?">
        <description>function(response, ioArgs){} response is of type Object, ioArgs
	is of type dojo.__IoCallbackArgs.  This function will be
	called on a successful HTTP response code.</description>
      </property>
      <property name="error" scope="instance" type="Function?">
        <description>function(response, ioArgs){} response is of type Object, ioArgs
	is of type dojo.__IoCallbackArgs. This function will
	be called when the request fails due to a network or server error, the url
	is invalid, etc. It will also be called if the load or handle callback throws an
	exception, unless djConfig.isDebug is true.  This allows deployed applications
	to continue to run even when a logic error happens in the callback, while making
	it easier to troubleshoot while in debug mode.</description>
      </property>
      <property name="handle" scope="instance" type="Function?">
        <description>function(response, ioArgs){} response is of type Object, ioArgs
	is of type dojo.__IoCallbackArgs.  This function will
	be called at the end of every request, whether or not an error occurs.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.__IoCallbackArgs">
    <properties>
      <property name="args" scope="instance" type="Object">
        <description>the original object argument to the IO call.</description>
      </property>
      <property name="xhr" scope="instance" type="XMLHttpRequest">
        <description>For XMLHttpRequest calls only, the
	XMLHttpRequest object that was used for the
	request.</description>
      </property>
      <property name="url" scope="instance" type="String">
        <description>The final URL used for the call. Many times it
	will be different than the original args.url
	value.</description>
      </property>
      <property name="query" scope="instance" type="String">
        <description>For non-GET requests, the
	name1=value1&amp;amp;name2=value2 parameters sent up in
	the request.</description>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <description>The final indicator on how the response will be
	handled.</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>For dojo.io.script calls only, the internal
	script ID used for the request.</description>
      </property>
      <property name="canDelete" scope="instance" type="Boolean">
        <description>For dojo.io.script calls only, indicates
	whether the script tag that represents the
	request can be deleted after callbacks have
	been called. Used internally to know when
	cleanup can happen on JSONP-type requests.</description>
      </property>
      <property name="json" scope="instance" type="Object">
        <description>For dojo.io.script calls only: holds the JSON
	response for JSONP-type requests. Used
	internally to hold on to the JSON responses.
	You should not need to access it directly --
	the same object should be passed to the success
	callbacks directly.</description>
      </property>
    </properties>
  </class>
  <class type="window">
    <properties>
      <property name="dojo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleFrame.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="styleElement">
    <properties>
      <property name="href" scope="instance" type="Object"/>
      <property name="rel" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleFrame">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="commandLine">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleBody.style">
    <properties>
      <property name="top" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleObjectInspector.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleDomInspector.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="commandLine.style">
    <properties>
      <property name="bottom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="consoleBody">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="row">
    <properties>
      <property name="className" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="groupRowBox">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="btn">
    <properties>
      <property name="obj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="event">
    <properties>
      <property name="cancelBubble" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="document">
    <properties>
      <property name="cookie" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.console">
    <properties>
      <property name="_connects" scope="instance" type="Object"/>
      <property name="openConsole" scope="instance" type="Object"/>
      <property name="openObjectInspector" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._firebug">
    <properties>
      <property name="firebug" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.location">
    <properties>
      <property name="hash" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.back">
    <description>Browser history management resources</description>
    <methods>
      <method name="init" scope="instance">
        <description>Initializes the undo stack. This must be called from a &amp;lt;script&amp;gt;
	block that lives inside the &amp;lt;body&amp;gt; tag to prevent bugs on IE.</description>
        <return-types>
          <return-type type="prevent reinit"/>
        </return-types>
      </method>
      <method name="setInitialState" scope="instance">
        <description>Sets the state object and back callback for the very first page
	that is loaded.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>See the addToHistory() function for the list of valid args properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addToHistory" scope="instance">
        <description>adds a state object (args) to the history list.</description>
        <example>
		dojo.back.addToHistory({
			back: function(){ console.debug('back pressed'); },
			forward: function(){ console.debug('forward pressed'); },
			changeUrl: true
		});</example>
        <parameters>
          <parameter name="args" type="dojo.__backArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeLoaded" scope="instance">
        <description>private method. Do not call this directly.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="ifrLoc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="getHash" scope="instance" type="Object"/>
      <property name="setHash" scope="instance" type="Object"/>
      <property name="goBack" scope="instance" type="Object"/>
      <property name="goForward" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="historyIframe">
    <properties>
      <property name="location" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.behavior">
    <description>Utility for unobtrusive/progressive event binding, DOM traversal,
	and manipulation.</description>
    <methods>
      <method name="add" scope="instance">
        <description>Add the specified behavior to the list of behaviors, ignoring existing
	matches.</description>
        <example>Simple list of properties. "found" is special. "Found" is assumed if
	no property object for a given selector, and property is a function.
		dojo.behavior.add({
			"#id": {
				"found": function(element){
					// node match found
				},
				"onclick": function(evt){
					// register onclick handler for found node
				}
			},
			"#otherid": function(element){
				// assumes "found" with this syntax
			}
		});</example>
        <parameters>
          <parameter name="behaviorObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <description>Applies all currently registered behaviors to the document.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="func" scope="instance"/>
    </mixins>
    <properties>
      <property name="_behaviors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.cldr.monetary">
    <methods>
      <method name="getData" scope="instance">
        <description>A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.</description>
        <parameters>
          <parameter name="code" type="String" usage="required">
            <description>an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr">
    <description>transformation of relevant pieces of the Unicode.org Common Locale Data Repository
	(see http://unicode.org/cldr) to JSON from the original XML with associated utility classes</description>
  </class>
  <class type="dojo.cldr.supplemental">
    <methods>
      <method name="getFirstDayOfWeek" scope="instance">
        <description>Returns a zero-based index for first day of the week</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_region" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getWeekend" scope="instance">
        <description>Returns a hash containing the start and end days of the weekend</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object {start,end}"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.colors">
    <description>Color utilities</description>
    <methods>
      <method name="makeGrey" scope="instance">
        <description>creates a greyscale color with an optional alpha</description>
        <parameters>
          <parameter name="g" type="Number" usage="required"/>
          <parameter name="a" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.cookie">
    <description>Get or set a cookie.</description>
    <example>set a cookie with the JSON-serialized contents of an object which
	will expire 5 days from now:
		dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });</example>
    <methods>
      <method name="isSupported" scope="instance">
        <description>Use to determine if the current browser supports cookies or not.
	Returns true if user allows cookies.
	Returns false if user doesn't allow cookies.</description>
      </method>
    </methods>
  </class>
  <class type="dojo.currency">
    <description>localized formatting and parsing routines for currencies</description>
    <methods>
      <method name="_mixInDefaults" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Format a Number as a currency, using locale-specific settings</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Builds the regular needed to parse a currency value</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Convert a properly formatted currency string to a primitive Number,
	using locale-specific settings.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a Number</description>
          </parameter>
          <parameter name="options" type="dojo.currency.__ParseOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.currency.__ParseOptions" superclass="dojo.number.__ParseOptions">
    <properties>
      <property name="type" scope="prototype" type="String?">
        <description>currency, set by default.</description>
      </property>
      <property name="symbol" scope="prototype" type="String?">
        <description>override currency symbol. Normally, will be looked up in table of supported currencies,
	and ISO currency code will be used if not found.  See dojo.i18n.cldr.nls-&amp;gt;currency.js</description>
      </property>
      <property name="places" scope="prototype" type="Number?">
        <description>number of decimal places to accept.  Default is defined by currency.</description>
      </property>
      <property name="fractional" scope="prototype" type="Boolean?|Array?">
        <description>where places are implied by pattern or explicit 'places' parameter, whether to include the fractional portion.
	By default for currencies, it the fractional portion is optional.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.data">
    <description>A uniform data access layer</description>
  </class>
  <class type="dojo.data.ItemFileReadStore">
    <description>constructor</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <description>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</description>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <description>Internal function to determine which list of items to search over.</description>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="prototype">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.
	First, we define a couple little utility functions...</return-description>
        <return-types>
          <return-type type="examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <description>Method to add an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.
	Stub function, does nothing.  Real processing is in ItemFileWriteStore.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object "/>
          <return-type type="Object"/>
          <return-type type=" String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="prototype">
        <description>Internal function to look an item up by its identity map.</description>
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentifierAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="prototype">
        <description>Internal function to force a load of the store if it hasn't occurred yet.  This is required
	for specific functions to work properly.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="typeMap" scope="prototype" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_jsonData" scope="instance" type="Object"/>
      <property name="_queuedFetches" scope="instance" type="Object"/>
      <property name="_arrayOfAllItems" scope="instance" type="Object"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Object"/>
      <property name="_itemsByIdentity" scope="instance" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_jsonFileUrl" scope="instance" type="Object"/>
      <property name="_datatypeMap" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="Object"/>
      <property name="_itemNumPropName" scope="instance" type="Object"/>
      <property name="_rootItemPropName" scope="instance" type="Object"/>
      <property name="_reverseRefMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore" superclass="dojo.data.ItemFileReadStore">
    <methods>
      <method name="_assert" scope="prototype">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="prototype"/>
      <method name="newItem" scope="prototype">
        <description>See dojo.data.api.Write.newItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="prototype">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>See dojo.data.api.Write.deleteItem()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>See dojo.data.api.Write.set()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <description>See dojo.data.api.Write.setValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>See dojo.data.api.Write.unsetAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <description>Method to add an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="prototype">
        <description>Method to remove an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="prototype">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="prototype">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="prototype">
        <description>Generate a string that can be saved to a file.
	The result should look similar to:
	http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json</description>
      </method>
      <method name="_isEmpty" scope="prototype">
        <description>Function to determine if an array or object has no properties or values.</description>
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <description>See dojo.data.api.Write.save()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <description>See dojo.data.api.Write.revert()</description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <description>See dojo.data.api.Write.isDirty()</description>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="prototype">
        <description>See dojo.data.api.Notification.onSet()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object | array" usage="required"/>
          <parameter name="newValue" type="object | array" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="prototype">
        <description>See dojo.data.api.Notification.onNew()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <description>See dojo.data.api.Notification.onDelete()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="Object"/>
      <property name="_saveInProgress" scope="instance" type="Object"/>
      <property name="_pending" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.api"/>
  <class type="dojo.data.api.Identity" superclass="dojo.data.api.Read">
    <description>This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.</description>
    <methods>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>Returns a unique identifier for an item.  The return value will be
	either a string or something that has a toString() method (such as,
	for example, a dojox.uuid.Uuid object).</description>
        <example>
		var itemId = store.getIdentity(kermit);
		assert(kermit === store.findByIdentity(store.getIdentity(kermit)));</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain its identifier.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>Returns an array of attribute names that are used to generate the identity.
	For most stores, this is a single attribute, but for some complex stores
	such as RDB backed stores that use compound (multi-attribute) identifiers
	it can be more than one.  If the identity is not composed of attributes
	on the item, it will return null.  This function is intended to identify
	the attributes that comprise the identity so that so that during a render
	of all attributes, the UI can hide the the identity information if it
	chooses.</description>
        <example>
		var itemId = store.getIdentity(kermit);
		var identifiers = store.getIdentityAttributes(itemId);
		assert(typeof identifiers === "array" || identifiers === null);</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>Given the identity of an item, this method returns the item that has
	that identity through the onItem callback.  Conforming implementations
	should return null if there is no item with the given identity.
	Implementations of fetchItemByIdentity() may sometimes return an item
	from a local cache and may sometimes fetch an item from a remote server,</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to locate and callbacks to invoke when the
	item has been located and load has completed.  The format of the object is as follows:
	{
	identity: string|object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *identity* parameter.
	The identity parameter is the identity of the item you wish to locate and load
	This attribute is required.  It should be a string or an object that toString()
	can be called on.
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the item located, or null if none found.
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global, item, request)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Notification" superclass="dojo.data.api.Read">
    <description>This is an abstract API that data provider implementations conform to.
	This file defines functions signatures and intentionally leaves all the
	functions unimplemented.</description>
    <example>
		function onSet(item, attribute, oldValue, newValue) {
			//Do something with the information...
		};
		var store = new some.newStore();
		dojo.connect(store, "onSet", onSet);</example>
    <methods>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="onSet" scope="prototype">
        <description>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item being modified.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute being changed represented as a string name.</description>
          </parameter>
          <parameter name="oldValue" type="object | array" usage="required">
            <description>The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,
	this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case of
	multi-valued attributes, it will be an array.</description>
          </parameter>
          <parameter name="newValue" type="object | array" usage="required">
            <description>The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	it will be an array.  In the case of unsetAttribute, the new value will be 'undefined'.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onNew" scope="prototype">
        <description>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required">
            <description>The item created.</description>
          </parameter>
          <parameter name="parentInfo" type="object" usage="optional">
            <description>An optional javascript object that is passed when the item created was placed in the store
	hierarchy as a value f another item's attribute, instead of a root level item.  Note that if this
	function is invoked with a value for parentInfo, then onSet is not invoked stating the attribute of
	the parent item was modified.  This is to avoid getting two notification  events occurring when a new item
	with a parent is created.  The structure passed in is as follows:
	{
	item: someItem,							//The parent item
	attribute:	&amp;quot;attribute-name-string&amp;quot;,	//The attribute the new item was assigned to.
	oldValue: something	//Whatever was the previous value for the attribute.
	//If it is a single-value attribute only, then this value will be a single value.
	//If it was a multi-valued attribute, then this will be an array of all the values minues the new one.
	newValue: something	//The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	//generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	//it will be an array.
	}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onDelete" scope="prototype">
        <description>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required">
            <description>The item deleted.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Read">
    <description>This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.  For more information on the dojo.data APIs,
	please visit: http://www.dojotoolkit.org/node/98</description>
    <methods>
      <method name="getValue" scope="prototype">
        <description>Returns a single attribute value.
	Returns defaultValue if and only if *item* does not have a value for *attribute*.
	Returns null if and only if null was explicitly set as the attribute value.
	Returns undefined if and only if the item does not have a value for the
	given attribute (which is the same as saying the item does not have the attribute).</description>
        <example>
		var darthVader = store.getValue(lukeSkywalker, "father");</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>Optional.  A default value to use for the getValue return in the attribute does not exist or has no value.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="a literal, an item, null, or undefined (never an array)"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>This getValues() method works just like the getValue() method, but getValues()
	always returns an array rather than a single attribute value.  The array
	may be empty, may contain a single attribute value, or may contain
	many attribute values.
	If the item does not have a value for the given attribute, then getValues()
	will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
	has a return of false, then store.getValues(item, attribute) will return [].)</description>
        <example>
		var friendsOfLuke = store.getValues(lukeSkywalker, "friends");</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="an array that may contain literals and items"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>Returns an array with all the attributes that this item has.  This
	method will always return an array; if the item has no attributes
	at all, getAttributes() will return an empty array: [].</description>
        <example>
		var array = store.getAttributes(kermit);</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>Returns true if the given *item* has a value for the given *attribute*.</description>
        <example>
		var trueOrFalse = store.hasAttribute(kermit, "color");</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <description>Returns true if the given *value* is one of the values that getValues()
	would return.</description>
        <example>
		var trueOrFalse = store.containsValue(kermit, "color", "green");</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match as a value for the attribute.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>Returns true if *something* is an item and came from the store instance.
	Returns false if *something* is a literal, an item from another store instance,
	or is any object other than an item.</description>
        <example>
		var yes = store.isItem(store.newItem());
		var no  = store.isItem("green");</example>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>Returns false if isItem(something) is false.  Returns false if
	if isItem(something) is true but the the item is not yet loaded
	in local memory (for example, if the item has not yet been read
	from the server).</description>
        <example>
		var yes = store.isItemLoaded(store.newItem());
		var no  = store.isItemLoaded("green");</example>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>Given an item, this method loads the item so that a subsequent call
	to store.isItemLoaded(item) will return true.  If a call to
	isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.  So, before invoking this method, check that
	the item has not already been loaded.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to load and callbacks to invoke when the
	load has completed.  The format of the object is as follows:
	{
	item: object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *item* parameter.
	The item parameter is an object that represents the item in question that should be
	contained by the store.  This attribute is required.
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the fully loaded item.
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>Given a query and set of defined options, such as a start and count of items to return,
	this method executes the query and makes the results available as data items.
	The format and expectations of stores is that they operate in a generally asynchronous
	manner, therefore callbacks are always used to return items located by the fetch parameters.</description>
        <example>Fetch all books identified by the query and call 'showBooks' when complete
		var request = store.fetch({query:"all books", onComplete: showBooks});</example>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required">
            <description>The keywordArgs parameter may either be an instance of
	conforming to dojo.data.api.Request or may be a simple anonymous object
	that may contain any of the following:
	{
	query: query-object or query-string,
	queryOptions: object,
	onBegin: Function,
	onItem: Function,
	onComplete: Function,
	onError: Function,
	scope: object,
	start: int
	count: int
	sort: array
	}
	All implementations should accept keywordArgs objects with any of
	the 9 standard properties: query, onBegin, onItem, onComplete, onError
	scope, sort, start, and count.  Some implementations may accept additional
	properties in the keywordArgs object as valid parameters, such as
	{includeOutliers:true}.
	The *query* parameter.
	The query may be optional in some data store implementations.
	The dojo.data.api.Read API does not specify the syntax or semantics
	of the query itself -- each different data store implementation
	may have its own notion of what a query should look like.
	However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	and dojox.data support an object structure query, where the object is a set of
	name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	widgets the recommended query parameter is a key/value object.  That does not mean that the
	the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query
	format.
	Further note:  In general for query objects that accept strings as attribute
	value matches, the store should also support basic filtering capability, such as *
	(match any character) and ? (match single character).  An example query that is a query object
	would be like: { attrFoo: &amp;quot;value*&amp;quot;}.  Which generally means match all items where they have
	an attribute named attrFoo, with a value that starts with 'value'.
	The *queryOptions* parameter
	The queryOptions parameter is an optional parameter used to specify optiosn that may modify
	the query in some fashion, such as doing a case insensitive search, or doing a deep search
	where all items in a hierarchical representation of data are scanned instead of just the root
	items.  It currently defines two options that all datastores should attempt to honor if possible:
	{
	ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
	deep: boolean 	//Whether or not a fetch should do a deep search of items and all child
	//items instead of just root-level items in a datastore.  Default is false.
	}
	The *onBegin* parameter.
	function(size, request);
	If an onBegin callback function is provided, the callback function
	will be called just once, before the first onItem callback is called.
	The onBegin callback function will be passed two arguments, the
	the total number of items identified and the Request object.  If the total number is
	unknown, then size will be -1.  Note that size is not necessarily the size of the
	collection of items returned from the query, as the request may have specified to return only a
	subset of the total set of items through the use of the start and count parameters.
	The *onItem* parameter.
	function(item, request);
	If an onItem callback function is provided, the callback function
	will be called as each item in the result is received. The callback
	function will be passed two arguments: the item itself, and the
	Request object.
	The *onComplete* parameter.
	function(items, request);
	If an onComplete callback function is provided, the callback function
	will be called just once, after the last onItem callback is called.
	Note that if the onItem callback is not present, then onComplete will be passed
	an array containing all items which matched the query and the request object.
	If the onItem callback is present, then onComplete is called as:
	onComplete(null, request).
	The *onError* parameter.
	function(errorData, request);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the query.
	The onError callback function will be passed two arguments:
	an Error object and the Request object.
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)
	The *start* parameter.
	If a start parameter is specified, this is a indication to the datastore to
	only start returning items once the start number of items have been located and
	skipped.  When this parameter is paired withh 'count', the store should be able
	to page across queries with millions of hits by only returning subsets of the
	hits for each query
	The *count* parameter.
	If a count parameter is specified, this is a indication to the datastore to
	only return up to that many items.  This allows a fetch call that may have
	millions of item matches to be paired down to something reasonable.
	The *sort* parameter.
	If a sort parameter is specified, this is a indication to the datastore to
	sort the items in some manner before returning the items.  The array is an array of
	javascript objects that must conform to the following format to be applied to the
	fetching of items:
	{
	attribute: attribute || attribute-name-string,
	descending: true|false;   // Optional.  Default is false.
	}
	Note that when comparing attributes, if an item contains no value for the attribute
	(undefined), then it the default ascending sort logic should push it to the bottom
	of the list.  In the descending order case, it such items should appear at the top of the list.</description>
          </parameter>
        </parameters>
        <return-description>The fetch() method will return a javascript object conforming to the API
	defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	object returned with the required functions in Request.js attached.
	Its general purpose is to provide a convenient way for a caller to abort an
	ongoing fetch.
	The Request object may also have additional properties when it is returned
	such as request.store property, which is a pointer to the datastore object that
	fetch() is a method of.</return-description>
        <return-types>
          <return-type type="an object conforming to the dojo.data.api.Request API"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>The getFeatures() method returns an simple keyword values object
	that specifies what interface features the datastore implements.
	A simple CsvStore may be read-only, and the only feature it
	implements will be the 'dojo.data.api.Read' interface, so the
	getFeatures() method will return an object like this one:
	{'dojo.data.api.Read': true}.
	A more sophisticated datastore might implement a variety of
	interface features, like 'dojo.data.api.Read', 'dojo.data.api.Write',
	'dojo.data.api.Identity', and 'dojo.data.api.Attribution'.</description>
      </method>
      <method name="close" scope="prototype">
        <description>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.</description>
        <example>
		var request = store.fetch({onComplete: doSomething});
		...
		store.close(request);</example>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required">
            <description>An instance of a request for the store to use to identify what to close out.
	If no request is passed, then the store should clear all internal caches (if any)
	and close out all 'open' connections.  It does not render the store unusable from
	there on, it merely cleans out any current data and resets the store to initial
	state.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the label for.</description>
          </parameter>
        </parameters>
        <return-description>A user-readable string representing the item or undefined if no user-readable label can
	be generated.</return-description>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the list of label attributes for.</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute names that were used to generate the label, or null if public attributes
	were not used to generate the label.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Request">
    <description>This class defines out the semantics of what a 'Request' object looks like
	when returned from a fetch() method.  In general, a request object is
	nothing more than the original keywordArgs from fetch with an abort function
	attached to it to allow users to abort a particular request if they so choose.
	No other functions are required on a general Request object return.  That does not
	inhibit other store implementations from adding extentions to it, of course.
	This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.
	For more details on fetch, see dojo.data.api.Read.fetch().</description>
    <methods>
      <method name="abort" scope="prototype">
        <description>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.</description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Write" superclass="dojo.data.api.Read">
    <description>This is an abstract API that data provider implementations conform to.
	This file defines function signatures and intentionally leaves all the
	functionss unimplemented.</description>
    <methods>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="newItem" scope="prototype">
        <description>Returns a newly created item.  Sets the attributes of the new
	item based on the *keywordArgs* provided.  In general, the attribute
	names in the keywords become the attributes in the new item and as for
	the attribute values in keywordArgs, they become the values of the attributes
	in the new item.  In addition, for stores that support hierarchical item
	creation, an optional second parameter is accepted that defines what item is the parent
	of the new item and what attribute of that item should the new item be assigned to.
	In general, this will assume that the attribute targetted is multi-valued and a new item
	is appended onto the list of values for that attribute.</description>
        <example>
		var kermit = store.newItem({name: "Kermit", color:[blue, green]});</example>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional">
            <description>A javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="optional">
            <description>An optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),
	and what attribute of that parent to assign the new item to.  If this is present, and the attribute specified
	is a multi-valued attribute, it will append this item into the array of values for that attribute.  The structure
	of the object is as follows:
	{
	parent: someItem,
	attribute: &amp;quot;attribute-name-string&amp;quot;
	}</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>Deletes an item from the store.</description>
        <example>
		var success = store.deleteItem(kermit);</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to delete.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <description>Sets the value of an attribute on an item.
	Replaces any previous value or values.</description>
        <example>
		var success = store.set(kermit, "color", "green");</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="value" type="almost anything" usage="required">
            <description>The value to assign to the item.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <description>Adds each value in the *values* array as a value of the given
	attribute on the given item.
	Replaces any previous value or values.
	Calling store.setValues(x, y, []) (with *values* as an empty array) has
	the same effect as calling store.unsetAttribute(x, y).</description>
        <example>
		var success = store.setValues(kermit, "color", ["green", "aqua"]);
		success = store.setValues(kermit, "color", []);
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to assign to the attribute..</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>Deletes all the values of an attribute on an item.</description>
        <example>
		var success = store.unsetAttribute(kermit, "color");
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to unset represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <description>Saves to the server all the changes that have been made locally.
	The save operation may take some time and is generally performed
	in an asynchronous fashion.  The outcome of the save action is
	is passed into the set of supported callbacks for the save.</description>
        <example>
		store.save({onComplete: onSave});
		store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});</example>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description> onComplete: function
	onError: function
	scope: object
	}
	The *onComplete* parameter.
	function();
	If an onComplete callback function is provided, the callback function
	will be called just once, after the save has completed.  No parameters
	are generally passed to the onComplete.
	The *onError* parameter.
	function(errorData);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the save.  The onError function will be based one parameter, the
	error.
	The *scope* parameter.
	If a scope object is provided, all of the callback function (
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onComplete.call(scope) vs.
	onComplete.call(dojo.global)</description>
          </parameter>
        </parameters>
        <return-description>Nothing.  Since the saves are generally asynchronous, there is
	no need to return anything.  All results are passed via callbacks.</return-description>
      </method>
      <method name="revert" scope="prototype">
        <description>Discards any unsaved changes.</description>
        <example>
		var success = store.revert();</example>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <description>Given an item, isDirty() returns true if the item has been modified
	since the last save().  If isDirty() is called with no *item* argument,
	then this function returns true if any item has been modified since
	the last save().</description>
        <example>
		var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
		var trueOrFalse = store.isDirty();       // true if any item is dirty</example>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>The item to check.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util.filter">
    <methods>
      <method name="patternToRegExp" scope="instance">
        <description>Helper function to convert a simple pattern to a regular expression for matching.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <description>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</description>
          </parameter>
          <parameter name="ignoreCase" type="boolean" usage="optional">
            <description>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util"/>
  <class type="dojo.data.util.simpleFetch">
    <methods>
      <method name="fetch" scope="instance">
        <description>The simpleFetch mixin is designed to serve as a set of function(s) that can
	be mixed into other datastore implementations to accelerate their development.
	The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	is not designed to work for datastores that respond to a fetch() call by incrementally
	loading items, or sequentially loading partial batches of the result
	set.  For datastores that mixin simpleFetch, simpleFetch
	implements a fetch method that automatically handles eight of the fetch()
	arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	The class mixing in simpleFetch should not implement fetch(),
	but should instead implement a _fetchItems() method.  The _fetchItems()
	method takes three arguments, the keywordArgs object that was passed
	to fetch(), a callback function to be called when the result array is
	available, and an error callback to be called if something goes wrong.
	The _fetchItems() method should ignore any keywordArgs parameters for
	start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	The _fetchItems() method needs to correctly handle any other keywordArgs
	parameters, including the query parameter and any optional parameters
	(such as includeChildren).  The _fetchItems() method should create an array of
	result items and pass it to the fetchHandler along with the original request object
	-- or, the _fetchItems() method may, if it wants to, create an new request object
	with other specifics about the request that are specific to the datastore and pass
	that as the request object to the handler.
	For more information on this specific function, see dojo.data.api.Read.fetch()</description>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util.sorter">
    <methods>
      <method name="basicComparator" scope="instance">
        <description>Basic comparision function that compares if an item is greater or less than another item</description>
        <parameters>
          <parameter name="a" type="anything" usage="required"/>
          <parameter name="b" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int, {-1,0,1}"/>
        </return-types>
      </method>
      <method name="createSortFunction" scope="instance">
        <description>Helper function to generate the sorting function based off the list of sort attributes.</description>
        <parameters>
          <parameter name="sortSpec" type="attributes array" usage="required">
            <description>array A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	The objects should be formatted as follows:
	{
	attribute: &amp;quot;attributeName-string&amp;quot; || attribute,
	descending: true|false;   // Default is false.
	}</description>
          </parameter>
          <parameter name="store" type="dojo.data.core.Read" usage="required">
            <description>object The datastore object to look up item values from.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale">
    <methods>
      <method name="getNames" scope="instance">
        <description>Used to get localized strings from dojo.cldr for day or month names.</description>
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>months || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>wide || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</description>
          </parameter>
          <parameter name="use" type="String" usage="optional">
            <description>standAlone || 'format' (default)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isWeekend" scope="instance">
        <description>Determines if the date falls on a weekend, according to local custom.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getDayOfYear" scope="instance">
        <description>gets the day of the year as represented by dateObject</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDayOfWeek" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <description>Format a Date object as a String, using locale-specific settings.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <description>Builds the regular needed to parse a localized date</description>
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <description>Convert a properly formatted string to a primitive Date object,
	using locale-specific settings.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string representation of a date</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>Add a reference to a bundle containing localized custom formats to be
	used by date/time formatting and parsing routines.</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getGregorianBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale.__FormatOptions">
    <properties>
      <property name="selector" scope="instance" type="String">
        <description>choice of 'time','date' (default: date and time)</description>
      </property>
      <property name="formatLength" scope="instance" type="String">
        <description>choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'</description>
      </property>
      <property name="datePattern" scope="instance" type="String">
        <description>override pattern with this string</description>
      </property>
      <property name="timePattern" scope="instance" type="String">
        <description>override pattern with this string</description>
      </property>
      <property name="am" scope="instance" type="String">
        <description>override strings for am in times</description>
      </property>
      <property name="pm" scope="instance" type="String">
        <description>override strings for pm in times</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="fullYear" scope="instance" type="Boolean">
        <description>(format only) use 4 digit years whenever 2 digit years are called for</description>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <description>(parse only) strict parsing, off by default</description>
      </property>
    </properties>
  </class>
  <class type="dojo.date">
    <description>Date manipulation utilities</description>
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <description>Returns the number of days in the month used by dateObject</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>Determines if the year of the dateObject is a leap year</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTimezoneName" scope="instance">
        <description>Get the user's time zone as provided by the browser</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>Needed because the timezone may vary with time (daylight savings)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="The result -- return empty string if nothing found"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Compare two date objects by date, time, or both.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <description>Add to a Date in intervals of different size, from milliseconds to years</description>
        <parameters>
          <parameter name="date" type="Date" usage="required">
            <description>object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <description>Get the difference in a specific unit of time (e.g., number of
	months, weeks, days, etc.) between two dates, rounded to the
	nearest integer.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Integer return value"/>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.stamp">
    <methods>
      <method name="fromISOString" scope="instance">
        <description>Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.</description>
        <parameters>
          <parameter name="formattedString" type="String" usage="required">
            <description>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00</description>
          </parameter>
          <parameter name="defaultTime" type="Number" usage="optional">
            <description>Used for defaults for fields omitted in the formattedString.
	Uses 1970-01-01T00:00:00.0Z by default.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date or null"/>
        </return-types>
      </method>
      <method name="toISOString" scope="instance">
        <description>Format a Date object as a string according a subset of the ISO-8601 standard</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>A Date object</description>
          </parameter>
          <parameter name="options" type="dojo.date.stamp.__Options" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.stamp.__Options">
    <properties>
      <property name="selector" scope="instance" type="String">
        <description>&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; for partial formatting of the Date object.
	Both date and time will be formatted by default.</description>
      </property>
      <property name="zulu" scope="instance" type="Boolean">
        <description>if true, UTC/GMT is used for a timezone</description>
      </property>
      <property name="milliseconds" scope="instance" type="Boolean">
        <description>if true, output milliseconds</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd">
    <description>Drag and Drop resources</description>
    <methods>
      <method name="_createNode" scope="instance">
        <description>returns a function, which creates an element of given tag
	(SPAN by default) and sets its innerHTML to given text</description>
        <parameters>
          <parameter name="tag" type="String" usage="required">
            <description>a tag name or empty for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="_createTrTd" scope="instance">
        <description>creates a TR/TD structure with given text as an innerHTML of TD</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for TD</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createSpan" scope="instance">
        <description>creates a SPAN element with given text as its innerHTML</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_defaultCreator" scope="instance">
        <description>takes a parent node, and returns an appropriate creator function</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a container node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="manager" scope="instance">
        <description>returns the current DnD manager, creates one if it is not created yet</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getViewport" scope="instance">
        <description>returns a viewport size (visible part of the window)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="autoScroll" scope="instance">
        <description>a handler for onmousemove event, which scrolls the window, if
	necesary</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="autoScrollNodes" scope="instance">
        <description>a handler for onmousemove event, which scrolls the first avaialble
	Dom element, it falls back to dojo.dnd.autoScroll()</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="getCopyKeyState" scope="instance">
        <description>abstracts away the difference between selection on Mac and PC,
	and returns the state of the &amp;quot;copy&amp;quot; key to be pressed.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getUniqueId" scope="instance">
        <description>returns a unique string for use with any DOM element</description>
      </method>
      <method name="isFormElement" scope="instance">
        <description>returns true, if user clicked on a form element</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_manager" scope="instance" type="Object"/>
      <property name="V_TRIGGER_AUTOSCROLL" scope="instance" type="Object"/>
      <property name="H_TRIGGER_AUTOSCROLL" scope="instance" type="Object"/>
      <property name="V_AUTOSCROLL_VALUE" scope="instance" type="Object"/>
      <property name="H_AUTOSCROLL_VALUE" scope="instance" type="Object"/>
      <property name="autoscroll" scope="instance" type="Object"/>
      <property name="_empty" scope="instance" type="Object"/>
      <property name="_isMac" scope="instance" type="Object"/>
      <property name="_copyKey" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="common" scope="instance" type="Object"/>
      <property name="constrainedMover" scope="instance" type="Object"/>
      <property name="boxConstrainedMover" scope="instance" type="Object"/>
      <property name="parentConstrainedMover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar">
    <description>an object, which represents transferred DnD items visually
	manager: Object: a DnD manager object</description>
    <methods>
      <method name="construct" scope="prototype">
        <description>a constructor function;
	it is separate so it can be (dynamically) overwritten in case of need</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>a desctructor for the avatar, called to remove all references so it can be garbage-collected</description>
      </method>
      <method name="update" scope="prototype">
        <description>updates the avatar to reflect the current DnD state</description>
      </method>
      <method name="_generateText" scope="prototype">
        <description>generates a proper text to reflect copying or moving of items</description>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Container">
    <description>a constructor of the Container</description>
    <methods>
      <method name="creator" scope="instance-prototype">
        <description>a creator function, which takes a data item, and returns an object like that:
	{node: newNode, data: usedData, type: arrayOfStrings}</description>
      </method>
      <method name="getItem" scope="prototype">
        <description>returns a data item by its key (id)</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setItem" scope="prototype">
        <description>associates a data item with its key (id)</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="delItem" scope="prototype">
        <description>removes a data item from the map by its key (id)</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forInItems" scope="prototype">
        <description>iterates over a data map skipping members, which
	are present in the empty object (IE and/or 3rd-party libraries).</description>
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="clearItems" scope="prototype">
        <description>removes all data items from the map</description>
      </method>
      <method name="getAllNodes" scope="prototype">
        <description>returns a list (an array) of all valid child nodes</description>
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="sync" scope="prototype">
        <description>synch up the node list with the data map</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="prototype">
        <description>inserts an array of new nodes before/after an anchor node</description>
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <description>a list of data items, which should be processed by the creator function</description>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before the anchor, if true, and after the anchor otherwise</description>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <description>the anchor node to be used as a point of insertion</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype">
        <description>collects valid child items and populate the map
	set up the real parent node</description>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>event processor for onmouseover</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <description>event processor for onmouseout</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="prototype">
        <description>event processor for onselectevent and ondragevent</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <description>this function is called once, when mouse is over our container</description>
      </method>
      <method name="onOutEvent" scope="prototype">
        <description>this function is called once, when mouse is out of our container</description>
      </method>
      <method name="_changeState" scope="prototype">
        <description>changes a named state to new state value</description>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>a name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="prototype">
        <description>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="prototype">
        <description>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="prototype">
        <description>gets a child, which is under the mouse at the moment, or null</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="prototype">
        <description>adds all necessary data to the output of the user-supplied creator function</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="skipForm" scope="instance-prototype" type="Boolean">
        <description>don't start the drag operation, if clicked on form elements
	dropParent: Node: node or node's id to use as the parent node for dropped items
	(must be underneath the 'node' parameter in the DOM)
	_skipStartup: Boolean: skip startup(), which collects children, for deferred initialization
	(this is used in the markup mode)</description>
      </property>
      <property name="map" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Node">
        <description>node or node's id to build the container on</description>
      </property>
      <property name="parent" scope="instance" type="Object"/>
      <property name="defaultCreator" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd._defaultCreatorNodes">
    <properties>
      <property name="ul" scope="instance" type="Object"/>
      <property name="ol" scope="instance" type="Object"/>
      <property name="div" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager">
    <description>the manager of DnD operations (usually a singleton)</description>
    <methods>
      <method name="overSource" scope="prototype">
        <description>called when a source detected a mouse-over conditiion</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="outSource" scope="prototype">
        <description>called when a source detected a mouse-out conditiion</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <description>called to initiate the DnD operation</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="canDrop" scope="prototype">
        <description>called to notify if the current target can accept items</description>
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stopDrag" scope="prototype">
        <description>stop the DnD in progress</description>
      </method>
      <method name="makeAvatar" scope="prototype">
        <description>makes the avatar, it is separate to be overwritten dynamically, if needed</description>
      </method>
      <method name="updateAvatar" scope="prototype">
        <description>updates the avatar, it is separate to be overwritten dynamically, if needed</description>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <description>event processor for onkeydown:
	watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <description>event processor for onkeyup, watching for CTRL for copy/move status</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCopyStatus" scope="prototype">
        <description>changes the copy status</description>
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <description>the copy status</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="OFFSET_X" scope="prototype" type="Object"/>
      <property name="OFFSET_Y" scope="prototype" type="Object"/>
      <property name="target" scope="instance" type="Object"/>
      <property name="canDropFlag" scope="instance" type="Object"/>
      <property name="nodes" scope="instance" type="Object"/>
      <property name="copy" scope="instance" type="Object"/>
      <property name="avatar" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.source">
    <properties>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="declaredClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Moveable">
    <description>an object, which makes a node moveable</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>stops watching for possible move, deletes all references, so the object can be garbage-collected</description>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown, creates a Mover for the node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove, used only for delayed drags</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup, used only for delayed drags</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="prototype">
        <description>event processor for onselectevent and ondragevent</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragDetected" scope="prototype">
        <description>called when the drag is detected,
	responsible for creation of the mover</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="prototype">
        <description>called before every move operation</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <description>called after every move operation</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <description>called during the very first move notification,
	can be used to initialize coordinates, can be overwritten.
	default implementation does nothing</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <description>called during every move notification,
	should actually move the node, can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="prototype">
        <description>called before every incremental move,
	can be overwritten.
	default implementation does nothing</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="prototype">
        <description>called after every incremental move,
	can be overwritten.
	default implementation does nothing</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handle" scope="instance-prototype" type="Node">
        <description>a node (or node's id), which is used as a mouse handle
	if omitted, the node itself is used as a handle</description>
      </property>
      <property name="delay" scope="instance-prototype" type="Number">
        <description>delay move by this number of pixels</description>
      </property>
      <property name="skip" scope="instance-prototype" type="Boolean">
        <description>skip move of form elements</description>
      </property>
      <property name="events" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Node">
        <description>a node (or node's id) to be moved</description>
      </property>
      <property name="mover" scope="instance" type="Object">
        <description>a constructor of custom Mover</description>
      </property>
    </properties>
  </class>
  <class type="dojox.analytics">
    <methods>
      <method name="schedulePusher" scope="prototype">
        <description>schedule the data pushing routines to happen in interval ms</description>
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addData" scope="prototype">
        <description>add data to the queue. Will be pusshed to the server on the next
	data push</description>
        <parameters>
          <parameter name="dataType" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkData" scope="prototype"/>
      <method name="pushData" scope="prototype"/>
      <method name="getQueryPacket" scope="prototype"/>
      <method name="onPushComplete" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_data" scope="instance" type="Object"/>
      <property name="_id" scope="instance" type="Object"/>
      <property name="sendInterval" scope="instance" type="Object"/>
      <property name="inTransitRetry" scope="instance" type="Object"/>
      <property name="dataUrl" scope="instance" type="Object"/>
      <property name="sendMethod" scope="instance" type="Object"/>
      <property name="maxRequestSize" scope="instance" type="Object"/>
      <property name="_inTransit" scope="instance" type="Object"/>
      <property name="_split" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.Urchin">
    <description>A Google-analytics helper, for post-onLoad inclusion of the tracker</description>
    <example>
		// create the tracker programatically:
		var tracker = new dojox.analytics.Urchin({ acct:"UA-123456-7" });</example>
    <methods>
      <method name="_loadGA" scope="prototype">
        <description>load the ga.js file and begin initialization process</description>
      </method>
      <method name="_checkGA" scope="prototype">
        <description>sniff the global _gat variable Google defines and either check again
	or fire onLoad if ready.</description>
      </method>
      <method name="_gotGA" scope="prototype">
        <description>initialize the tracker</description>
      </method>
      <method name="trackPageView" scope="prototype">
        <description>A public API attached to this widget instance, allowing you
	Ajax-like notification of updates.</description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>String A location to tell the tracker to track, eg: &amp;quot;/my-ajaxy-endpoint&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="this._loadGA" scope="instance"/>
    </mixins>
    <properties>
      <property name="acct" scope="prototype" type="String">
        <description>your GA urchin tracker account number.</description>
      </property>
      <property name="loadInterval" scope="prototype" type="Integer">
        <description>Time (in ms) to wait before checking for a ready Analytics API</description>
      </property>
      <property name="tracker" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.Urchin.GAonLoad">
    <description>Stub function to fire when urchin is complete</description>
  </class>
  <class type="dojox">
    <description>DojoX: the home for Dojo eXtensions</description>
    <methods>
      <method name="__temp__" scope="instance"/>
    </methods>
    <properties>
      <property name="_sql" scope="instance" type="Object">
        <description>objects to support Dojo Offline (dojox.off)</description>
      </property>
      <property name="crypto" scope="instance" type="Object">
        <description>Cryptography in JS.  DEPRECATED: use dojox.encoding instead.</description>
      </property>
      <property name="_clientId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.plugins">
    <methods>
      <method name="consoleMessages" scope="instance">
        <description>plugin to have analyitcs return the base info dojo collects</description>
      </method>
      <method name="dojo" scope="instance">
        <description>plugin to have analyitcs return the base info dojo collects</description>
      </method>
      <method name="window" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.analytics.plugins.idle">
    <methods>
      <method name="setIdle" scope="instance"/>
    </methods>
    <properties>
      <property name="addData" scope="instance" type="Object"/>
      <property name="idleTime" scope="instance" type="Object"/>
      <property name="idle" scope="instance" type="Object"/>
      <property name="idleTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.plugins.mouseClick">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="trimEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="addData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.plugins.mouseOver">
    <methods>
      <method name="toggleWatchMouse" scope="instance"/>
      <method name="sampleMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="trimMouseEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="watchMouse" scope="instance" type="Object"/>
      <property name="mouseSampleDelay" scope="instance" type="Object"/>
      <property name="addData" scope="instance" type="Object"/>
      <property name="targetProps" scope="instance" type="Object"/>
      <property name="_rateLimited" scope="instance" type="Object"/>
      <property name="_lastMouseEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dependencies">
    <properties>
      <property name="layers" scope="instance" type="Object"/>
      <property name="prefixes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.profiles.analytics">
    <properties>
      <property name="profile" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.profiles"/>
  <class type="dojox.analytics.profiles.analyticsInBase">
    <properties>
      <property name="profile" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av"/>
  <class type="dojox.av.FLVideo" superclass="dijit._Widget">
    <description>Inserts a Flash FLV video into the HTML page and provides methods
	and events for controlling the video. Also plays the H264/M4V codec
	with a little trickery: change the '.M4V' extension to '.flv'.</description>
    <example>markup:
		&lt;div id="vid" initialVolume=".7",
			mediaUrl="../resources/Grog.flv"
			dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
	programmatic:
		new dojox.av.FLVideo({
			initialVolume:.7,
			mediaUrl:"../resources/Grog.flv"
		}, "vid");
	mediaUrl: String
	REQUIRED: The Url of the video file that will be played.
	NOTE: Must be either an absolute URL or relative to the HTML file.
	Relative paths will be converted to abslute paths</example>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initialize the media.</description>
      </method>
      <method name="play" scope="prototype">
        <description>Plays the video. If an url is passed in, plays the new link.</description>
        <parameters>
          <parameter name="newUrl" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="prototype">
        <description>Pauses the video</description>
      </method>
      <method name="seek" scope="prototype">
        <description>Goes to the time passed in the argument</description>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="volume" scope="prototype">
        <description>Sets the volume of the video to the time in the
	argument - between 0 - 1.</description>
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="_checkBuffer" scope="prototype">
        <description>Checks that there is a proper buffer time between
	current playhead time and the amount of data loaded.
	Works only on FLVs with a duration (not older). Pauses
	the video while continuing download.</description>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
          <parameter name="bufferLength" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <description>Helper function to fire onPosition, check download progress,
	and check buffer.</description>
      </method>
      <method name="_normalizeUrl" scope="prototype">
        <description>Checks that path is relative to HTML file or
	convertes it to an absolute path.</description>
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="prototype">
        <description>Ensures volume is less than one</description>
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sub" scope="prototype">
        <description>helper for subscribing to topics</description>
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>destroys flash</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.av._Media" scope="prototype"/>
      <mixin type="dojox.av._Media" scope="instance"/>
    </mixins>
    <properties>
      <property name="_swfPath" scope="prototype" type="Uri">
        <description>The path to the video player SWF resource</description>
      </property>
      <property name="_subs" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Object"/>
      <property name="mediaUrl" scope="instance" type="Object"/>
      <property name="initialVolume" scope="instance" type="Object"/>
      <property name="flashMedia" scope="instance" type="Object"/>
      <property name="isPlaying" scope="instance" type="Object"/>
      <property name="isStopped" scope="instance" type="Object"/>
      <property name="percentDownloaded" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo._flashObject">
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av._Media">
    <description>Used as a mixin for dojox and AIR media</description>
    <methods>
      <method name="_initStatus" scope="prototype">
        <description>Connect mediaStatus to the media.</description>
      </method>
      <method name="getTime" scope="prototype">
        <description>Returns the current time of the video
	Note:
	Consider the onPosition event, which returns
	the time at a set interval. Too many trips to
	the SWF could impact performance.</description>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <description>Fired when the SWF player has loaded
	NOT when the video has loaded</description>
        <parameters>
          <parameter name="mov" type="SWF" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="prototype">
        <description>Fires the amount of that the media has been
	downloaded. Number, 0-100</description>
        <parameters>
          <parameter name="percent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>TODO: Return x/y of click
	Fires when the player is clicked
	Could be used to toggle play/pause, or
	do an external activity, like opening a new
	window.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="prototype">
        <description>Fired on SWF resize, or when its
	toggled between fullscreen.</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="prototype">
        <description>The video properties. Width, height, duration, etc.
	NOTE: 	if data is empty, this is an older FLV with no meta data.
	Duration cannot be determined. In original FLVs, duration
	could only be obtained with Flash Media Server.
	NOTE: 	Older FLVs can still return width and height
	and will do so on a second event call</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="prototype">
        <description>The position of the playhead in seconds</description>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="prototype">
        <description>Fires when video starts
	Good for setting the play button to pause
	during an autoPlay for example</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="prototype">
        <description>Fires when video starts and resumes</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="prototype">
        <description>Fires when teh pause button is clicked</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="prototype">
        <description>Fires when video ends
	Could be used to change pause button to play
	or show a post video graphic, like YouTube</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="prototype">
        <description>Fire when the Stop button is clicked
	TODO: 	This is not hooked up yet and shouldn't
	fire.</description>
      </method>
      <method name="onBuffer" scope="prototype">
        <description>Fires a boolean to tell if media
	is paused for buffering or if buffering
	has finished</description>
        <parameters>
          <parameter name="isBuffering" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <description>Fired when the player encounters an error</description>
        <example>
	 console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="prototype">
        <description>Simple status</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="prototype">
        <description>The status of the video from the SWF
	playing, stopped, bufering, etc.</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_figureStatus" scope="prototype">
        <description>Calculate media status, based on playhead movement, and
	onStop and onStart events
	TODO:
	Figure in real status from the media for more accurate results.</description>
      </method>
      <method name="_eventFactory" scope="prototype">
        <description>Creates a generic event object.</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="mediaUrl" scope="prototype" type="Object"/>
      <property name="initialVolume" scope="prototype" type="Float?">
        <description>The initial volume setting of the player. Acccepts between 0 and 1.</description>
      </property>
      <property name="autoPlay" scope="prototype" type="Boolean?">
        <description>Whether the video automatically plays on load or not.</description>
      </property>
      <property name="bufferTime" scope="prototype" type="Number?">
        <description>Time in milliseconds that the video should be loaded before it will
	play. May pause and resume to build up buffer. Prevents stuttering.
	Note:
	Older FLVs, without a duration, cannot be buffered.</description>
      </property>
      <property name="minBufferTime" scope="prototype" type="Number">
        <description>Time in milliseconds bwteen the playhead time and loaded time that
	will trigger the buffer. When buffer is triggered, video will pause
	until the bufferTime amount is buffered.
	Note: Should be a small number, greater than zero.</description>
      </property>
      <property name="updateTime" scope="prototype" type="Number">
        <description>How often, in milliseconds to get an update of the video position.</description>
      </property>
      <property name="id" scope="prototype" type="String?">
        <description>The id of this widget and the id of the SWF movie.</description>
      </property>
      <property name="isDebug" scope="prototype" type="Boolean?">
        <description>Setting to true tells the SWF to output log messages to Firebug.</description>
      </property>
      <property name="percentDownloaded" scope="prototype" type="read-only-Number">
        <description>The percentage the media has downloaded; from 0-100</description>
      </property>
      <property name="_flashObject" scope="prototype" type="read-only-Object">
        <description>The dojox.embed object</description>
      </property>
      <property name="flashMedia" scope="prototype" type="read-only-SWF">
        <description>The SWF object. Methods are passed to this.</description>
      </property>
      <property name="status" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
      <property name="_prevPos" scope="instance" type="Object"/>
      <property name="_prevStatus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget"/>
  <class type="dojox.av.widget.PlayButton" superclass="dijit._Widget">
    <description>A Play/Pause button widget to use with dojox.av.widget.Player</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Intialize button.</description>
      </method>
      <method name="setMedia" scope="prototype">
        <description>A common method to set the media in all Player widgets.
	May do connections and initializations.</description>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>Fired on play or pause click.</description>
      </method>
      <method name="onPlay" scope="prototype">
        <description>Fired on play click.</description>
      </method>
      <method name="onPause" scope="prototype">
        <description>Fired on pause click.</description>
      </method>
      <method name="showPlay" scope="prototype">
        <description>Toggles the pause button invisible and the play
	button visible..</description>
      </method>
      <method name="showPause" scope="prototype">
        <description>Toggles the play button invisible and the pause
	button visible.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="_mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Player" superclass="dijit._Widget">
    <description>A Media Player UI widget for all types of dojox.av and AIR media.</description>
    <example>
		&lt;div dojoType="dojox.av.widget.Player" playerWidth="100%"&gt;
	 		&lt;div controlType="video" initialVolume=".1"
	 			mediaUrl="video/Grog.flv" autoPlay="true"
				isDebug="false" dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
			 	&lt;div controlType="play" dojoType="dojox.av.widget.PlayButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="volume" dojoType="dojox.av.widget.VolumeButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="progress" dojoType="dojox.av.widget.ProgressSlider"&gt;&lt;/div&gt;
			 	&lt;div controlType="status" dojoType="dojox.av.widget.Status"&gt;&lt;/div&gt;
	 &lt;/div&gt;</example>
    <methods>
      <method name="_fillContent" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <description>Do player styling, and place child widgets in the proper location.</description>
      </method>
      <method name="startup" scope="prototype">
        <description>Fired when all children are ready. Set the media in
	all children with setMedia()</description>
      </method>
      <method name="onResize" scope="prototype">
        <description>If a player size is a percentage, this will fire an onResize
	event for all children, passing the size of the player.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="playerWidth" scope="prototype" type="Number">
        <description>or String */
	Sets the width of the player (not the video size)
	Number will be converted to pixels
	String will be used literally. EX: &amp;quot;320px&amp;quot; or &amp;quot;100%&amp;quot;</description>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="mediaNode" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.ProgressSlider" superclass="dijit._Widget">
    <description>A custom slider widget to use with dojox.av.widget.Player.</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initialize slider.</description>
      </method>
      <method name="setMedia" scope="prototype">
        <description>A common method to set the media in all Player widgets.
	May do connections and initializations.</description>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
          <parameter name="playerWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="prototype">
        <description>Fired when the mouse is moved. Sets the slider.</description>
        <parameters>
          <parameter name="evt" type="HTMLEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <description>Fired onmousedown of the slider handle.</description>
      </method>
      <method name="endDrag" scope="prototype">
        <description>Fired on document.onmouseup.</description>
      </method>
      <method name="setHandle" scope="prototype">
        <description>Sets the slider handle (when it is not being dragged)</description>
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLoadedPosition" scope="prototype">
        <description>Sets the download progress bar to the percentage of how much
	the media has been downloaded.</description>
        <parameters>
          <parameter name="decimal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="prototype">
        <description>Highlights the slider handle on mouseover, and
	stays highlighted during drag.</description>
      </method>
      <method name="handleOut" scope="prototype">
        <description>Unhighlights handle onmouseover, or on endDrag.</description>
      </method>
      <method name="onResize" scope="prototype">
        <description>Handles player resize. Need to recalculate the width of
	position an download bars.</description>
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="seeking" scope="instance" type="Object"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="finalWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="playerWidget" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="posCon" scope="instance" type="Object"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status" superclass="dijit._Widget">
    <description>A Status widget to use with dojox.av.widget.Player</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="setMedia" scope="prototype">
        <description>A common method to set the media in all Player widgets.
	May do connections and initializations.</description>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="prototype">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="prototype"/>
      <method name="onPlay" scope="prototype"/>
      <method name="onPause" scope="prototype"/>
      <method name="onStop" scope="prototype"/>
      <method name="onEnd" scope="prototype"/>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype"/>
      <method name="setStatus" scope="prototype">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="isError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toSeconds" scope="prototype">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="onPosition" scope="prototype" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.durNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.timeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.VolumeButton" superclass="dijit._Widget">
    <description>A volume widget to use with dojox.av.widget.Player</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initialize the widget.</description>
      </method>
      <method name="setMedia" scope="prototype">
        <description>A common method to set the media in all Player widgets.
	May do connections and initializations.</description>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateIcon" scope="prototype">
        <description>Changes the icon on the button according to volume level.</description>
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onShowVolume" scope="prototype">
        <description>Shows the volume slider.</description>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDocClick" scope="prototype">
        <description>Fired on document.onmousedown. Checks if clicked inside
	of this widget or not.</description>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onHideVolume" scope="prototype">
        <description>Hides volume slider.</description>
      </method>
      <method name="onDrag" scope="prototype">
        <description>Fired on mousemove. Updates volume and position of
	slider handle.</description>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <description>Fired on mousedown of the slider handle.</description>
      </method>
      <method name="endDrag" scope="prototype">
        <description>Fired on mouseup of the slider handle.</description>
      </method>
      <method name="handleOver" scope="prototype">
        <description>Highlights the slider handle on mouseover, and
	stays highlighted during drag.</description>
      </method>
      <method name="handleOut" scope="prototype">
        <description>Unhighlights handle onmouseover, or on endDrag.</description>
      </method>
      <method name="_getVolumeDim" scope="prototype">
        <description>Gets dimensions of slider background node.
	Only uses dojo.coords once, unless the page
	or player is resized.</description>
      </method>
      <method name="_getHandleDim" scope="prototype">
        <description>Gets dimensions of slider handle.
	Only uses dojo.marginBox once.</description>
      </method>
      <method name="onResize" scope="prototype">
        <description>Fired on player resize. Zeros dimensions
	so that it can be calculated again.</description>
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="slotWidth" scope="instance" type="Object"/>
      <property name="volumeSlider" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="showing" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="clickOff" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance" type="Object"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
      <property name="_domCoords" scope="instance" type="Object"/>
      <property name="_handleCoords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting">
    <description>Vector graphic, data-driven graphs and charts</description>
  </class>
  <class type="dojox.charting.Chart2D">
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="getCoords" scope="prototype"/>
      <method name="setTheme" scope="prototype">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="addPlot" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="updateSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getGeometry" scope="prototype"/>
      <method name="setAxisWindow" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setWindow" scope="prototype">
        <parameters>
          <parameter name="sx" type="Object" usage="required"/>
          <parameter name="sy" type="Object" usage="required"/>
          <parameter name="dx" type="Object" usage="required"/>
          <parameter name="dy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateGeometry" scope="prototype"/>
      <method name="fullGeometry" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="fullRender" scope="prototype"/>
      <method name="connectToPlot" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeClean" scope="prototype"/>
      <method name="_makeDirty" scope="prototype"/>
      <method name="_invalidateDependentPlots" scope="prototype">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
          <parameter name="verticalAxis" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="coords" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="dim" scope="instance" type="Object"/>
      <property name="offsets" scope="instance" type="Object"/>
      <property name="plotArea" scope="instance" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="axes" scope="instance" type="Object"/>
      <property name="stack" scope="instance" type="Object"/>
      <property name="plots" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="runs" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart3D">
    <methods>
      <method name="generate" scope="prototype"/>
      <method name="invalidate" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="addPlot" scope="prototype">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="prototype">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWall" scope="prototype">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeWall" scope="prototype">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="prototype">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="prototype">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateWalls" scope="prototype"/>
      <method name="_generatePlots" scope="prototype"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="view" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
      <property name="walls" scope="instance" type="Object"/>
      <property name="plots" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Element">
    <methods>
      <method name="createGroup" scope="prototype">
        <parameters>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="purgeGroup" scope="prototype"/>
      <method name="cleanGroup" scope="prototype">
        <parameters>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyHtmlElements" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="group" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="htmlElements" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Series" superclass="dojox.charting.Element">
    <methods>
      <method name="clear" scope="prototype"/>
    </methods>
    <properties>
      <property name="dyn" scope="instance" type="Object"/>
      <property name="plot" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme">
    <methods>
      <method name="defineColors" scope="prototype">
        <description>Generate a set of colors for the theme based on keyword
	arguments</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildMarkerArray" scope="prototype"/>
      <method name="_clone" scope="prototype">
        <description>Return a clone of this theme, with the position vars reset to 0.</description>
      </method>
      <method name="next" scope="prototype">
        <description>get either the next color or the next marker, depending on
	what was passed. If type is not passed, it assumes color.</description>
        <example>
		var color = myTheme.next();
		var color = myTheme.next("color");
		var marker = myTheme.next("marker");</example>
        <parameters>
          <parameter name="type" type="String" usage="optional">
            <description>Optional. One of either &amp;quot;color&amp;quot; or &amp;quot;marker&amp;quot;. Defaults to
	&amp;quot;color&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <description>resets both marker and color counters back to the start.
	Subsequent calls to `next` will retrievie the first value
	of each depending on the passed type.</description>
      </method>
    </methods>
    <properties>
      <property name="markers" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
      <property name="antiAlias" scope="instance" type="Object"/>
      <property name="assignColors" scope="instance" type="Object"/>
      <property name="assignMarkers" scope="instance" type="Object"/>
      <property name="_markers" scope="instance" type="Object"/>
      <property name="addMarker" scope="prototype" type="Object"/>
      <property name="setMarkers" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.Markers">
    <properties>
      <property name="CIRCLE" scope="instance" type="Object"/>
      <property name="SQUARE" scope="instance" type="Object"/>
      <property name="DIAMOND" scope="instance" type="Object"/>
      <property name="CROSS" scope="instance" type="Object"/>
      <property name="X" scope="instance" type="Object"/>
      <property name="TRIANGLE" scope="instance" type="Object"/>
      <property name="TRIANGLE_INVERTED" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme._def">
    <properties>
      <property name="chart" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme._current">
    <properties>
      <property name="marker" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d"/>
  <class type="dojox.charting.action2d.Base">
    <methods>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
      <method name="reset" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="handle" scope="instance" type="Object"/>
      <property name="anim" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="plot" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Base.overOutEvents">
    <properties>
      <property name="onmouseover" scope="instance" type="Object"/>
      <property name="onmouseout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="colorFun" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.optionalParams">
    <properties>
      <property name="highlight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Tooltip" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="aroundRect" scope="instance" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Tooltip.defaultParams">
    <properties>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d"/>
  <class type="dojox.charting.axis2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="clear" scope="prototype"/>
      <method name="initialized" scope="prototype"/>
      <method name="calculate" scope="prototype">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
          <parameter name="span" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScaler" scope="prototype"/>
      <method name="getTicks" scope="prototype"/>
      <method name="getOffsets" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="vertical" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default" superclass="dojox.charting.axis2d.Base">
    <methods>
      <method name="dependOnData" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="initialized" scope="prototype"/>
      <method name="setWindow" scope="prototype">
        <parameters>
          <parameter name="scale" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWindowScale" scope="prototype"/>
      <method name="getWindowOffset" scope="prototype"/>
      <method name="calculate" scope="prototype">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
          <parameter name="span" type="Object" usage="required"/>
          <parameter name="labels" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScaler" scope="prototype"/>
      <method name="getTicks" scope="prototype"/>
      <method name="getOffsets" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.defaultParams">
    <properties>
      <property name="vertical" scope="instance" type="Object"/>
      <property name="fixUpper" scope="instance" type="Object"/>
      <property name="fixLower" scope="instance" type="Object"/>
      <property name="natural" scope="instance" type="Object"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="includeZero" scope="instance" type="Object"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="majorLabels" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="minorLabels" scope="instance" type="Object"/>
      <property name="microTicks" scope="instance" type="Object"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.optionalParams">
    <properties>
      <property name="min" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
      <property name="from" scope="instance" type="Object"/>
      <property name="to" scope="instance" type="Object"/>
      <property name="majorTickStep" scope="instance" type="Object"/>
      <property name="minorTickStep" scope="instance" type="Object"/>
      <property name="microTickStep" scope="instance" type="Object"/>
      <property name="labels" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="majorTick" scope="instance" type="Object"/>
      <property name="minorTick" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="Object"/>
      <property name="fontColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.opt">
    <properties>
      <property name="from" scope="instance" type="Object"/>
      <property name="to" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.scaler">
    <properties>
      <property name="minMinorStep" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="s">
    <properties>
      <property name="marginLeft" scope="instance" type="Object"/>
      <property name="marginTop" scope="instance" type="Object"/>
      <property name="marginRight" scope="instance" type="Object"/>
      <property name="marginBottom" scope="instance" type="Object"/>
      <property name="paddingLeft" scope="instance" type="Object"/>
      <property name="paddingTop" scope="instance" type="Object"/>
      <property name="paddingRight" scope="instance" type="Object"/>
      <property name="paddingBottom" scope="instance" type="Object"/>
      <property name="borderLeftWidth" scope="instance" type="Object"/>
      <property name="borderTopWidth" scope="instance" type="Object"/>
      <property name="borderRightWidth" scope="instance" type="Object"/>
      <property name="borderBottomWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.common"/>
  <class type="dojox.charting.axis2d.common.createText">
    <methods>
      <method name="gfx" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
          <parameter name="align" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="fontColor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="html" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
          <parameter name="align" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="fontColor" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d"/>
  <class type="dojox.charting.plot2d.Areas" superclass="dojox.charting.plot2d.Default"/>
  <class type="dojox.charting.plot2d.Areas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="gap" scope="instance" type="Object"/>
      <property name="shadows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Object"/>
      <property name="maxBarSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="plotEvent" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="events" scope="prototype"/>
      <method name="resetEvents" scope="prototype"/>
      <method name="_calc" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="stats" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectEvents" scope="prototype">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
      <property name="_hAxis" scope="instance" type="Object"/>
      <property name="_vAxis" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="_hScaler" scope="instance" type="Object"/>
      <property name="_vScaler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="gap" scope="instance" type="Object"/>
      <property name="shadows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Object"/>
      <property name="maxBarSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
      <property name="markers" scope="instance" type="Object"/>
      <property name="shadows" scope="instance" type="Object"/>
      <property name="tension" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid" superclass="dojox.charting.Element">
    <methods>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype"/>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="_hAxis" scope="instance" type="Object"/>
      <property name="_vAxis" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="hMajorLines" scope="instance" type="Object"/>
      <property name="hMinorLines" scope="instance" type="Object"/>
      <property name="vMajorLines" scope="instance" type="Object"/>
      <property name="vMinorLines" scope="instance" type="Object"/>
      <property name="hStripes" scope="instance" type="Object"/>
      <property name="vStripes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Lines" superclass="dojox.charting.plot2d.Default"/>
  <class type="dojox.charting.plot2d.Lines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Markers" superclass="dojox.charting.plot2d.Default"/>
  <class type="dojox.charting.plot2d.Markers.opt">
    <properties>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly" superclass="dojox.charting.plot2d.Default"/>
  <class type="dojox.charting.plot2d.MarkersOnly.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie" superclass="dojox.charting.Element">
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="plotEvent" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="events" scope="prototype"/>
      <method name="resetEvents" scope="prototype"/>
      <method name="_connectEvents" scope="prototype">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continue"/>
          <return-type type="stop iteration"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="dyn" scope="instance" type="Object"/>
      <property name="run" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.defaultParams">
    <properties>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="precision" scope="instance" type="Object"/>
      <property name="labelOffset" scope="instance" type="Object"/>
      <property name="labelStyle" scope="instance" type="Object"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.optionalParams">
    <properties>
      <property name="font" scope="instance" type="Object"/>
      <property name="fontColor" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter" superclass="dojox.charting.plot2d.Default"/>
  <class type="dojox.charting.plot2d.Scatter.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas" superclass="dojox.charting.plot2d.Stacked"/>
  <class type="dojox.charting.plot2d.StackedAreas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedLines" superclass="dojox.charting.plot2d.Stacked"/>
  <class type="dojox.charting.plot2d.StackedLines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.common">
    <methods>
      <method name="makeStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentColor" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="collectSimpleStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateBarSize" scope="instance">
        <parameters>
          <parameter name="availableSize" type="Number" usage="required"/>
          <parameter name="opt" type="Object" usage="required"/>
          <parameter name="clusterSize" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="collectStackedStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="curve" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
          <parameter name="tension" type="Number|String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.common.defaultStats">
    <methods>
      <method name="collectSimpleStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateBarSize" scope="instance">
        <parameters>
          <parameter name="availableSize" type="Number" usage="required"/>
          <parameter name="opt" type="Object" usage="required"/>
          <parameter name="clusterSize" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="collectStackedStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="curve" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
          <parameter name="tension" type="Number|String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="hmin" scope="instance" type="Object"/>
      <property name="hmax" scope="instance" type="Object"/>
      <property name="vmin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d"/>
  <class type="dojox.charting.plot3d.Bars" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="depth" scope="instance" type="Object"/>
      <property name="gap" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Bars.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Base">
    <methods>
      <method name="setData" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="data" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="depth" scope="instance" type="Object"/>
      <property name="gap" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.scaler.common">
    <methods>
      <method name="findString" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
          <parameter name="text" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getNumericLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler"/>
  <class type="dojox.charting.scaler.linear">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler.primitive">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes">
    <properties>
      <property name="Adobebricks" scope="instance" type="Object"/>
      <property name="Algae" scope="instance" type="Object"/>
      <property name="Bahamation" scope="instance" type="Object"/>
      <property name="BlueDusk" scope="instance" type="Object"/>
      <property name="CubanShirts" scope="instance" type="Object"/>
      <property name="Desert" scope="instance" type="Object"/>
      <property name="Dollar" scope="instance" type="Object"/>
      <property name="Grasshopper" scope="instance" type="Object"/>
      <property name="Grasslands" scope="instance" type="Object"/>
      <property name="GreySkies" scope="instance" type="Object"/>
      <property name="IndigoNation" scope="instance" type="Object"/>
      <property name="Ireland" scope="instance" type="Object"/>
      <property name="MiamiNice" scope="instance" type="Object"/>
      <property name="Midwest" scope="instance" type="Object"/>
      <property name="Minty" scope="instance" type="Object"/>
      <property name="PurpleRain" scope="instance" type="Object"/>
      <property name="RoyalPurples" scope="instance" type="Object"/>
      <property name="SageToLime" scope="instance" type="Object"/>
      <property name="Shrooms" scope="instance" type="Object"/>
      <property name="Tufte" scope="instance" type="Object"/>
      <property name="WatersEdge" scope="instance" type="Object"/>
      <property name="Wetland" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.ET">
    <properties>
      <property name="greys" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit">
    <properties>
      <property name="blue" scope="instance" type="Object"/>
      <property name="cyan" scope="instance" type="Object"/>
      <property name="green" scope="instance" type="Object"/>
      <property name="orange" scope="instance" type="Object"/>
      <property name="purple" scope="instance" type="Object"/>
      <property name="red" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget"/>
  <class type="dojox.charting.widget.Chart2D" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <description>properly destroy the widget</description>
      </method>
      <method name="resize" scope="prototype">
        <description>resize the widget</description>
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="theme" scope="prototype" type="Object"/>
      <property name="margins" scope="prototype" type="Object"/>
      <property name="stroke" scope="prototype" type="Object"/>
      <property name="fill" scope="prototype" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="actions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Legend" superclass="dijit._Widget">
    <description>A legend for a chart. A legend contains summary labels for
	each series of data contained in the chart.
	Set the boolean horizontal attribute to false to layout legend labels vertically.
	(Line or Scatter charts (colored lines with shape symbols) )
	-o- Series1		-X- Series2		-v- Series3
	(Area/Bar/Pie charts (letters represent colors))
	[a] Series1		[b] Series2		[c] Series3</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="refresh" scope="prototype">
        <description>regenerates the legend to reflect changes to the chart</description>
      </method>
      <method name="_addLabel" scope="prototype">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeIcon" scope="prototype">
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="chartRef" scope="prototype" type="Object"/>
      <property name="horizontal" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="legendNode" scope="prototype" type="Object"/>
      <property name="legendBody" scope="prototype" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="_surfaces" scope="instance" type="Object"/>
      <property name="_tr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline" superclass="dojox.charting.widget.Chart2D">
    <methods>
      <method name="buildRendering" scope="prototype"/>
    </methods>
    <properties>
      <property name="theme" scope="prototype" type="Object"/>
      <property name="type" scope="prototype" type="Object"/>
      <property name="valueFn" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object"/>
      <property name="field" scope="prototype" type="Object"/>
      <property name="query" scope="prototype" type="Object"/>
      <property name="queryOptions" scope="prototype" type="Object"/>
      <property name="start" scope="prototype" type="Object"/>
      <property name="count" scope="prototype" type="Object"/>
      <property name="sort" scope="prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="name" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline.margins">
    <properties>
      <property name="l" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections">
    <description>A set of lists and hashes for easy use within your applications.</description>
    <properties>
      <property name="Set" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.ArrayList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="indexOf" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="reverse" scope="instance"/>
      <method name="sort" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance"/>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="delim" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree">
    <methods>
      <method name="clone" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="compareData" scope="instance">
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance"/>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="order" type="Object" usage="required"/>
          <parameter name="sep" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree.TraversalMethods">
    <properties>
      <property name="Preorder" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Dictionary">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
        </return-types>
      </method>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance"/>
      <method name="getValueList" scope="instance"/>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
      <property name="contains" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Queue">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Queue"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="dequeue" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="enqueue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance"/>
      <method name="toArray" scope="instance"/>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.SortedList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
        </return-types>
      </method>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="getKey" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="indexOfKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="indexOfValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
      <property name="contains" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Stack">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="pop" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryEntry">
    <methods>
      <method name="valueOf" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="key" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Iterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryIterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color">
    <description>Advanced color methods, including HSV, HSL, and CMYK conversion, a color generator and advanced colorspace calculations.</description>
    <methods>
      <method name="fromXYZ" scope="instance">
        <parameters>
          <parameter name="xyz" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fromCmy" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmyk" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
          <parameter name="black" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsl" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="luminosity" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsv" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="value" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="blend" scope="instance" type="Object"/>
      <property name="fromRgb" scope="instance" type="Object"/>
      <property name="fromHex" scope="instance" type="Object"/>
      <property name="fromArray" scope="instance" type="Object"/>
      <property name="fromString" scope="instance" type="Object"/>
      <property name="greyscale" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Colorspace">
    <methods>
      <method name="whitepoint" scope="instance">
        <parameters>
          <parameter name="wpName" type="String" usage="required"/>
          <parameter name="observer" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="tempToWhitepoint" scope="instance">
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="primaries" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adapt" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matrix" scope="instance">
        <parameters>
          <parameter name="to" type="String" usage="required"/>
          <parameter name="primary" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="epsilon" scope="instance">
        <parameters>
          <parameter name="useApprox" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="kappa" scope="instance">
        <parameters>
          <parameter name="useApprox" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="from" type="string" usage="required"/>
          <parameter name="to" type="string" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Color">
    <methods>
      <method name="toXYZ" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmy" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmyk" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsl" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsv" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Generator">
    <methods>
      <method name="analogous" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__AnalogousArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="monochromatic" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="triadic" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="complementary" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="splitComplementary" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorAngleArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="compound" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorAngleArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="shades" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.color.__GeneratorArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="num" scope="instance" type="Object"/>
      <property name="angleHigh" scope="instance" type="Object"/>
      <property name="angleLow" scope="instance" type="Object"/>
      <property name="high" scope="instance" type="Object"/>
      <property name="low" scope="instance" type="Object"/>
      <property name="angle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.__AnalogousArgs">
    <properties>
      <property name="base" scope="instance" type="String">
        <description>| dojox.Color
	The base color from which to derive all other colors.</description>
      </property>
      <property name="series" scope="instance" type="Number">
        <description>The number of lines to generate</description>
      </property>
      <property name="num" scope="instance" type="Number">
        <description>The number of colors to generate</description>
      </property>
      <property name="angleHigh" scope="instance" type="Number">
        <description>The high hue angle of difference from the base color, subtracted</description>
      </property>
      <property name="angleLow" scope="instance" type="Number">
        <description>The low hue angle of difference from the base color, added</description>
      </property>
      <property name="high" scope="instance" type="Float">
        <description>The high part of the range to generate tints and shades</description>
      </property>
      <property name="low" scope="instance" type="Float">
        <description>The low part of the range to generate tints and shades</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.__GeneratorArgs">
    <properties>
      <property name="base" scope="instance" type="String">
        <description>| dojox.Color
	The base color from which to derive all other colors.</description>
      </property>
      <property name="num" scope="instance" type="Number">
        <description>The number of colors to generate</description>
      </property>
      <property name="high" scope="instance" type="Float">
        <description>The high part of the range to generate tints and shades</description>
      </property>
      <property name="low" scope="instance" type="Float">
        <description>The low part of the range to generate tints and shades</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.__GeneratorAngleArgs">
    <properties>
      <property name="base" scope="instance" type="String">
        <description>| dojox.Color
	The base color from which to derive all other colors.</description>
      </property>
      <property name="num" scope="instance" type="Number">
        <description>The number of colors to generate</description>
      </property>
      <property name="angle" scope="instance" type="Number">
        <description>The angle of hue difference from the base color to use</description>
      </property>
      <property name="high" scope="instance" type="Float">
        <description>The high part of the range to generate tints and shades</description>
      </property>
      <property name="low" scope="instance" type="Float">
        <description>The low part of the range to generate tints and shades</description>
      </property>
    </properties>
  </class>
  <class type="ret">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Palette">
    <methods>
      <method name="transform" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="clone" scope="prototype">
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="base" type="String|dojox.color.Color" usage="required"/>
          <parameter name="type" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="colors" scope="instance" type="summary">
        <description>An object that represents a palette of colors.
	description
	A Palette is a representation of a set of colors.  While the standard
	number of colors contained in a palette is 5, it can really handle any
	number of colors.
	A palette is useful for the ability to transform all the colors in it
	using a simple object-based approach.  In addition, you can generate
	palettes using dojox.color.Palette.generate; these generated palettes
	are based on the palette generators at http://kuler.adobe.com.
	dojox.color.Color[]
	The actual color references in this palette.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.Palette.generators">
    <methods>
      <method name="monochromatic" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="triadic" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="complementary" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="splitComplementary" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="compound" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shades" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="analogous" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd">
    <description>A cometd client written in Dojo</description>
    <properties>
      <property name="HttpChannels" scope="instance" type="Object"/>
      <property name="connectionTypes" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="longPollTransport" scope="instance" type="Object"/>
      <property name="timestamp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.RestChannels">
    <description>Initiates the REST Channels protocol</description>
    <methods>
      <method name="absoluteUrl" scope="prototype">
        <parameters>
          <parameter name="baseUrl" type="Object" usage="required"/>
          <parameter name="relativeUrl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="prototype">
        <description>Startup the transport (connect to the &amp;quot;channels&amp;quot; resource to receive updates from the server).</description>
        <return-types>
          <return-type type="this can be called after dojo is unloaded, just do nothing in that case"/>
        </return-types>
      </method>
      <method name="_send" scope="prototype">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="prototype">
        <description>Subscribes to a channel/uri, and returns a dojo.Deferred object for the response from
	the subscription request</description>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the uri for the resource you want to monitor</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional">
            <description>See dojo.xhr
	headers:
	These are the headers to be applied to the channel subscription request
	callback:
	This will be called when a event occurs for the channel
	The callback will be called with a single argument:
		callback(message)
	where message is an object that follows the XHR API:
	status : Http status
	statusText : Http status text
	getAllResponseHeaders() : The response headers
	getResponseHeaders(headerName) : Retrieve a header by name
	responseText : The response body as text
	with the following additional Bayeux properties
	data : The response body as JSON
	channel : The channel/url of the response</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="don't process the response, the response will be received in the main channels response"/>
        </return-types>
      </method>
      <method name="publish" scope="prototype">
        <description>Publish an event.</description>
        <parameters>
          <parameter name="channel" type="Channel/resource" usage="required">
            <description>path to publish to</description>
          </parameter>
          <parameter name="data" type="data" usage="required">
            <description>to publish</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="indicate an error"/>
        </return-types>
      </method>
      <method name="onprogress" scope="prototype">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="contentType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <description>GET the initial value of the resource and subscribe to it
	See subscribe for parameter values</description>
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="receive" scope="instance-prototype">
        <description>Called when a message is received from the server</description>
        <parameters>
          <parameter name="message" type="A" usage="required">
            <description>cometd/XHR message</description>
          </parameter>
        </parameters>
      </method>
      <method name="disconnected" scope="prototype">
        <description>called when our channel gets disconnected</description>
      </method>
      <method name="unsubscribe" scope="prototype">
        <description>unsubscribes from the resource
	See subscribe for parameter values</description>
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="disconnect" scope="prototype">
        <description>disconnect from the server</description>
      </method>
    </methods>
    <properties>
      <property name="acceptType" scope="prototype" type="Object"/>
      <property name="subscriptions" scope="prototype" type="Object"/>
      <property name="subCallbacks" scope="prototype" type="Object"/>
      <property name="autoReconnectTime" scope="prototype" type="Object"/>
      <property name="sendAsJson" scope="prototype" type="Object"/>
      <property name="url" scope="prototype" type="Object"/>
      <property name="autoSubscribeRoot" scope="prototype" type="Object"/>
      <property name="connectionId" scope="instance" type="Object"/>
      <property name="lastIndex" scope="instance" type="Object"/>
      <property name="connected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Channels">
    <properties>
      <property name="startup" scope="instance" type="Object"/>
      <property name="check" scope="instance" type="Object"/>
      <property name="deliver" scope="instance" type="Object"/>
      <property name="sendMessages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection">
    <methods>
      <method name="state" scope="instance"/>
      <method name="init" scope="instance">
        <description>return: dojo.Deferred
	Initialize the cometd implementation of the Bayeux protocol</description>
        <example>
		dojox.cometd.init("/cometd");
		dojox.cometd.init("http://xdHost/cometd",{ext:{user:"fred",pwd:"secret"}});
	FIXME: if the root isn't from the same host, we should automatically
	try to select an XD-capable transport</example>
        <parameters>
          <parameter name="root" type="String" usage="required">
            <description>The URL of the cometd server. If the root is absolute, the host
	is examined to determine if xd transport is needed. Otherwise the
	same domain is assumed.</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional">
            <description>An optional object that is used as the basis of the handshake message</description>
          </parameter>
          <parameter name="bargs" type="Object" usage="optional">
            <description>An optional object of bind args mixed in with the send of the handshake</description>
          </parameter>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <description>publishes the passed message to the cometd server for delivery
	on the specified topic</description>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the destination channel for the message</description>
          </parameter>
          <parameter name="data" type="Object" usage="required">
            <description>a JSON object containing the message &amp;quot;payload&amp;quot;
	properties:
	Optional. Other meta-data to be mixed into the top-level of the
	message</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>return: dojo.Deferred
	inform the server of this client's interest in channel</description>
        <example>Simple subscribe use-case
		dojox.cometd.init("http://myserver.com:8080/cometd");
		// log out all incoming messages on /foo/bar
		dojox.cometd.subscribe("/foo/bar", console, "debug");</example>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to subscribe to</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="required">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel</description>
          </parameter>
          <parameter name="funcName" type="String" usage="required">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="unsubscribe" scope="instance">
        <description>inform the server of this client's disinterest in channel</description>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to unsubscribe from</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="optional">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel. If null then all subscribers to the channel are unsubscribed.</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Disconnect from the server.</description>
        <example>
		dojox.cometd.disconnect();</example>
      </method>
      <method name="subscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance">
        <parameters>
          <parameter name="childLocation" type="Object" usage="required"/>
          <parameter name="childDomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_backoff" scope="instance"/>
      <method name="_backon" scope="instance"/>
      <method name="_interval" scope="instance"/>
      <method name="_publishMeta" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="successful" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishInit" scope="instance">
        <description>Handle the handshake return from the server and initialize
	connection if all is OK</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendIn" scope="instance">
        <description>Handle extensions for inbound messages</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendOut" scope="instance">
        <description>Handle extensions for inbound messages</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sendMessage" scope="instance">
        <parameters>
          <parameter name="message" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="startBatch" scope="instance"/>
      <method name="endBatch" scope="instance"/>
      <method name="_onUnload" scope="instance"/>
      <method name="_connectTimeout" scope="instance">
        <description>Return the connect timeout in ms, calculated as the minimum of the advised timeout
	and the configured timeout.  Else 0 to indicate no client side timeout</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="this.unsubscribe" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="Object"/>
      <property name="_isXD" scope="instance" type="Object"/>
      <property name="_props" scope="instance" type="Object"/>
      <property name="_messageQ" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="batch" scope="instance" type="Object"/>
      <property name="_connected" scope="instance" type="Object"/>
      <property name="_handshook" scope="instance" type="Object"/>
      <property name="_backoffInterval" scope="instance" type="Object"/>
      <property name="handshakeReturn" scope="instance" type="Object"/>
      <property name="currentTransport" scope="instance" type="Object"/>
      <property name="clientId" scope="instance" type="Object"/>
      <property name="lastMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection._advice">
    <properties>
      <property name="interval" scope="instance" type="Object"/>
      <property name="reconnect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="this">
    <mixins scope="prototype">
      <mixin type="props" scope="instance"/>
    </mixins>
    <mixins scope="normal">
      <mixin type="_nlsResources" scope="instance"/>
      <mixin type="attributes || {}" scope="instance"/>
      <mixin type="args" scope="instance"/>
      <mixin type="this.constraints" scope="instance"/>
      <mixin type="params" scope="instance"/>
      <mixin type="kwArgs" scope="instance"/>
      <mixin type="keywordParameters" scope="instance"/>
      <mixin type="options" scope="instance"/>
      <mixin type="messages" scope="instance"/>
      <mixin type="inProps" scope="instance"/>
      <mixin type="dojo.mixin({}, params)" scope="instance"/>
    </mixins>
    <properties>
      <property name="DISCONNECTED" scope="instance" type="Object"/>
      <property name="CONNECTING" scope="instance" type="Object"/>
      <property name="CONNECTED" scope="instance" type="Object"/>
      <property name="DISCONNECTING" scope="instance" type="Object"/>
      <property name="prefix" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_connected" scope="instance" type="Object"/>
      <property name="_polling" scope="instance" type="Object"/>
      <property name="_handshook" scope="instance" type="Object"/>
      <property name="expectedNetworkDelay" scope="instance" type="Object"/>
      <property name="connectTimeout" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
      <property name="minimumVersion" scope="instance" type="Object"/>
      <property name="clientId" scope="instance" type="Object"/>
      <property name="messageId" scope="instance" type="Object"/>
      <property name="batch" scope="instance" type="Object"/>
      <property name="_isXD" scope="instance" type="Object"/>
      <property name="handshakeReturn" scope="instance" type="Object"/>
      <property name="currentTransport" scope="instance" type="Object"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="lastMessage" scope="instance" type="Object"/>
      <property name="_messageQ" scope="instance" type="Object"/>
      <property name="handleAs" scope="instance" type="Object"/>
      <property name="_advice" scope="instance" type="Object"/>
      <property name="_backoffInterval" scope="instance" type="Object"/>
      <property name="_backoffIncrement" scope="instance" type="Object"/>
      <property name="_backoffMax" scope="instance" type="Object"/>
      <property name="_deferredSubscribes" scope="instance" type="Object"/>
      <property name="_deferredUnsubscribes" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
      <property name="_extendInList" scope="instance" type="Object"/>
      <property name="_extendOutList" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_render" scope="instance" type="Object"/>
      <property name="_rendering" scope="instance" type="Object"/>
      <property name="_templates" scope="instance" type="Object"/>
      <property name="defaultValue" scope="instance" type="Object"/>
      <property name="_totalPages" scope="instance" type="Object"/>
      <property name="_currentPage" scope="instance" type="Object"/>
      <property name="dirClass" scope="instance" type="Object"/>
      <property name="iconNext" scope="instance" type="Object"/>
      <property name="iconPrevious" scope="instance" type="Object"/>
      <property name="required" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.callbackPollTransport">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="Object"/>
      <property name="tunnelCollapse" scope="instance" type="Object"/>
      <property name="_connect" scope="instance" type="Object"/>
      <property name="deliver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.callbackPollTransport._cometd">
    <properties>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded._cometd">
    <properties>
      <property name="_connected" scope="instance" type="Object"/>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded._cometd">
    <properties>
      <property name="_connected" scope="instance" type="Object"/>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="msg">
    <properties>
      <property name="timestamp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.timesync">
    <methods>
      <method name="getServerTime" scope="instance"/>
      <method name="getServerDate" scope="instance"/>
      <method name="setTimeout" scope="instance">
        <parameters>
          <parameter name="call" type="function" usage="required">
            <description>Summary Set a timeout function relative to server time
	the function to call when the timeout occurs
	atTimeOrTime:
	a long timestamp or a Date representing the server time at
	which the timeout should occur.</description>
          </parameter>
          <parameter name="atTimeOrDate" type="long|Date" usage="required"/>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required">
            <description>The incoming bayeux message</description>
          </parameter>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <parameters>
          <parameter name="msg" type="The" usage="required">
            <description>outgoing bayeux message</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_window" scope="instance" type="Object"/>
      <property name="_minWindow" scope="instance" type="Object"/>
      <property name="_offsets" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="samples" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data">
    <description>Additional dojo.data data stores and demos</description>
    <methods>
      <method name="_getStoreForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type=")[0]]._store;"/>
        </return-types>
      </method>
      <method name="restListener" scope="instance">
        <description>this function can be used to receive REST notifications, from Comet or from another frame</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ASYNC_MODE" scope="instance" type="Object"/>
      <property name="SYNC_MODE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore">
    <description>constructor</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()
	filter modified to permit complex queries where
	logical operators are case insensitive:
	, NOT AND OR ( ) ! &amp;amp;&amp;amp; ||
	Note:  &amp;quot;,&amp;quot; included for quoted/string legacy queries.</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <description>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</description>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <description>Internal function to determine which list of items to search over.</description>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="prototype">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.
	First, we define a couple little utility functions...</return-description>
        <return-types>
          <return-type type="examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <description>Method to add an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.
	Stub function, does nothing.  Real processing is in ItemFileWriteStore.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object "/>
          <return-type type="Object"/>
          <return-type type=" String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="prototype">
        <description>Internal function to look an item up by its identity map.</description>
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentifierAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="prototype">
        <description>Internal function to force a load of the store if it hasn't occurred yet.  This is required
	for specific functions to work properly.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="typeMap" scope="prototype" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_jsonData" scope="instance" type="Object"/>
      <property name="_queuedFetches" scope="instance" type="Object"/>
      <property name="_arrayOfAllItems" scope="instance" type="Object"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Object"/>
      <property name="_itemsByIdentity" scope="instance" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_jsonFileUrl" scope="instance" type="Object"/>
      <property name="_datatypeMap" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="Object"/>
      <property name="_itemNumPropName" scope="instance" type="Object"/>
      <property name="_rootItemPropName" scope="instance" type="Object"/>
      <property name="_reverseRefMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore" superclass="dojox.data.AndOrReadStore">
    <methods>
      <method name="_assert" scope="prototype">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="prototype"/>
      <method name="newItem" scope="prototype">
        <description>See dojo.data.api.Write.newItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="prototype">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>See dojo.data.api.Write.deleteItem()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>See dojo.data.api.Write.set()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <description>See dojo.data.api.Write.setValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>See dojo.data.api.Write.unsetAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <description>Method to add an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="prototype">
        <description>Method to remove an reference map entry for an item and attribute.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="prototype">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="prototype">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="prototype">
        <description>Generate a string that can be saved to a file.
	The result should look similar to:
	http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json</description>
      </method>
      <method name="_isEmpty" scope="prototype">
        <description>Function to determine if an array or object has no properties or values.</description>
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <description>See dojo.data.api.Write.save()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <description>See dojo.data.api.Write.revert()</description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <description>See dojo.data.api.Write.isDirty()</description>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="prototype">
        <description>See dojo.data.api.Notification.onSet()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object | array" usage="required"/>
          <parameter name="newValue" type="object | array" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="prototype">
        <description>See dojo.data.api.Notification.onNew()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <description>See dojo.data.api.Notification.onDelete()
	No need to do anything. This method is here just so that the
	client code can connect observers to it.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="Object"/>
      <property name="_saveInProgress" scope="instance" type="Object"/>
      <property name="_pending" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AtomReadStore">
    <description>Constructor for the AtomRead store.</description>
    <methods>
      <method name="getValue" scope="prototype">
        <description>Return an attribute value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getValues" scope="prototype">
        <description>Return an attribute value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
        </parameters>
        <return-description>An array of values for the attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>Return an array of attribute names</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>Check whether an element has the attribute</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>must be created by the AtomReadStore instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>An attribute of an Atom Entry item.</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <description>Check whether the attribute values contain the value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>Check whether the object is an item (XML element)
	item:
	An object to check</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>Check whether the object is an item (XML element) and loaded
	item:
	An object to check</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>Load an item (XML element)</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.  See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>Return supported data APIs</description>
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeedValue" scope="prototype">
        <description>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</description>
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="prototype">
        <description>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</description>
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initItem" scope="prototype">
        <description>Initializes an item before it can be parsed.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Retrieves the items from the Atom XML document.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="prototype">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <description>Parses the document in a first pass</description>
        <parameters>
          <parameter name="document" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="prototype">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>url to a service or an XML document that represents the store</description>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <description>boolean indicate to add a query string to the service URL</description>
      </property>
      <property name="unescapeHTML" scope="instance-prototype" type="A">
        <description>boolean to specify whether or not to unescape HTML text</description>
      </property>
      <property name="_feedMetaData" scope="instance" type="Object"/>
      <property name="_items" scope="instance" type="Object"/>
      <property name="rewriteUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ClientFilter">
    <description>This is an abstract class that data stores can extend to add updateable result set functionality
	as well as client side querying capabilities. This enables
	widgets to be aware of how active results change in response to the modifications/notifications.</description>
    <example>to make a live-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.LiveResultSets], // subclass LiveResultSets if available
			{}
		);</example>
    <methods>
      <method name="updateResultSet" scope="prototype">
        <description>Attempts to update the given result set based on previous notifications</description>
        <parameters>
          <parameter name="resultSet" type="Array" usage="required">
            <description>The result set array that should be updated</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>This object follows the same meaning as the keywordArgs passed to a dojo.data.api.Read.fetch.</description>
          </parameter>
        </parameters>
      </method>
      <method name="querySuperSet" scope="prototype">
        <description>Determines whether the provided arguments are super/sub sets of each other</description>
        <parameters>
          <parameter name="argsSuper" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
          <parameter name="argsSub" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="cachingFetch" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="prototype">
        <description>Returns whether the provide fetch arguments can be used to update an existing list</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="prototype">
        <description>Performs a query on the client side and returns the results as an array</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
          <parameter name="baseResults" type="Array" usage="required">
            <description>This provides the result set to start with for client side querying</description>
          </parameter>
        </parameters>
      </method>
      <method name="matchesQuery" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="prototype">
        <description>returns a comparator function for the given sort order array</description>
        <parameters>
          <parameter name="sort" type="See" usage="required">
            <description>dojox.data.api.Read.fetch</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="keep the order unchanged"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="serverVersion" scope="prototype" type="Object"/>
      <property name="onSet" scope="instance" type="Object"/>
      <property name="onNew" scope="instance" type="Object"/>
      <property name="onDelete" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Object"/>
      <property name="_fetchCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="lrs">
    <properties>
      <property name="onUpdate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type=".clientQuery || {}">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CouchDBRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="save" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>This only differs from JsonRestStore in that it, will put the query string the query part of the URL and it handles start and count</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="couchServerUrl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.CssClassStore" superclass="dojox.data.CssRuleStore">
    <description>Basic store to display CSS information.</description>
    <methods>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="prototype">
        <description>Handles the creation of an item based on the passed rule.  In this store, this implies
	parsing out all available class names.</description>
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="prototype">
        <description>Handles the return from a fetching action.  Delegates requests to act on the resulting
	item set to eitehr the _handleFetchReturn or _handleFetchByIdentityReturn depending on
	where the request originated.</description>
      </method>
      <method name="_handleFetchByIdentityReturn" scope="prototype">
        <description>Handles a fetchByIdentity request by finding the correct item.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentityAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="request" type="request" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_labelAttribute" scope="prototype" type="Object"/>
      <property name="_idAttribute" scope="prototype" type="Object"/>
      <property name="_cName" scope="prototype" type="Object"/>
      <property name="_pending" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CssRuleStore">
    <description>Basic store to display CSS information.</description>
    <methods>
      <method name="setContext" scope="prototype">
        <parameters>
          <parameter name="context" type="Array" usage="required">
            <description>Sets the context in which queries are executed
	Array - Array of CSS string paths to execute queries within</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>See dojo.data.api.Read.fetch()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="prototype">
        <description>Populates the _allItems object with unique class names</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="prototype">
        <description>Handles the creation of an item based on the passed rule.  In this store, this implies
	parsing out all available class names.</description>
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="prototype">
        <description>Handles the return from a fetching action.  Delegates requests to act on the resulting
	item set to eitehr the _handleFetchReturn or _handleFetchByIdentityReturn depending on
	where the request originated.</description>
      </method>
      <method name="_handleFetchReturn" scope="prototype">
        <description>Handles a fetchByIdentity request by finding the correct items.</description>
        <parameters>
          <parameter name="request" type="Request" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()
	Clears out the cache and allItems objects, meaning all future fetches will requery
	the stylesheets.</description>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_storeRef" scope="prototype" type="Object"/>
      <property name="_labelAttribute" scope="prototype" type="Object"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_browserMap" scope="prototype" type="Object"/>
      <property name="_cName" scope="prototype" type="Object"/>
      <property name="context" scope="instance" type="Object"/>
      <property name="_pending" scope="instance" type="Object"/>
      <property name="_allItems" scope="instance" type="Object"/>
      <property name="_waiting" scope="instance" type="Object"/>
      <property name="gatherHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CsvStore">
    <description>initializer</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="item || String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()
	Note that for the CsvStore, an empty string value is the same as no value,
	so the defaultValue would be returned instead of an empty string.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()
	CSV syntax does not support multi-valued attributes, so this is just a
	wrapper function for getValue().</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()
	The hasAttribute test is true if attribute has an index number within the item's array length
	AND if the item has a value for that attribute. Note that for the CsvStore, an
	empty string value is the same as no value.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()
	The CsvStore always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="_getArrayOfArraysFromCsvFileContents" scope="prototype">
        <parameters>
          <parameter name="csvFileContents" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_splitLines" scope="prototype">
        <description>Function to split the CSV file contents into separate lines.
	Since line breaks can occur inside quotes, a Regexp didn't
	work as well.  A quick passover parse should be just as efficient.</description>
        <parameters>
          <parameter name="csvContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processData" scope="prototype">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_createItemFromIdentity" scope="prototype">
        <parameters>
          <parameter name="identity" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentifierAttributes()
	Identity isn't a public attribute in the item, it's the row position index.
	So, return null.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <description>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="Object"/>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_csvData" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance" type="Object"/>
      <property name="_dataArray" scope="instance" type="Object"/>
      <property name="_arrayOfAllItems" scope="instance" type="Object"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_queuedFetches" scope="instance" type="Object"/>
      <property name="_attributeIndexes" scope="instance" type="Object"/>
      <property name="_storeProp" scope="instance" type="Object"/>
      <property name="_idProp" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FileStore">
    <description>A simple store that provides a datastore interface to a filesystem.</description>
    <example>options="expand,dirsOnly,showHiddenFiles"</example>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>Fetch  items that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object
	fetchHandler:
	A function to call for fetched items
	errorHandler:
	A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResult" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemArray" scope="prototype">
        <description>Internal function for processing an array of items for return.</description>
        <parameters>
          <parameter name="itemArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="prototype">
        <description>Internal function for processing an item returned from the store.
	It sets up the store ref as well as sets up the attributes necessary
	to invoke a lazy load on a child, if there are any.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>URL of the service which provides the file store serverside implementation.</description>
      </property>
      <property name="_storeRef" scope="prototype" type="Object"/>
      <property name="label" scope="instance-prototype" type="The">
        <description>attribute of the file to use as the huma-readable text.  Default is 'name'.
	The purpose of this store is to represent a file as a datastore item.  The
	datastore item by default has the following attributes that can be examined on it.
	directory:	Boolean indicating if the file item represents a directory.
	name:	The filename with no path informatiom.
	path:	The file complete file path including name, relative to the location the
	file service scans from
	size:	The size of the file, in bytes.
	parentDir:	The parent directory path.
	children:	Any child files contained by a directory file item.
	Note that the store's server call pattern is RESTlike.
	The store also supports the passing of configurable options to the back end service, such as
	expanding all child files (no lazy load), displaying hidden files, displaying only directories, and so on.
	These are defined through a comma-separated list in declarative, or through setting the options array in programmatic.</description>
      </property>
      <property name="_identifier" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
      <property name="pathSeparator" scope="instance-prototype" type="Object"/>
      <property name="options" scope="instance-prototype" type="Object"/>
      <property name="pathAsQueryParam" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore" superclass="dojox.data.FlickrStore">
    <description>Initializer for the FlickrRestStore store.</description>
    <methods>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch flickr items that match to a query</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
          <parameter name="fetchHandler" type="Function" usage="required">
            <description>A function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="Function" usage="required">
            <description>A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="www.flickr.com/photos/&quot; + item.owner + &quot;/&quot; + item.id ]; // String"/>
        </return-types>
      </method>
      <method name="_processFlickrData" scope="prototype">
        <description>Processes the raw data from Flickr and updates the internal cache.</description>
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>Data returned from Flickr</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>The original dojo.data.Request object passed in by the user.
	If the data contains an 'item' object, it has not come from the REST
	services, so process it using the FlickrStore.</description>
          </parameter>
          <parameter name="cacheKey" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_checkPrevRanges" scope="prototype">
        <parameters>
          <parameter name="primaryKey" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <description>A unique identifier for this store.</description>
      </property>
      <property name="_requestCount" scope="prototype" type="Integer">
        <description>A counter for the number of requests made. This is used to define
	the callback function that Flickr will use.</description>
      </property>
      <property name="_flickrRestUrl" scope="prototype" type="String">
        <description>The URL to the Flickr REST services.</description>
      </property>
      <property name="_apikey" scope="instance-prototype" type="String">
        <description>The users API key to be used when accessing Flickr REST services.</description>
      </property>
      <property name="_storeRef" scope="prototype" type="String">
        <description>A key used to mark an data store item as belonging to this store.</description>
      </property>
      <property name="_cache" scope="instance-prototype" type="Array">
        <description>An Array of all previously downloaded picture info.</description>
      </property>
      <property name="_prevRequests" scope="instance-prototype" type="Object">
        <description>A HashMap used to record the signature of a request to prevent duplicate
	request being made.</description>
      </property>
      <property name="_handlers" scope="instance-prototype" type="Object">
        <description>A HashMap used to record the handlers registered for a single remote request.  Multiple
	requests may be made for the same information before the first request has finished.
	Each element of this Object is an array of handlers to call back when the request finishes.
	This prevents multiple requests being made for the same information.</description>
      </property>
      <property name="label" scope="instance" type="Object"/>
      <property name="_prevRequestRanges" scope="instance" type="Object"/>
      <property name="_maxPhotosPerUser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore._sortAttributes">
    <description>A quick lookup of valid attribute names in a sort query.</description>
    <properties>
      <property name="date-posted" scope="instance" type="Object"/>
      <property name="date-taken" scope="instance" type="Object"/>
      <property name="interestingness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrStore">
    <description>Initializer for the FlickrStore store.</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch flickr items that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processFlickrData" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="prototype">
        <description>Utility function to un-escape XML special characters in an
	HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>. The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped)
	characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="_storeRef" scope="prototype" type="Object"/>
      <property name="label" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving RSS and Atom feeds from Google. The
	feeds can come from any source, which is specified in the &amp;quot;url&amp;quot;
	parameter of the query passed to the &amp;quot;fetch&amp;quot; function.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The feed entry title.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;link - The URL for the HTML version of the feed entry.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - The full content of the blog post, in HTML format&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;summary - A snippet of information about the feed entry, in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;published - The string date on which the entry was published.
	You can parse the date with new Date(store.getValue(item, &amp;quot;published&amp;quot;)&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;categories - An array of string tags for the entry&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: url - The URL of the feed to retrieve</description>
    <methods>
      <method name="_processItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_googleUrl" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
      <property name="_queryAttr" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore">
    <description>Initializer for the GoogleSearchStore store.</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_format" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="base implementation does not format any items"/>
        </return-types>
      </method>
      <method name="fetch" scope="prototype">
        <description>Fetch Google search items that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object
	fetchHandler:
	A function to call for fetched items
	errorHandler:
	A function to call on error</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="an error occurred, do not return anything else."/>
        </return-types>
      </method>
      <method name="_processItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <description>A unique identifier for this store.</description>
      </property>
      <property name="_requestCount" scope="prototype" type="Integer">
        <description>A counter for the number of requests made. This is used to define
	the callback function that GoogleSearchStore will use.</description>
      </property>
      <property name="_googleUrl" scope="prototype" type="String">
        <description>The URL to Googles search web service.</description>
      </property>
      <property name="_storeRef" scope="prototype" type="String">
        <description>The internal reference added to each item pointing at the store which owns it.</description>
      </property>
      <property name="_attributes" scope="prototype" type="Array">
        <description>The list of attributes that this store supports</description>
      </property>
      <property name="label" scope="instance-prototype" type="String">
        <description>The default attribute which acts as a label for each item.</description>
      </property>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_queryAttr" scope="prototype" type="Object"/>
      <property name="_key" scope="instance" type="Object"/>
      <property name="_lang" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleWebSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The page title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The page title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the page&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;visibleUrl - The URL with no protocol specified.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;cacheUrl - The URL to the copy of the document cached by Google&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
  </class>
  <class type="dojox.data.GoogleBlogSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The blog post title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The  blog post title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;blogUrl - The URL for the blog&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;postUrl - The URL for the a single blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;visibleUrl - The URL with no protocol specified.
	&amp;lt;li&amp;gt;cacheUrl - The URL to the copy of the document cached by Google
	&amp;lt;li&amp;gt;author - The author of the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publishedDate - The published date, in RFC-822 format&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The blog post title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The  blog post title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;lat - The latitude.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;lng - The longtitude.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;streetAddress - The street address&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;city - The city&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;region - The region&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;country - The country&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;phoneNumbers - Phone numbers associated with this address. Can be one or more.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;ddUrl - A URL that can be used to provide driving directions from the center of the search results to this search results&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;ddUrlToHere - A URL that can be used to provide driving directions from this search result to a user specified location&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;staticMapUrl - The published date, in RFC-822 format&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleVideoSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The blog post title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The  blog post title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;published - The published date, in RFC-822 format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publisher - The name of the publisher.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;duration - The approximate duration, in seconds, of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbWidth - The width in pixels of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbHeight - The height in pixels of the video&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbUrl - The URL to a thumbnail representation of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;playUrl - If present, supplies the url of the flash version of the video that can be played inline on your page. To play this video simply create and &amp;lt;embed&amp;gt; element on your page using this value as the src attribute and using application/x-shockwave-flash as the type attribute. If you want the video to play right away, make sure to append &amp;amp;autoPlay=true to the url..&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleNewsSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The news story title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The news story title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the news story&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publisher - The name of the publisher&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;clusterUrl - A URL pointing to a page listing related storied.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;location - The location of the news story.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publishedDate - The date of publication, in RFC-822 format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;relatedStories - An optional array of objects specifying related stories.
	Each object has the following subset of properties:
	&amp;quot;title&amp;quot;, &amp;quot;titleNoFormatting&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;unescapedUrl&amp;quot;, &amp;quot;publisher&amp;quot;, &amp;quot;location&amp;quot;, &amp;quot;publishedDate&amp;quot;.
	&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleBookSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The book title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The book title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;authors - An array of authors&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;bookId - An identifier for the book, usually an ISBN.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;pageCount - The number of pages in the book.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publishedYear - The year of publication.&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleImageSearchStore" superclass="dojox.data.GoogleSearchStore">
    <description>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The image title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The image title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the image&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the image, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbUrl - The URL for the image thumbnail&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;visibleUrl - A shortened version of the URL associated with the result, stripped of a protocol and path&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;originalContextUrl - The URL of the page containing the image.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;width - The width of the image in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;height - The height of the image in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbWidth - The width of the image thumbnail in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbHeight - The height of the image thumbnail in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the image, in HTML format&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;contentNoFormatting - A snippet of information about the image, in plain text&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</description>
    <properties>
      <property name="_type" scope="prototype" type="Object"/>
      <property name="_attributes" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlStore">
    <description>Initializer for the HTML table store.</description>
    <methods>
      <method name="_indexItems" scope="prototype"/>
      <method name="_getHeadings" scope="prototype">
        <description>Function to load the attribute names from the table header so that the
	attributes (cells in a row), can have a reasonable name.
	For list items, returns single implicit heading, [&amp;quot;name&amp;quot;]</description>
      </method>
      <method name="_getAllItems" scope="prototype">
        <description>Function to return all rows in the table as an array of items.</description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object "/>
          <return-type type="Object"/>
          <return-type type=" int "/>
          <return-type type=" Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="return Value for lists"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch items (XML elements) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_finishFetchItems" scope="prototype">
        <description>Internal function for processing the passed in request and locating the requested items.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()
	nothing to do here!</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentityAttributes()
	Identity isn't taken from a public attribute.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>url of the remote page to load</description>
      </property>
      <property name="dataId" scope="instance-prototype" type="The">
        <description>id of the table element in the remote page</description>
      </property>
      <property name="_rootNode" scope="instance" type="Object"/>
      <property name="_headings" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlTableStore">
    <methods>
      <method name="_getHeadings" scope="prototype">
        <description>Function to load the attribute names from the table header so that the
	attributes (cells in a row), can have a reasonable name.</description>
      </method>
      <method name="_getAllItems" scope="prototype">
        <description>Function to return all rows in the table as an array of items.</description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object "/>
          <return-type type="Object"/>
          <return-type type=" int "/>
          <return-type type=" Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch items (XML elements) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_finishFetchItems" scope="prototype">
        <description>Internal function for processing the passed in request and locating the requested items.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()
	nothing to do here!</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentityAttributes()
	Identity isn't taken from a public attribute.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="Object"/>
      <property name="tableId" scope="instance-prototype" type="Object"/>
      <property name="_headings" scope="instance" type="Object"/>
      <property name="_rootNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore" superclass="dojox.data.ServiceStore">
    <description>JsonRestStore is a Dojo Data store interface to JSON HTTP/REST web
	storage services that support read and write through GET, PUT, POST, and DELETE.</description>
    <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
    <methods>
      <method name="newItem" scope="prototype">
        <description>adds a new item to the store at the specified point.
	Takes two parameters, data, and options.</description>
        <parameters>
          <parameter name="data" type="object" usage="required">
            <description>*/
	The data to be added in as an item.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>deletes item any references to that item from the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="changing" scope="prototype">
        <description>adds an item to the list of dirty items.  This item
	contains a reference to the item itself as well as a
	cloned and trimmed version of old item for use with
	revert.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>sets 'attribute' on 'item' to 'value'</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="prototype">
        <description>sets 'attribute' on 'item' to 'value' value
	must be an array.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>unsets 'attribute' on 'item'</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <description>Saves the dirty data using REST Ajax methods. See dojo.data.api.Write for API.
	kwArgs.global:
	This will cause the save to commit the dirty data for all
	JsonRestStores as a single transaction.</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype"/>
      <method name="isDirty" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>Checks to see if a passed 'item'
	is really belongs to this JsonRestStore.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/
	attribute: /* string */</description>
          </parameter>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="prototype">
        <description>Gets the constructor for objects from this store</description>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="prototype"/>
      <method name="onNew" scope="prototype"/>
      <method name="onDelete" scope="prototype"/>
      <method name="getFeatures" scope="prototype">
        <description>return the store feature set</description>
      </method>
    </methods>
    <properties>
      <property name="target" scope="prototype" type="Object"/>
      <property name="serverVersion" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="Object"/>
      <property name="_constructor" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.service">
    <properties>
      <property name="_store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.schema">
    <properties>
      <property name="_idAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.KeyValueStore">
    <description>constructor</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()
	Key/Value syntax does not support multi-valued attributes, so this is just a
	wrapper function for getValue().</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()
	The KeyValueStore always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <description>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</description>
      </method>
      <method name="_processData" scope="prototype">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="prototype">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentifierAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_keyValueString" scope="instance" type="Object"/>
      <property name="_keyValueVar" scope="instance" type="Object"/>
      <property name="_queuedFetches" scope="instance" type="Object"/>
      <property name="_arrayOfAllItems" scope="instance" type="Object"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_keyAttribute" scope="instance" type="Object"/>
      <property name="_valueAttribute" scope="instance" type="Object"/>
      <property name="_storeProp" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpmlStore">
    <description>constructor</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="item || String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeChildNodesThatAreNotElementNodes" scope="prototype">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="recursive" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_processRawXmlTree" scope="prototype">
        <parameters>
          <parameter name="rawXmlTree" type="xmlDoc" usage="required"/>
        </parameters>
      </method>
      <method name="_checkChildNodes" scope="prototype">
        <description>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The child node to walk.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <description>Internal function to determine which list of items to search over.</description>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValues()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <description>Internal function for looking at the values contained by the item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()
	OpmlStore loads every item, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>See dojo.data.util.simpleFetch.fetch()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentifierAttributes()
	Identity isn't a public attribute in the item, it's the node count.
	So, return null.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <description>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</description>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="url" scope="instance-prototype" type="Object"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_xmlData" scope="instance" type="Object"/>
      <property name="_metadataNodes" scope="instance" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_opmlData" scope="instance" type="Object"/>
      <property name="_queuedFetches" scope="instance" type="Object"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Object"/>
      <property name="_arrayOfAllItems" scope="instance" type="Object"/>
      <property name="_identityMap" scope="instance" type="Object"/>
      <property name="_identCount" scope="instance" type="Object"/>
      <property name="_idProp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.PersevereStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="_toJsonQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="prototype"/>
      <method name="matchesQuery" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="prototype">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="querySuperSet" scope="prototype">
        <parameters>
          <parameter name="argsSuper" type="Object" usage="required"/>
          <parameter name="argsSub" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="instance">
        <description>Creates Dojo data stores for all the table/classes on a Persevere server</description>
        <parameters>
          <parameter name="path" type="String" usage="optional">
            <description>URL of the Persevere server's root, this normally just &amp;quot;/&amp;quot;
	which is the default value if the target is not provided
	callback:
	Allows the operation to happen asynchronously
	return:
	A map/object of datastores. The name of each property is a the name of a store,
	and the value is the actual data store object.</description>
          </parameter>
          <parameter name="sync" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="addProxy" scope="instance">
        <description>Invokes the XHR proxy plugin. Call this if you will be using x-site data.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.json.ref">
    <methods>
      <method name="resolveJson" scope="instance">
        <description>Indexes and resolves references in the JSON object.</description>
        <parameters>
          <parameter name="root" type="Object" usage="required">
            <description>The root object of the object graph to be processed</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>with additional arguments:
	The *index* parameter.
	This is the index object (map) to use to store an index of all the objects.
	If you are using inter-message referencing, you must provide the same object for each call.
	The *defaultId* parameter.
	This is the default id to use for the root object (if it doesn't define it's own id)
	The *idPrefix* parameter.
	This the prefix to use for the ids as they enter the index. This allows multiple tables
	to use ids (that might otherwise collide) that enter the same global index.
	idPrefix should be in the form &amp;quot;/Service/&amp;quot;.  For example,
	if the idPrefix is &amp;quot;/Table/&amp;quot;, and object is encountered {id:&amp;quot;4&amp;quot;,...}, this would go in the
	index as &amp;quot;/Table/4&amp;quot;.
	The *idAttribute* parameter.
	This indicates what property is the identity property. This defaults to &amp;quot;id&amp;quot;
	The *assignAbsoluteIds* parameter.
	This indicates that the resolveJson should assign absolute ids (__id) as the objects are being parsed.
	The *schemas* parameter
	This provides a map of schemas, from which prototypes can be retrieved
	The *loader* parameter
	This is a function that is called added to the reference objects that can't be resolved (lazy objects)
	return:
	An object, the result of the processing</description>
          </parameter>
        </parameters>
      </method>
      <method name="fromJson" scope="instance">
        <description>evaluates the passed string-form of a JSON object.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a string literal of a JSON item, for instance:
	'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>See resolveJson
	return:
	An object, the result of the evaluation</description>
          </parameter>
        </parameters>
      </method>
      <method name="toJson" scope="instance">
        <description>Create a JSON serialization of an object.
	This has support for referencing, including circular references, duplicate references, and out-of-message references
	id and path-based referencing is supported as well and is based on http://www.json.com/2007/10/19/json-referencing-proposal-and-library/.</description>
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <description>an object to be serialized.</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <description>if true, we indent objects and arrays to make the output prettier.
	The variable dojo.toJsonIndentStr is used as the indent string
	-- to use something other than the default (tab),
	change that variable before calling dojo.toJson().</description>
          </parameter>
          <parameter name="idPrefix" type="Object" usage="optional">
            <description>The prefix that has been used for the absolute ids
	return:
	a String representing the serialized version of the passed object.</description>
          </parameter>
          <parameter name="indexSubObjects" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="use the default serializer for primitives"/>
        </return-types>
      </method>
      <method name="_addProp" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_useRefs" scope="instance" type="Object"/>
      <property name="serializeFunctions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.PicasaStore">
    <description>Initializer for the PicasaStore store.</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch picasa items that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processPicasaData" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="prototype">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String." usage="required">
            <description>The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).
	TODO: Check to see if theres already compatible escape() in dojo.string or dojo.html</return-description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="_picasaUrl" scope="prototype" type="Object"/>
      <property name="_storeRef" scope="prototype" type="Object"/>
      <property name="label" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.QueryReadStore">
    <description>This class provides a store that is mainly intended to be used
	for loading data dynamically from the server, used i.e. for
	retreiving chunks of data from huge data stores on the server (by server-side filtering!).
	Upon calling the fetch() method of this store the data are requested from
	the server if they are not yet loaded for paging (or cached).
	For example used for a combobox which works on lots of data. It
	can be used to retreive the data partially upon entering the
	letters &amp;quot;ac&amp;quot; it returns only items like &amp;quot;action&amp;quot;, &amp;quot;acting&amp;quot;, etc.
	note:
	The field name &amp;quot;id&amp;quot; in a query is reserved for looking up data
	by id. This is necessary as before the first fetch, the store
	has no way of knowing which field the server will declare as
	identifier.</description>
    <example>
		// The parameter "query" contains the data that are sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
		// Since "serverQuery" is given, it overrules and those data are
		// sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
		&lt;div dojoType="dojox.data.QueryReadStore"
			jsId="store2"
			url="../tests/stores/QueryReadStore.php"
			requestMethod="post"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.grid.data.DojoData"
			jsId="model2"
			store="store2"
			sortFields="[{attribute: 'name', descending: true}]"
			rowsPerPage="30"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.Grid" id="grid2"
			model="model2"
			structure="gridLayout"
			style="height:300px; width:800px;"&gt;&lt;/div&gt;
	todo:
	- there is a bug in the paging, when i set start:2, count:5 after an initial fetch() and doClientPaging:true
	it returns 6 elemetns, though count=5, try it in QueryReadStore.html
	- add optional caching
	- when the first query searched for "a" and the next for a subset of
	the first, i.e. "ab" then we actually dont need a server request, if
	we have client paging, we just need to filter the items we already have
	that might also be tooo much logic</example>
    <methods>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttribute()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype"/>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_xhrFetchHandler" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>The request contains the data as defined in the Read-API.
	Additionally there is following keyword &amp;quot;serverQuery&amp;quot;.
	The *serverQuery* parameter, optional.
	This parameter contains the data that will be sent to the server.
	If this parameter is not given the parameter &amp;quot;query&amp;quot;'s
	data are sent to the server. This is done for some reasons:
	- to specify explicitly which data are sent to the server, they
	might also be a mix of what is contained in &amp;quot;query&amp;quot;, &amp;quot;queryOptions&amp;quot;
	and the paging parameters &amp;quot;start&amp;quot; and &amp;quot;count&amp;quot; or may be even
	completely different things.
	- don't modify the request.query data, so the interface using this
	store can rely on unmodified data, as the combobox dijit currently
	does it, it compares if the query has changed
	- request.query is required by the Read-API
	I.e. the following examples might be sent via GET:
	fetch({query:{name:&amp;quot;abc&amp;quot;}, queryOptions:{ignoreCase:true}})
	the URL will become:   /url.php?name=abc
	fetch({serverQuery:{q:&amp;quot;abc&amp;quot;, c:true}, query:{name:&amp;quot;abc&amp;quot;}, queryOptions:{ignoreCase:true}})
	the URL will become:   /url.php?q=abc&amp;amp;c=true
	// The serverQuery-parameter has overruled the query-parameter
	// but the query parameter stays untouched, but is not sent to the server!
	// The serverQuery contains more data than the query, so they might differ!</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_filterResponse" scope="prototype">
        <description>If the data from servers needs to be processed before it can be processed by this
	store, then this function should be re-implemented in subclass. This default
	implementation just return the data unchanged.</description>
        <parameters>
          <parameter name="data" type="The" usage="required">
            <description>data received from server</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <description>It throws an error if item is not valid, so you can call it in every method that needs to
	throw an error when item is invalid.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.fetchItemByIdentity()
	See if we have already loaded the item with that id
	In case there hasn't been a fetch yet, _itemsByIdentity is null
	and thus a fetch will be triggered below.</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentity()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>See dojo.data.api.Identity.getIdentityAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="prototype" type="Object"/>
      <property name="requestMethod" scope="prototype" type="Object"/>
      <property name="_className" scope="prototype" type="Object"/>
      <property name="_items" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="instance-prototype" type="Object"/>
      <property name="fetch" scope="prototype" type="Object"/>
      <property name="_itemsByIdentity" scope="instance" type="Object"/>
      <property name="_identifier" scope="instance" type="Object"/>
      <property name="_numRows" scope="instance" type="Object"/>
      <property name="lastRequestHash" scope="instance" type="Object"/>
      <property name="_lastServerQuery" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.S3Store" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.ServiceStore" superclass="dojox.data.ClientFilter">
    <description>ServiceStore constructor, instantiate a new ServiceStore
	A ServiceStore can be configured from a JSON Schema. Queries are just
	passed through to the underlying services</description>
    <methods>
      <method name="getSchema" scope="prototype"/>
      <method name="getValue" scope="prototype">
        <description>Gets the value of an item's 'property'</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>The item to get the value from</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>property to look up value for</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>the default value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return the plain value since it was found;"/>
          <return-type type="we do, so we can return it"/>
          <return-type type="not in item -&gt; return default value"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>Gets the value of an item's 'property' and returns
	it.  If this value is an array it is just returned,
	if not, the value is added to an array and that is returned.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="property" type="string" usage="required">
            <description>*/
	property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>Gets the available attributes of an item's 'property' and returns
	it as an array.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>Checks to see if item has attribute</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>Checks to see if 'item' has 'value' at 'attribute'</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>Checks to see if the argument is an item</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/
	attribute: /* string */
	we have no way of determining if it belongs, we just have object returned from
	service queries</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>Checks to see if the item is loaded.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>Loads an item that has not been loaded yet.
	If you access a value directly through property access, you can use this to load
	a lazy (Deferred) value.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="in synchronous mode this can allow loadItem to return the value"/>
        </return-types>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>See dojo.data.api.Read.fetch
	The *queryOptions.cache* parameter
	If true, indicates that the query result should be cached for future use. This is only available
	if dojox.data.ClientFilter has been loaded before the ServiceStore
	The *syncMode* parameter
	Indicates that the call should be fetch synchronously if possible (this is not always possible)
	The *clientFetch* parameter
	This is a fetch keyword argument for explicitly doing client side filtering, querying, and paging</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>return the store feature set</description>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>returns an array of attributes that are used to create the label of an item</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>returns the attributes which are used to make up the
	identity of an item.  Basically returns this.idAttribute</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>fetch an item by its identity, by looking in our index of what we have loaded</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="schema" scope="prototype" type="Object"/>
      <property name="idAttribute" scope="instance-prototype" type="Object"/>
      <property name="syncMode" scope="prototype" type="Object"/>
      <property name="loadLazyValues" scope="prototype" type="Object"/>
      <property name="_currentId" scope="prototype" type="Object"/>
      <property name="byId" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="labelAttribute" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore">
    <description>Initialize a SnapLogicStore object.</description>
    <methods>
      <method name="_assertIsItem" scope="prototype">
        <description>This function tests whether the item passed in is indeed an item in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <description>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>See dojo.data.api.Read.getFeatures()</description>
      </method>
      <method name="getValue" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>See dojo.data.api.Read.hasAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>See dojo.data.api.Read.isItemLoaded()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>See dojo.data.api.Read.loadItem()</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>See dojo.data.api.Read.containsValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>See dojo.data.api.Read.getValue()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>See dojo.data.api.Read.isItem()</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchHandler" scope="prototype">
        <description>Process data retrieved via fetch and send it back to requester.
	response:
	The data returend from the I/O transport. In the normal case, it will be an array of result rows
	from the pipeline. In the special case for record count optimization, response will be an array
	with a single element containing the total pipeline result row count. See fetch() for details
	on this optimization.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_partHandler" scope="prototype">
        <description>Handle the individual replies for both data and length requests.</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>The request/handle object used with the original fetch() call.</description>
          </parameter>
          <parameter name="part" type="String" usage="required">
            <description>A value indicating which request this handler call is for (this.Parts).</description>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <description>Response received from the underlying IO transport.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.close() for generic interface.
	In addition to the standard Read API fetch support, this store supports an optimization for
	for retrieving the total count of records in the Pipeline without retrieving the data. To
	use this optimization, simply provide an onBegin handler without an onItem or onComplete handler.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="A">
        <description>URL to the SnapLogic pipeline's output routed through PipeToHttp. Typically, this
	will look like &amp;quot;http://&amp;lt;server-host&amp;gt;:&amp;lt;port&amp;gt;/pipe/&amp;lt;pipeline-url&amp;gt;/&amp;lt;pipeline-output-view&amp;gt;&amp;quot;.
	parameters:
	An object whose properties define parameters to the pipeline. The values of these
	properties will be sent to the pipeline as parameters when it run.</description>
      </property>
      <property name="_parameters" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore.Parts">
    <properties>
      <property name="DATA" scope="instance" type="Object"/>
      <property name="COUNT" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.WikipediaStore" superclass="dojox.data.ServiceStore">
    <description>Initializer for the Wikipedia data store interface.</description>
    <example>
		var store = new dojox.data.WikipediaStore();
		store.fetch({
			query: {title:"Dojo Toolkit"},
			onItem: function(item){
				dojo.byId("somediv").innerHTML = item.text["*"];
			}
		});</example>
    <methods>
      <method name="fetch" scope="prototype">
        <description>Fetch a page or some partially-loaded search results from
	Wikipedia. Note that there isn't a way to sort data coming
	in from the API, so we just ignore the *sort* parameter.</description>
        <example>Loading a page:
		store.fetch({
			query: {title:"Dojo Toolkit"},
			// define your handlers here
		});</example>
        <parameters>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.XmlStore">
    <description>Constructor for the XML store.</description>
    <methods>
      <method name="getValue" scope="prototype">
        <description>Return an attribute value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <description>Return an array of attribute values</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A tag name of child elements, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute values found, otherwise an empty array</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>Return an array of attribute names</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>Check whether an element has the attribute</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <description>Check whether the attribute values contain the value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute || attribute-name-string" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <description>Check whether the object is an item (XML element)
	item:
	An object to check</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>Check whether the object is an item (XML element) and loaded
	item:
	An object to check</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <description>Load an item (XML element)</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.  See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>Return supported data APIs</description>
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <description>See dojo.data.api.Read.getLabel()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>See dojo.data.api.Read.getLabelAttributes()</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <description>Fetch items (XML elements) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="prototype">
        <description>Generate a URL for fetch</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>A fetch URL</return-description>
      </method>
      <method name="_getItems" scope="prototype">
        <description>Fetch items (XML elements) in an XML document based on a request</description>
        <parameters>
          <parameter name="document" type="An" usage="required">
            <description>XML document</description>
          </parameter>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>An array of items</return-description>
      </method>
      <method name="close" scope="prototype">
        <description>See dojo.data.api.Read.close()</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request || keywordArgs || null" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <description>Return a new dojox.data.XmlItem</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional">
            <description>An object containing initial attributes</description>
          </parameter>
        </parameters>
        <return-description>An XML element</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>Delete an dojox.data.XmlItem (wrapper to a XML element).</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element to delete</description>
          </parameter>
        </parameters>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <description>Set an attribute value</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute || string" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="almost anything" usage="required">
            <description>A attribute value to set</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <description>Set attribute values</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute || string" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names
	value:
	A attribute value to set</description>
          </parameter>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>Remove an attribute</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute || string" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <description>Save new and/or modified items (XML elements)</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An object for callbacks</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <description>Invalidate changes (new and/or modified elements)</description>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <description>Check whether an item is new, modified or deleted</description>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>An item (XML element) to check</description>
          </parameter>
        </parameters>
        <return-description>True if an item or items are new, modified or deleted, otherwise
	false</return-description>
      </method>
      <method name="_saveItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPostUrl" scope="prototype">
        <description>Generate a URL for post</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPutUrl" scope="prototype">
        <description>Generate a URL for put</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A put URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getDeleteUrl" scope="prototype">
        <description>Generate a URL for delete</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to delete</description>
          </parameter>
        </parameters>
        <return-description>A delete URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPostContent" scope="prototype">
        <description>Generate a content to post</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getPutContent" scope="prototype">
        <description>Generate a content to put</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getAttribute" scope="prototype">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItemIndex" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_backupItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new or already modified"/>
        </return-types>
      </method>
      <method name="_restoreItems" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forgetItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDocument" scope="prototype">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="_getRootElement" scope="prototype">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMElement"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.data.util.simpleFetch" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>url to a service or an XML document that represents the store</description>
      </property>
      <property name="rootItem" scope="instance-prototype" type="A">
        <description>tag name for root items</description>
      </property>
      <property name="keyAttribute" scope="instance-prototype" type="An">
        <description>attribute name for a key or an indentify
	attributeMap:   An anonymous object contains properties for attribute mapping,
	{&amp;quot;tag_name.item_attribute_name&amp;quot;: &amp;quot;@xml_attribute_name&amp;quot;, ...}</description>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <description>boolean indicate to add a query string to the service URL</description>
      </property>
      <property name="_newItems" scope="instance" type="Object"/>
      <property name="_deletedItems" scope="instance" type="Object"/>
      <property name="_modifiedItems" scope="instance" type="Object"/>
      <property name="_attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.XmlItem">
    <description>Initialize with an XML element</description>
    <methods>
      <method name="toString" scope="prototype">
        <description>Return a value of the first text child of the element</description>
        <return-description>a value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="element" scope="instance" type="An">
        <description>XML element</description>
      </property>
      <property name="store" scope="instance" type="The">
        <description>containing store, if any.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.data.css.rules">
    <methods>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="Object" usage="required"/>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.css">
    <methods>
      <method name="findStyleSheets" scope="instance">
        <parameters>
          <parameter name="sheets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findStyleSheet" scope="instance">
        <parameters>
          <parameter name="sheet" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="IE stylesheet has imports[] containing @import'ed rules"/>
        </return-types>
      </method>
      <method name="determineContext" scope="instance">
        <parameters>
          <parameter name="initialStylesheets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.dom">
    <methods>
      <method name="createDocument" scope="instance">
        <description>cross-browser implementation of creating an XML document object.</description>
        <parameters>
          <parameter name="str" type="string" usage="optional">
            <description>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</description>
          </parameter>
          <parameter name="mimetype" type="string" usage="optional">
            <description>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node to get the text off of or set the text on.</description>
          </parameter>
          <parameter name="text" type="string" usage="optional">
            <description>Optional argument of the text to apply to the node.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type="empty string."/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to modify the children on</description>
          </parameter>
          <parameter name="newChildren" type="Node || array" usage="required">
            <description>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <description>removes all children from node and returns the count of children removed.
	The children nodes are not destroyed. Be sure to call dojo._destroyElement on them
	after they are not used anymore.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to remove all the children from.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <description>Implementation of MS's innerXML function.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.data.jsonPathStore" superclass="//              The jsonPathStore implements dojo.data.read, write, notify, and identity api's.  It is a local (in memory) store  //  and can take a javascript object with any arbitrary format and attach to it to provide a dojo.data interface to that object  //  data.  It uses jsonPath as the query language to search agains this store.  null">
    <description>jsonPathStore constructor, instantiate a new jsonPathStore
	Takes a single optional parameter in the form of a Javascript object
	containing one or more of the following properties.
	data: /*JSON String*/ || /* Javascript Object */,
	JSON String or Javascript object this store will control
	JSON is converted into an object, and an object passed to
	the store will be used directly.  If no data and no url
	is provide, an empty object, {}, will be used as the initial
	store.
	url: /* string url */
	Load data from this url in JSON format and use the Object
	created from the data as the data source.
	indexOnLoad: /* boolean */
	Defaults to true, but this may change in the near future.
	Parse the data object and set individual objects up as
	appropriate.  This will add meta data and assign
	id's to objects that dont' have them as defined by the
	idAttribute option.  Disabling this option will keep this
	parsing from happening until a query is performed at which
	time only the top level of an item has meta info stored.
	This might work in some situations, but you will almost
	always want to indexOnLoad or use another option which
	will create an index.  In the future we will support a
	generated index that maps by jsonPath allowing the
	server to take some of this load for larger data sets.
	idAttribute: /* string */
	Defaults to '_id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index. There
	are utility routines for exporting data from the store
	that can clean any generated IDs before exporting and leave
	preexisting id's in tact.
	metaLabel: /* string */
	Defaults to '_meta' overrides the attribute name that is used by the store
	for attaching meta information to an object while
	in the store's control.  Defaults to '_meta'.
	hideMetaAttributes: /* boolean */
	Defaults to False.  When enabled, calls to getAttributes() will not
	include the meta attribute.
	autoIdPrefix: /*string*/
	Defaults to &amp;quot;_auto_&amp;quot;.  This string is used as the prefix to any
	objects which have a generated id. A numeric index is appended
	to this string to complete the ID
	mode: dojox.data.ASYNC_MODE || dojox.data.SYNC_MODE
	Defaults to ASYNC_MODE.  This option sets the default mode for this store.
	Sync calls return their data immediately from the calling function
	instead of calling the callback functions.  Functions such as
	fetchItemByIdentity() and fetch() both accept a string parameter in addtion
	to the normal keywordArgs parameter.  When passed this option, SYNC_MODE will
	automatically be used even when the default mode of the system is ASYNC_MODE.
	A normal request to fetch or fetchItemByIdentity (with kwArgs object) can also
	include a mode property to override this setting for that one request.</description>
    <methods>
      <method name="_loadData" scope="prototype">
        <description>load data into the store. Index it if appropriate.</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadData" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setData" scope="prototype">
        <description>set the stores' data to the supplied object and then
	load and/or setup that data with the required meta info</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildIndex" scope="prototype">
        <description>parse the object structure, and turn any objects into
	jsonPathStore items. Basically this just does a recursive
	series of fetches which itself already examines any items
	as they are retrieved and setups up the required meta information.</description>
        <parameters>
          <parameter name="path" type="string" usage="required">
            <description>*/
	jsonPath Query for the starting point of this index construction.</description>
          </parameter>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_correctReference" scope="prototype">
        <description>make sure we have an reference to the item in the store
	and not a clone. Takes an item, matches it to the corresponding
	item in the store and if it is the same, returns itself, otherwise
	it returns the item from the store.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>Gets the value of an item's 'property'</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="property" type="string" usage="required">
            <description>*/
	property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <description>Gets the value of an item's 'property' and returns
	it.  If this value is an array it is just returned,
	if not, the value is added to an array and that is returned.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="property" type="string" usage="required">
            <description>*/
	property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <description>Gets the available attributes of an item's 'property' and returns
	it as an array. If the store has 'hideMetaAttributes' set to true
	the attributed identified by 'metaLabel' will not be included.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <description>Checks to see if item has attribute</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <description>Checks to see if 'item' has 'value' at 'attribute'</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>*/</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="_shallowCompare" scope="prototype">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <description>Checks to see if a passed 'item'
	is really a jsonPathStore item.  Currently
	it only verifies structure.  It does not verify
	that it belongs to this store at this time.</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/
	attribute: /* string */</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <description>returns isItem() :)</description>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>*/</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <description>returns true. Future implementatins might alter this</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateMeta" scope="prototype">
        <description>verifies that 'item' has a meta object attached
	and if not it creates it by setting it to 'props'
	if the meta attribute already exists, mix 'props'
	into it.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cleanMeta" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dump" scope="prototype">
        <description>exports the store data set. Takes an options
	object with a number of parameters
	data: /* object */
	Defaults to the root of the store.
	The data to be exported.
	clone: /* boolean */
	clone the data set before returning it
	or modifying it for export
	cleanMeta: /* boolean */
	clean the meta data off of the data. Note
	that this will happen to the actual
	store data if !clone. If you want
	to continue using the store after
	this operation, it is probably better to export
	it as a clone if you want it cleaned.
	suppressExportMeta: /* boolean */
	By default, when data is exported from the store
	some information, such as as a timestamp, is
	added to the root of exported data.  This
	prevents that from happening.  It is mainly used
	for making tests easier.
	type: &amp;quot;raw&amp;quot; || &amp;quot;json&amp;quot;
	Defaults to 'json'. 'json' will convert the data into
	json before returning it. 'raw' will just return a
	reference to the object</description>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>return the store feature set</description>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <description>returns an array of attributes that are used to create the label of an item</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="prototype">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <description>returns the attributes which are used to make up the
	identity of an item.  Basically returns this.idAttribute</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <description>fetch an item by its identity. This store also provides
	a much more finger friendly alias, 'byId' which does the
	same thing as this function.  If provided a string
	this call will be treated as a SYNC request and will
	return the identified item immediatly.  Alternatively it
	takes a object as a set of keywordArgs:
	identity: /* string */
	the id of the item you want to retrieve
	mode: dojox.data.SYNC_MODE || dojox.data.ASYNC_MODE
	overrides the default store fetch mode
	onItem: /* function */
	Result call back.  Passed the fetched item.
	onError: /* function */
	error callback.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <description>adds a new item to the store at the specified point.
	Takes two parameters, data, and options.</description>
        <parameters>
          <parameter name="data" type="object" usage="required">
            <description>*/
	The data to be added in as an item.  This could be a
	new javascript object, or it could be an item that
	already exists in the store.  If it already exists in the
	store, then this will be added as a reference.</description>
          </parameter>
          <parameter name="options" type="object" usage="required">
            <description>*/
	item: /* item */
	reference to an existing store item
	attribute: /* string */
	attribute to add the item at.  If this is
	not provided, the item's id will be used as the
	attribute name. If specified attribute is an
	array, the new item will be push()d on to the
	end of it.
	oldValue: /* old value of item[attribute]
	newValue: new value item[attribute]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addReference" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="pInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDirty" scope="prototype">
        <description>adds an item to the list of dirty items.  This item
	contains a reference to the item itself as well as a
	cloned and trimmed version of old item for use with
	revert.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>sets 'attribute' on 'item' to 'value'</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="prototype">
        <description>sets 'attribute' on 'item' to 'value' value
	must be an array.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <description>unsets 'attribute' on 'item'</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <description>Takes an optional set of keyword Args with
	some save options.  Currently only format with options
	being &amp;quot;raw&amp;quot; or &amp;quot;json&amp;quot;.  This function goes through
	the dirty item lists, clones and trims the item down so that
	the items children are not part of the data (the children are replaced
	with reference objects). This data is compiled into a single array, the dirty objects
	are all marked as clean, and the new data is then passed on to the onSave handler.</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markClean" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype"/>
      <method name="_mixin" scope="prototype">
        <description>specialized mixin that hooks up objects in the store where references are identified.</description>
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createReference" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trimItem" scope="prototype">
        <description>copy an item recursively stoppying at other items that have id's
	and replace them with a refrence object;</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="prototype"/>
      <method name="onNew" scope="prototype"/>
      <method name="onDelete" scope="prototype"/>
      <method name="onSave" scope="prototype">
        <description>notification of the save event..not part of the notification api,
	but probably should be.
	console.log(&amp;quot;onSave() &amp;quot;, items);</description>
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRevert" scope="prototype">
        <description>notification of the revert event..not part of the notification api,
	but probably should be.</description>
      </method>
    </methods>
    <properties>
      <property name="mode" scope="prototype" type="Object"/>
      <property name="metaLabel" scope="prototype" type="Object"/>
      <property name="hideMetaAttributes" scope="prototype" type="Object"/>
      <property name="autoIdPrefix" scope="prototype" type="Object"/>
      <property name="autoIdentity" scope="prototype" type="Object"/>
      <property name="idAttribute" scope="prototype" type="Object"/>
      <property name="indexOnLoad" scope="prototype" type="Object"/>
      <property name="labelAttribute" scope="prototype" type="Object"/>
      <property name="url" scope="prototype" type="Object"/>
      <property name="_replaceRegex" scope="prototype" type="Object"/>
      <property name="_data" scope="instance" type="Object"/>
      <property name="byId" scope="instance" type="Object"/>
      <property name="_dirtyItems" scope="instance" type="Object"/>
      <property name="_autoId" scope="instance" type="Object"/>
      <property name="_referenceId" scope="instance" type="Object"/>
      <property name="_references" scope="instance" type="Object"/>
      <property name="_fetchQueue" scope="instance" type="Object"/>
      <property name="index" scope="instance" type="Object"/>
      <property name="metaRegex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="item[this">
    <properties>
      <property name="metaLabel]" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date">
    <description>Additional date manipulation functions</description>
  </class>
  <class type="dojox.date.HebrewDate">
    <description>This is the constructor</description>
    <example>
			var date1 = new dojox.date.HebrewDate();
			var date2 = new dojox.date.HebrewDate("12\2\5768");
			var date3 = new dojox.date.HebrewDate(date2);
			var date4 = new dojox.date.HebrewDate(5768,2,12);</example>
    <methods>
      <method name="getDate" scope="prototype">
        <description>This function returns the date value (1 - 30)</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			document.writeln(date1.getDate);</example>
      </method>
      <method name="getMonth" scope="prototype">
        <description>This function return the month value ( 0 - 11 )</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			document.writeln(date1.getMonth()+1);</example>
      </method>
      <method name="getFullYear" scope="prototype">
        <description>This function return the Year value</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			document.writeln(date1.getFullYear());</example>
      </method>
      <method name="getHours" scope="prototype">
        <description>returns the Hour value</description>
      </method>
      <method name="getMinutes" scope="prototype">
        <description>returns the Minuites value</description>
      </method>
      <method name="getSeconds" scope="prototype">
        <description>returns the seconde value</description>
      </method>
      <method name="getMilliseconds" scope="prototype">
        <description>returns the Milliseconds value</description>
      </method>
      <method name="setDate" scope="prototype">
        <description>This function sets the Date</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			date1.setDate(2);</example>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setYear" scope="prototype">
        <description>This function set Year</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			date1.setYear(5768);</example>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="prototype">
        <description>This function set Month</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			date1.setMonth(2);</example>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="prototype">
        <description>set the Hours</description>
      </method>
      <method name="setMinutes" scope="prototype">
        <description>set the Minutes</description>
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="prototype">
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="prototype">
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <description>This returns a string representation of the date in &amp;quot;DDDD MMMM DD YYYY HH:MM:SS&amp;quot; format</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			document.writeln(date1.toString());
	FIXME: TZ/DST issues?</example>
      </method>
      <method name="parse" scope="prototype">
        <description>This function parse the date string</description>
        <example>
			var dateIslamic = new dojox.date.IslamicDate();
			dateIslamic.parse("Heshvan 2 5768");</example>
        <parameters>
          <parameter name="dateObject" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="prototype"/>
      <method name="getDaysInHebrewMonth" scope="prototype">
        <description>returns the number of days in the month used</description>
        <parameters>
          <parameter name="month" type="dojox.date.HebrewDate" usage="required"/>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.HebrewDate"/>
        </return-types>
      </method>
      <method name="_yearType" scope="prototype">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_handleGetYearLength" scope="prototype">
        <parameters>
          <parameter name="eyear" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_startOfYear" scope="prototype">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_isLeapYear" scope="prototype">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="prototype">
        <description>This function returns the equivalent Hebrew Date value for the Gregorian Date</description>
        <example>
			var dateHebrew = new dojox.date.HebrewDate();
			var dateGregorian = new Date(2008,10,12);
			dateHebrew.fromGregorian(dateGregorian);</example>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_computeHebrewFields" scope="prototype">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="prototype">
        <description>This returns the equevalent Grogorian date value in Date object</description>
        <example>
			var dateHebrew = new dojox.date.HebrewDate(5768,11,20);
			var dateGregorian = dateHebrew.toGregorian();</example>
      </method>
      <method name="_floorDivide" scope="prototype">
        <parameters>
          <parameter name="numerator" type="Object" usage="required"/>
          <parameter name="denominator" type="Object" usage="required"/>
          <parameter name="remainder" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDay" scope="prototype">
        <description>This function return Week Day value ( 0 - 6 )</description>
        <example>
			var date1 = new dojox.date.HebrewDate();
			document.writeln(date1.getDay());</example>
      </method>
      <method name="_getJulianDayFromGregorianDate" scope="prototype">
        <description>returns the Julian day of a Gregorian date</description>
        <parameters>
          <parameter name="gdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNames" scope="instance">
        <description>Used to get localized strings from dojo.cldr for day or month names.</description>
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>months || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>wide || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</description>
          </parameter>
          <parameter name="use" type="String" usage="optional">
            <description>standAlone || 'format' (default)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="TISHRI" scope="prototype" type="Object"/>
      <property name="HESHVAN" scope="prototype" type="Object"/>
      <property name="KISLEV" scope="prototype" type="Object"/>
      <property name="TEVET" scope="prototype" type="Object"/>
      <property name="SHEVAT" scope="prototype" type="Object"/>
      <property name="ADAR_1" scope="prototype" type="Object"/>
      <property name="ADAR" scope="prototype" type="Object"/>
      <property name="NISAN" scope="prototype" type="Object"/>
      <property name="IYAR" scope="prototype" type="Object"/>
      <property name="SIVAN" scope="prototype" type="Object"/>
      <property name="TAMUZ" scope="prototype" type="Object"/>
      <property name="AV" scope="prototype" type="Object"/>
      <property name="ELUL" scope="prototype" type="Object"/>
      <property name="_HOUR_PARTS" scope="prototype" type="Object"/>
      <property name="_DAY_PARTS" scope="prototype" type="Object"/>
      <property name="_MONTH_DAYS" scope="prototype" type="Object"/>
      <property name="_MONTH_FRACT" scope="prototype" type="Object"/>
      <property name="_MONTH_PARTS" scope="prototype" type="Object"/>
      <property name="BAHARAD" scope="prototype" type="Object"/>
      <property name="JAN_1_1_JULIAN_DAY" scope="prototype" type="Object"/>
      <property name="_MONTH_LENGTH" scope="prototype" type="Object"/>
      <property name="_MONTH_START" scope="prototype" type="Object"/>
      <property name="LEAP_MONTH_START" scope="prototype" type="Object"/>
      <property name="GREGORIAN_MONTH_COUNT" scope="prototype" type="Object"/>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Object"/>
      <property name="_year" scope="instance-prototype" type="Object"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance-prototype" type="Object"/>
      <property name="weekDays" scope="instance" type="Object"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.IslamicDate">
    <description>This is the constructor</description>
    <example>
			var date1 = new dojox.date.IslamicDate();
			var date2 = new dojox.date.IslamicDate("12\2\1429");
			var date3 = new dojox.date.IslamicDate(date2);
			var date4 = new dojox.date.IslamicDate(1429,2,12);</example>
    <methods>
      <method name="setDate" scope="prototype">
        <description>This function sets the Date</description>
        <example>
			var date1 = new dojox.date.IslamicDate();
			date1.setDate(2);</example>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="getDaysInIslamicMonth" scope="prototype">
        <parameters>
          <parameter name="month" type="dojox.date.IslamicDate" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.IslamicDate"/>
        </return-types>
      </method>
      <method name="_getNames" scope="instance">
        <description>Used to get localized strings from dojo.cldr for day or month names.</description>
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>months || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>wide || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</description>
          </parameter>
          <parameter name="use" type="String" usage="optional">
            <description>standAlone || 'format' (default)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Object"/>
      <property name="_year" scope="instance-prototype" type="Object"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance-prototype" type="Object"/>
      <property name="_GREGORIAN_EPOCH" scope="prototype" type="Object"/>
      <property name="_ISLAMIC_EPOCH" scope="prototype" type="Object"/>
      <property name="getDate" scope="prototype" type="Object"/>
      <property name="getMonth" scope="prototype" type="Object"/>
      <property name="getFullYear" scope="prototype" type="Object"/>
      <property name="getDay" scope="prototype" type="Object"/>
      <property name="getHours" scope="prototype" type="Object"/>
      <property name="getMinutes" scope="prototype" type="Object"/>
      <property name="getSeconds" scope="prototype" type="Object"/>
      <property name="getMilliseconds" scope="prototype" type="Object"/>
      <property name="setYear" scope="prototype" type="Object"/>
      <property name="setMonth" scope="prototype" type="Object"/>
      <property name="setHours" scope="prototype" type="Object"/>
      <property name="setMinutes" scope="prototype" type="Object"/>
      <property name="setSeconds" scope="prototype" type="Object"/>
      <property name="setMilliseconds" scope="prototype" type="Object"/>
      <property name="toString" scope="prototype" type="Object"/>
      <property name="toGregorian" scope="prototype" type="Object"/>
      <property name="fromGregorian" scope="prototype" type="Object"/>
      <property name="parse" scope="prototype" type="Object"/>
      <property name="valueOf" scope="prototype" type="Object"/>
      <property name="_yearStart" scope="prototype" type="Object"/>
      <property name="_monthStart" scope="prototype" type="Object"/>
      <property name="_civilLeapYear" scope="prototype" type="Object"/>
      <property name="_mod" scope="prototype" type="Object"/>
      <property name="weekDays" scope="instance" type="Object"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php">
    <methods>
      <method name="format" scope="instance">
        <description>Get a formatted string for a given date object</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.php.DateFormat">
    <description>Format the internal date object</description>
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="d" scope="prototype">
        <description>Day of the month, 2 digits with leading zeros</description>
      </method>
      <method name="j" scope="prototype">
        <description>Day of the month without leading zeros</description>
      </method>
      <method name="l" scope="prototype">
        <description>A full textual representation of the day of the week</description>
      </method>
      <method name="w" scope="prototype">
        <description>Numeric representation of the day of the week</description>
      </method>
      <method name="z" scope="prototype">
        <description>The day of the year (starting from 0)</description>
      </method>
      <method name="m" scope="prototype">
        <description>Numeric representation of a month, with leading zeros</description>
      </method>
      <method name="n" scope="prototype">
        <description>Numeric representation of a month, without leading zeros</description>
      </method>
      <method name="t" scope="prototype">
        <description>Number of days in the given month</description>
      </method>
      <method name="o" scope="prototype">
        <description>ISO-8601 year number. This has the same value as Y, except that if
	the ISO week number (W) belongs to the previous or next year, that year is used instead. (added in PHP 5.1.0)
	TODO: Figure out what this means</description>
      </method>
      <method name="y" scope="prototype">
        <description>A two digit representation of a year</description>
      </method>
      <method name="a" scope="prototype">
        <description>Lowercase Ante meridiem and Post meridiem</description>
      </method>
      <method name="b" scope="prototype">
        <description>Uppercase Ante meridiem and Post meridiem</description>
      </method>
      <method name="g" scope="prototype">
        <description>12-hour format of an hour without leading zeros</description>
      </method>
      <method name="h" scope="prototype">
        <description>12-hour format of an hour with leading zeros</description>
      </method>
      <method name="i" scope="prototype">
        <description>Minutes with leading zeros</description>
      </method>
      <method name="s" scope="prototype">
        <description>Seconds, with leading zeros</description>
      </method>
      <method name="e" scope="prototype">
        <description>Timezone identifier (added in PHP 5.1.0)</description>
      </method>
      <method name="c" scope="prototype">
        <description>ISO 8601 date (added in PHP 5)</description>
      </method>
      <method name="r" scope="prototype">
        <description>RFC 2822 formatted date</description>
      </method>
    </methods>
    <properties>
      <property name="tokens" scope="instance" type="Object"/>
      <property name="replacements" scope="instance" type="Object"/>
      <property name="weekdays" scope="prototype" type="Object"/>
      <property name="weekdays_3" scope="prototype" type="Object"/>
      <property name="months" scope="prototype" type="Object"/>
      <property name="months_3" scope="prototype" type="Object"/>
      <property name="monthdays" scope="prototype" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.constructor.prototype">
    <properties>
      <property name="regex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.D">
    <description>A textual representation of a day, three letters</description>
  </class>
  <class type="dojox.date.php.DateFormat.N">
    <description>ISO-8601 numeric representation of the day of the week (added in PHP 5.1.0)</description>
  </class>
  <class type="dojox.date.php.DateFormat.S">
    <description>English ordinal suffix for the day of the month, 2 characters</description>
  </class>
  <class type="dojox.date.php.DateFormat.W">
    <description>ISO-8601 week number of year, weeks starting on Monday (added in PHP 4.1.0)</description>
  </class>
  <class type="dojox.date.php.DateFormat.F">
    <description>A full textual representation of a month, such as January or March</description>
  </class>
  <class type="dojox.date.php.DateFormat.M">
    <description>A short textual representation of a month, three letters</description>
  </class>
  <class type="dojox.date.php.DateFormat.L">
    <description>Whether it's a leap year</description>
  </class>
  <class type="dojox.date.php.DateFormat.Y">
    <description>A full numeric representation of a year, 4 digits</description>
  </class>
  <class type="dojox.date.php.DateFormat.B">
    <description>Swatch Internet time
	A day is 1,000 beats. All time is measured from GMT + 1</description>
  </class>
  <class type="dojox.date.php.DateFormat.G">
    <description>24-hour format of an hour without leading zeros</description>
  </class>
  <class type="dojox.date.php.DateFormat.H">
    <description>24-hour format of an hour with leading zeros</description>
  </class>
  <class type="dojox.date.php.DateFormat.I">
    <description>Whether or not the date is in daylight saving time
	TODO: Can dojo.date do this?</description>
  </class>
  <class type="dojox.date.php.DateFormat.O">
    <description>Difference to Greenwich time (GMT) in hours</description>
  </class>
  <class type="dojox.date.php.DateFormat.P">
    <description>Difference to Greenwich time (GMT) with colon between hours and minutes (added in PHP 5.1.3)</description>
  </class>
  <class type="dojox.date.php.DateFormat.T">
    <description>Timezone abbreviation</description>
  </class>
  <class type="dojox.date.php.DateFormat.Z">
    <description>Timezone offset in seconds. The offset for timezones west of UTC is always negative,
	and for those east of UTC is always positive.</description>
  </class>
  <class type="dojox.date.php.DateFormat.U">
    <description>Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)</description>
  </class>
  <class type="dojox.date.posix">
    <methods>
      <method name="strftime" scope="instance">
        <description>Formats the date object using the specifications of the POSIX strftime function</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getStartOfWeek" scope="instance">
        <description>Return a date object representing the first day of the given
	date's week.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDay" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setIsoWeekOfYear" scope="instance">
        <description>Set the ISO8601 week number of the given date.
	The week containing January 4th is the first week of the year.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="week" type="Number" usage="required">
            <description>can be positive or negative: -1 is the year's last week.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getIsoWeekOfYear" scope="instance">
        <description>Get the ISO8601 week number of the given date.
	The week containing January 4th is the first week of the year.
	See http://en.wikipedia.org/wiki/ISO_week_date</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getIsoWeeksInYear" scope="instance">
        <description>Determine the number of ISO8601 weeks in the year of the given
	date. Most years have 52 but some have 53.
	See http://www.phys.uu.nl/~vgent/calendar/isocalendar_text3.htm</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl">
    <description>Django Templating Language implementation</description>
    <methods>
      <method name="quickFilter" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="TOKEN_BLOCK" scope="instance" type="Object"/>
      <property name="TOKEN_VAR" scope="instance" type="Object"/>
      <property name="TOKEN_COMMENT" scope="instance" type="Object"/>
      <property name="TOKEN_TEXT" scope="instance" type="Object"/>
      <property name="_TextNode" scope="instance" type="Object"/>
      <property name="_noOpNode" scope="instance" type="Object"/>
      <property name="mark_safe" scope="instance" type="Object"/>
      <property name="TOKEN_CHANGE" scope="instance" type="Object"/>
      <property name="TOKEN_ATTR" scope="instance" type="Object"/>
      <property name="TOKEN_CUSTOM" scope="instance" type="Object"/>
      <property name="TOKEN_NODE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context">
    <methods>
      <method name="getKeys" scope="prototype"/>
      <method name="extend" scope="prototype">
        <description>Returns a clone of this context object, with the items from the
	passed objecct mixed in.</description>
        <parameters>
          <parameter name="obj" type="dojox.dtl.Context|Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <description>Returns a clone of this context, only containing the items
	defined in the filter.</description>
        <parameters>
          <parameter name="filter" type="dojox.dtl.Context|Object|String" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="setThis" scope="prototype">
        <parameters>
          <parameter name="_this" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getThis" scope="prototype"/>
      <method name="hasKey" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.dtl._Context" scope="prototype"/>
      <mixin type="dojox.dtl._Context" scope="instance"/>
    </mixins>
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTemplated.prototype">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="setTemplate" scope="instance">
        <description>Quickly switch between templated by location</description>
        <parameters>
          <parameter name="template" type="String|dojo._Url" usage="required"/>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
          <parameter name="tpl" type="dojox.dtl.HtmlTemplate" usage="optional"/>
        </parameters>
      </method>
      <method name="_getContext" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dijitTemplateCompat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTemplated"/>
  <class type="ddcd">
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Templated" superclass="dijit._Templated">
    <methods>
      <method name="buildRendering" scope="prototype"/>
      <method name="getCachedTemplate" scope="prototype">
        <description>Layer for dijit._Templated.getCachedTemplate</description>
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype"/>
    </methods>
    <properties>
      <property name="_dijitTemplateCompat" scope="prototype" type="Object"/>
      <property name="_templateCache" scope="prototype" type="Object"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Context">
    <description>Pass one of these when rendering a template to tell the template what values to use.</description>
    <methods>
      <method name="push" scope="prototype"/>
      <method name="pop" scope="prototype"/>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="otherwise" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dicts" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Template">
    <methods>
      <method name="update" scope="prototype">
        <parameters>
          <parameter name="node" type="DOMNode|String|dojo.NodeList" usage="required">
            <description>A node reference or set of nodes</description>
          </parameter>
          <parameter name="context" type="dojo._Url|String|Object" usage="required">
            <description>The context object or location</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="concatenatable" usage="optional"/>
        </parameters>
      </method>
      <method name="getBuffer" scope="prototype"/>
    </methods>
    <properties>
      <property name="nodelist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._QuickNodeList">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dummyRender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Filter">
    <description>Uses a string to find (and manipulate) a variable</description>
    <methods>
      <method name="_tokenize" scope="prototype"/>
      <method name="getExpression" scope="prototype"/>
      <method name="resolve" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolvePath" scope="prototype">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="key" scope="instance" type="Object"/>
      <property name="filters" scope="instance" type="Object"/>
      <property name="_cache" scope="prototype" type="Object"/>
      <property name="_re" scope="prototype" type="Object"/>
      <property name="_values" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._NodeList">
    <description>Allows us to render a group of nodes</description>
    <methods>
      <method name="push" scope="prototype">
        <description>Add a new node to the list</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="concat" scope="prototype">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <description>Adds all content onto the buffer</description>
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dummyRender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype"/>
      <method name="clone" scope="prototype"/>
      <method name="rtrim" scope="prototype"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._VarNode">
    <description>A node to be processed as a variable</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Parser">
    <description>Parser used during initialization and for tag groups.</description>
    <methods>
      <method name="parse" scope="prototype">
        <description>Turns tokens into nodes</description>
        <parameters>
          <parameter name="stop_at" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="next_token" scope="prototype">
        <description>Returns the next token in the list.</description>
      </method>
      <method name="delete_first_token" scope="prototype"/>
      <method name="skip_past" scope="prototype">
        <parameters>
          <parameter name="endtag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create_variable_node" scope="prototype">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create_text_node" scope="prototype">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="prototype">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="i" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token">
    <methods>
      <method name="split" scope="instance"/>
      <method name="split_contents" scope="prototype">
        <parameters>
          <parameter name="limit" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="String.prototype.split" scope="instance"/>
    </mixins>
    <properties>
      <property name="token_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token.contents">
    <properties>
      <property name="split" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._base">
    <methods>
      <method name="escape" scope="instance">
        <description>Escapes a string's HTML</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="safe" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.text">
    <methods>
      <method name="_get" scope="instance">
        <description>Used to find both tags and filters</description>
        <parameters>
          <parameter name="module" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTag" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplateString" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveLazy" scope="instance">
        <parameters>
          <parameter name="location" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
          <parameter name="json" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveTemplateArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTemplate" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveContextArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseDelims" scope="instance">
        <parameters>
          <parameter name="varr" type="Object" usage="required"/>
          <parameter name="load" type="Object" usage="required"/>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_re" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.register._registry">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
      <property name="tags" scope="instance" type="Object"/>
      <property name="filters" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.register">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributeTags" scope="instance"/>
      <method name="_any" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tags" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filters" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._Filter._args">
    <properties>
      <property name="4" scope="instance" type="Object"/>
      <property name="5" scope="instance" type="Object"/>
      <property name="6" scope="instance" type="Object"/>
      <property name="7" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Node">
    <description>Basic catch-all node</description>
    <methods>
      <method name="set" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <description>Adds content onto the buffer</description>
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEmpty" scope="prototype"/>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._Parser.contents">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.data"/>
  <class type="dojox.dtl.contrib.data._BoundItem">
    <methods>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="item" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.data.BindDataNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="items" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib"/>
  <class type="dojox.dtl.contrib.dijit"/>
  <class type="dojox.dtl.contrib.dijit.AttachNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_keys" scope="instance" type="Object"/>
      <property name="_object" scope="instance" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit.EventNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="_command" scope="instance" type="Object"/>
      <property name="_types" scope="instance" type="Object"/>
      <property name="_fns" scope="instance" type="Object"/>
      <property name="_object" scope="instance" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
      <property name="_clear" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit.DojoTypeNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_parsed" scope="instance" type="Object"/>
      <property name="_dijit" scope="instance" type="Object"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit.DojoTypeNode._events">
    <properties>
      <property name="_object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit.DojoTypeNode._attach">
    <properties>
      <property name="_object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.html"/>
  <class type="dojox.dtl.contrib.html.StyleNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="_styles" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.html.BufferNode">
    <methods>
      <method name="_swap" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="options" scope="instance" type="Object"/>
      <property name="swapped" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="onAddNode" scope="instance" type="Object"/>
      <property name="onRemoveNode" scope="instance" type="Object"/>
      <property name="onChangeData" scope="instance" type="Object"/>
      <property name="onChangeAttribute" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.objects">
    <methods>
      <method name="key" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.ext-dojo">
    <properties>
      <property name="NodeList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter">
    <properties>
      <property name="dates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.htmlstrings">
    <methods>
      <method name="linebreaks" scope="instance">
        <description>Converts newlines into &amp;lt;p&amp;gt; and &amp;lt;br /&amp;gt;s</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaksbr" scope="instance">
        <description>Converts newlines into &amp;lt;br /&amp;gt;s</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removetags" scope="instance">
        <description>Removes a space separated list of [X]HTML tags from the output&amp;quot;</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="striptags" scope="instance">
        <description>Strips all [X]HTML tags</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_linebreaksrn" scope="instance" type="Object"/>
      <property name="_linebreaksn" scope="instance" type="Object"/>
      <property name="_linebreakss" scope="instance" type="Object"/>
      <property name="_linebreaksbr" scope="instance" type="Object"/>
      <property name="_removetagsfind" scope="instance" type="Object"/>
      <property name="_striptags" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.integers">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get_digit" scope="instance">
        <description>Given a whole number, returns the 1-based requested digit of it
	desciprtion:
	1 is the right-most digit, 2 is the second-right-most digit, etc. Returns the
	original value for invalid input (if input or argument is not an integer,
	or if argument is less than 1). Otherwise, output is always an integer.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.lists">
    <methods>
      <method name="_dictsort" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsort" scope="instance">
        <description>Takes a list of dicts, returns that list sorted by the property given in the argument.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsortreversed" scope="instance">
        <description>Takes a list of dicts, returns that list sorted in reverse order by the property given in the argument.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="first" scope="instance">
        <description>Returns the first item in a list</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="join" scope="instance">
        <description>Joins a list with a string, like Python's ``str.join(list)``</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <description>Returns the length of the value - useful for lists</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length_is" scope="instance">
        <description>Returns a boolean of whether the value's length is the argument</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="random" scope="instance">
        <description>Returns a random item from the list</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slice" scope="instance">
        <description>Returns a slice of the list.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unordered_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="tabs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unordered_list" scope="instance">
        <description>Recursively takes a self-nested list and returns an HTML unordered list --
	WITHOUT opening and closing &amp;lt;ul&amp;gt; tags.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.logic">
    <methods>
      <method name="default_" scope="instance">
        <description>If value is unavailable, use given default</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="default_if_none" scope="instance">
        <description>If value is null, use given default</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="divisibleby" scope="instance">
        <description>Returns true if the value is devisible by the argument&amp;quot;</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="yesno" scope="instance">
        <description>arg being a comma-delimited string, value of true/false/none
	chooses the appropriate item from the string</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_yesno" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.misc">
    <methods>
      <method name="filesizeformat" scope="instance">
        <description>Format the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB, 102bytes, etc).</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluralize" scope="instance">
        <description>Returns a plural suffix if the value is not 1, for '1 vote' vs. '2 votes'</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phone2numeric" scope="instance">
        <description>Takes a phone number and converts it in to its numerical equivalent</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pprint" scope="instance">
        <description>A wrapper around toJson unless something better comes along</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.misc._phone2numeric">
    <properties>
      <property name="a" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
      <property name="c" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="f" scope="instance" type="Object"/>
      <property name="g" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
      <property name="i" scope="instance" type="Object"/>
      <property name="j" scope="instance" type="Object"/>
      <property name="k" scope="instance" type="Object"/>
      <property name="l" scope="instance" type="Object"/>
      <property name="m" scope="instance" type="Object"/>
      <property name="n" scope="instance" type="Object"/>
      <property name="o" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="s" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="u" scope="instance" type="Object"/>
      <property name="v" scope="instance" type="Object"/>
      <property name="w" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings">
    <methods>
      <method name="_urlquote" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="safe" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="addslashes" scope="instance">
        <description>Adds slashes - useful for passing strings to JavaScript, for example.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="capfirst" scope="instance">
        <description>Capitalizes the first character of the value</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="instance">
        <description>Centers the value in a field of a given width</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cut" scope="instance">
        <description>Removes all values of arg from the given string</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fix_ampersands" scope="instance">
        <description>Replaces ampersands with ``&amp;amp;amp;`` entities</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="floatformat" scope="instance">
        <description>Format a number according to arg</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iriencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linenumbers" scope="instance">
        <description>Displays text with line numbers</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ljust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lower" scope="instance">
        <description>Converts a string into all lowercase</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="make_list" scope="instance">
        <description>Returns the value turned into a list. For an integer, it's a list of
	digits. For a string, it's a list of characters.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rjust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slugify" scope="instance">
        <description>Converts to lowercase, removes
	non-alpha chars and converts spaces to hyphens</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stringformat" scope="instance">
        <description>Formats the variable according to the argument, a string formatting specifier.
	This specifier uses Python string formating syntax, with the exception that
	the leading &amp;quot;%&amp;quot; is dropped.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <description>Converts a string into titlecase</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords" scope="instance">
        <description>Truncates a string after a certain number of words</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Integer" usage="required">
            <description>Number of words to truncate after</description>
          </parameter>
        </parameters>
      </method>
      <method name="truncatewords_html" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upper" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlizetrunc" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="' + middle + '&quot; rel=&quot;nofollow&quot;&gt;' + trimmed + '&lt;/a&gt;';"/>
        </return-types>
      </method>
      <method name="wordcount" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wordwrap" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_fix_ampersands" scope="instance" type="Object"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_truncatewords" scope="instance" type="Object"/>
      <property name="_truncate_words" scope="instance" type="Object"/>
      <property name="_truncate_tag" scope="instance" type="Object"/>
      <property name="_urlize" scope="instance" type="Object"/>
      <property name="_urlize2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings._truncate_singlets">
    <properties>
      <property name="br" scope="instance" type="Object"/>
      <property name="col" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="base" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="param" scope="instance" type="Object"/>
      <property name="area" scope="instance" type="Object"/>
      <property name="hr" scope="instance" type="Object"/>
      <property name="input" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.HtmlTemplate">
    <description>Use this object for HTML templating</description>
    <methods>
      <method name="setClass" scope="prototype">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRootNode" scope="prototype"/>
      <method name="getBuffer" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tokens" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="_count" scope="prototype" type="Object"/>
      <property name="_re" scope="prototype" type="Object"/>
      <property name="buffer" scope="instance" type="Object"/>
      <property name="rootNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.HtmlBuffer">
    <description>Allows the manipulation of DOM</description>
    <methods>
      <method name="concat" scope="prototype">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setAttribute" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addEvent" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
          <parameter name="args" type="Array|Function" usage="required"/>
        </parameters>
      </method>
      <method name="setParent" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="up" type="Boolean" usage="optional"/>
          <parameter name="root" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getParent" scope="prototype"/>
      <method name="getRootNode" scope="prototype"/>
      <method name="onSetParent" scope="prototype">
        <description>Stub called when setParent is used.</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="up" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddNode" scope="prototype">
        <description>Stub called before new nodes are added</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddNodeComplete" scope="prototype">
        <description>Stub called after new nodes are added</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveNode" scope="prototype">
        <description>Stub called when nodes are removed</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChangeAttribute" scope="prototype">
        <description>Stub called when an attribute is changed</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="updated" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChangeData" scope="prototype">
        <description>Stub called when a data in a node is changed</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="updated" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClone" scope="prototype">
        <description>Stub called when a node is duplicated</description>
        <parameters>
          <parameter name="from" type="DOMNode" usage="required"/>
          <parameter name="to" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="onAddEvent" scope="prototype">
        <description>Stub to call when you're adding an event</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="description" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_parent" scope="instance" type="Object"/>
      <property name="_cache" scope="instance" type="Object"/>
      <property name="rootNode" scope="instance" type="Object"/>
      <property name="_removed" scope="instance" type="Object"/>
      <property name="_closed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlNode">
    <description>Places a node into DOM</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlNodeList">
    <description>A list of any HTML-specific node object</description>
    <methods>
      <method name="push" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unshift" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="instance" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="dummyRender" scope="prototype">
        <description>A really expensive way of checking to see how a rendering will look.
	Used in the ifchanged tag</description>
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="asNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="instance" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <description>Used to create an identical copy of a NodeList, useful for things like the for tag.</description>
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rtrim" scope="prototype"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlVarNode">
    <description>A node to be processed as a variable</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="_type" scope="instance" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
      <property name="_root" scope="instance" type="Object"/>
      <property name="_injected" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_src" scope="instance" type="Object"/>
      <property name="_html" scope="instance" type="Object"/>
      <property name="_div" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.ChangeNode">
    <description>Changes the parent during render/unrender</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="up" scope="instance" type="Object"/>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.AttributeNode">
    <description>Works on attributes</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="key" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
      <property name="_pool" scope="prototype" type="Object"/>
      <property name="_rendered" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTextNode">
    <description>Adds a straight text node without any processing</description>
    <methods>
      <method name="set" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEmpty" scope="prototype"/>
      <method name="clone" scope="prototype"/>
    </methods>
    <properties>
      <property name="upcoming" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlParser">
    <description>Turn a simple array into a set of objects</description>
    <methods>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="stop_at" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="next_token" scope="prototype">
        <description>Returns the next token in the list.</description>
      </method>
      <method name="delete_first_token" scope="prototype"/>
      <method name="skip_past" scope="prototype">
        <parameters>
          <parameter name="endtag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create_variable_node" scope="prototype">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create_text_node" scope="prototype">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="prototype">
        <parameters>
          <parameter name="loc" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
      <property name="i" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.html">
    <methods>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="nodes" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_tokenize" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="tokens" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="__tokenize" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="tokens" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_attributes" scope="instance" type="Object"/>
      <property name="_re4" scope="instance" type="Object"/>
      <property name="_swallowed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlVarNode._txt">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTextNode.contents">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.html"/>
  <class type="dojox.dtl.render.html.Render">
    <methods>
      <method name="setAttachPoint" scope="prototype">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="tpl" type="dojox.dtl.HtmlTemplate" usage="optional"/>
          <parameter name="buffer" type="dojox.dtl.HtmlBuffer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render"/>
  <class type="dojox.dtl.tag.date">
    <methods>
      <method name="now" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.date.NowNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_format" scope="instance" type="Object"/>
      <property name="format" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag"/>
  <class type="dojox.dtl.tag.loader"/>
  <class type="dojox.dtl.tag.loader.BlockNode">
    <methods>
      <method name="super" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="rendered" scope="instance" type="Object"/>
      <property name="context" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loader.ExtendsNode">
    <methods>
      <method name="getParent" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype"/>
    </methods>
    <properties>
      <property name="getTemplate" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="shared" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="key" scope="instance" type="Object"/>
      <property name="parents" scope="prototype" type="Object"/>
      <property name="rendered" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loader.IncludeNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_path" scope="instance" type="Object"/>
      <property name="constant" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="getTemplate" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="parsed" scope="instance" type="Object"/>
      <property name="_cache" scope="prototype" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
      <property name="rendered" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.logic"/>
  <class type="dojox.dtl.tag.logic.IfNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="bools" scope="instance" type="Object"/>
      <property name="trues" scope="instance" type="Object"/>
      <property name="falses" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.logic.IfEqualNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="var1" scope="instance" type="Object"/>
      <property name="var2" scope="instance" type="Object"/>
      <property name="trues" scope="instance" type="Object"/>
      <property name="falses" scope="instance" type="Object"/>
      <property name="negate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.logic.ForNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="assign" scope="instance" type="Object"/>
      <property name="loop" scope="instance" type="Object"/>
      <property name="reversed" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="pool" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop"/>
  <class type="dojox.dtl.tag.loop.CycleNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cyclevars" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop.IfChangedNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="nodes" scope="instance" type="Object"/>
      <property name="_vars" scope="instance" type="Object"/>
      <property name="vars" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop.RegroupNode">
    <methods>
      <method name="_push" scope="prototype">
        <parameters>
          <parameter name="container" type="Object" usage="required"/>
          <parameter name="grouper" type="Object" usage="required"/>
          <parameter name="stack" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_expression" scope="instance" type="Object"/>
      <property name="expression" scope="instance" type="Object"/>
      <property name="key" scope="instance" type="Object"/>
      <property name="alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop.CycleNode.shared">
    <properties>
      <property name="counter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop.IfChangedNode.shared">
    <properties>
      <property name="last" scope="instance" type="Object"/>
      <property name="counter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc"/>
  <class type="dojox.dtl.tag.misc.DebugNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype"/>
    </methods>
    <properties>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.FilterNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_varnode" scope="instance" type="Object"/>
      <property name="_nodelist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.FirstOfNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_vars" scope="instance" type="Object"/>
      <property name="vars" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.SpacelessNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_watch" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_watchParent" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="nodelist" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.TemplateTagNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tag" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.WidthRatioNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="current" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.WithNode">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="target" scope="instance" type="Object"/>
      <property name="alias" scope="instance" type="Object"/>
      <property name="nodelist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc.TemplateTagNode.mapping">
    <properties>
      <property name="openblock" scope="instance" type="Object"/>
      <property name="closeblock" scope="instance" type="Object"/>
      <property name="openvariable" scope="instance" type="Object"/>
      <property name="closevariable" scope="instance" type="Object"/>
      <property name="openbrace" scope="instance" type="Object"/>
      <property name="closebrace" scope="instance" type="Object"/>
      <property name="opencomment" scope="instance" type="Object"/>
      <property name="closecomment" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <description>Takes two datetime objects and returns the time between then and now
	as a nicely formatted string, e.g &amp;quot;10 minutes&amp;quot;</description>
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="now" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_chunks" scope="instance" type="Object"/>
      <property name="_months_ap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat">
    <methods>
      <method name="f" scope="prototype">
        <description>Time, in 12-hour hours and minutes, with minutes left off if they're zero.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.date.php.DateFormat" scope="prototype"/>
      <mixin type="dojox.date.php.DateFormat" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat.N">
    <description>Month abbreviation in Associated Press style. Proprietary extension.</description>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat.P">
    <description>Time, in 12-hour hours, minutes and 'a.m.'/'p.m.', with minutes left off
	if they're zero and the strings 'midnight' and 'noon' if appropriate.</description>
  </class>
  <class type="dojox.dtl.utils"/>
  <class type="dojox.editor.plugins"/>
  <class type="dojox.editor.plugins.GlobalTableHandler" superclass="dijit._editor._Plugin">
    <description>A global object that handles common tasks for all the plugins. Since
	there are several plugins that are all calling common methods, it's preferable
	that they call a centralized location that either has a set variable or a
	timeout to only repeat code-heavy calls when necessary.</description>
    <methods>
      <method name="doMixins" scope="prototype"/>
      <method name="initialize" scope="prototype">
        <description>Initialize the global handler upon a plugin's first instance of setEditor
	All plugins will attempt initialization. We only need to do so once.</description>
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTableInfo" scope="prototype">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectDraggable" scope="prototype"/>
      <method name="onDragStart" scope="prototype"/>
      <method name="onDragEnd" scope="prototype"/>
      <method name="checkAvailable" scope="prototype"/>
      <method name="_prepareTable" scope="prototype">
        <parameters>
          <parameter name="tbl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTimeStamp" scope="prototype"/>
      <method name="_tempStoreTableData" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_tempAvailability" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectTableKeys" scope="prototype"/>
      <method name="disconnectTableKeys" scope="prototype"/>
      <method name="onKeyDown" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplayChanged" scope="prototype"/>
    </methods>
    <properties>
      <property name="tablesConnected" scope="instance-prototype" type="Object"/>
      <property name="currentlyAvailable" scope="instance-prototype" type="Object"/>
      <property name="alwaysAvailable" scope="prototype" type="Object"/>
      <property name="availableCurrentlySet" scope="instance-prototype" type="Object"/>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="tableData" scope="instance-prototype" type="Object"/>
      <property name="shiftKeyDown" scope="instance-prototype" type="Object"/>
      <property name="undoEnabled" scope="prototype" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="cnKeyDn" scope="instance" type="Object"/>
      <property name="cnKeyUp" scope="instance" type="Object"/>
      <property name="stopEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.GlobalTableHandler.editorDomNode">
    <properties>
      <property name="ondragstart" scope="instance" type="Object"/>
      <property name="ondragend" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins" superclass="dijit._editor._Plugin">
    <description>A collection of Plugins for inserting and modifying tables in the Editor
	See end of this document for all avaiable plugs
	and dojox/editorPlugins/tests/editorTablePlugs.html for an example
	NOT IMPLEMENTED: Not handling cell merge, span or split</description>
    <methods>
      <method name="onDisplayChanged" scope="prototype">
        <parameters>
          <parameter name="withinTable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="prototype"/>
      <method name="onEditorLoaded" scope="prototype"/>
      <method name="selectTable" scope="prototype"/>
      <method name="launchInsertDialog" scope="prototype"/>
      <method name="launchModifyDialog" scope="prototype"/>
      <method name="_initButton" scope="prototype"/>
      <method name="modTable" scope="instance-prototype">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="begEdit" scope="prototype"/>
      <method name="endEdit" scope="prototype"/>
      <method name="makeColumnsEven" scope="prototype"/>
      <method name="getTableInfo" scope="prototype">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeTitle" scope="prototype">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCells" scope="prototype"/>
    </methods>
    <properties>
      <property name="iconClassPrefix" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="instance-prototype" type="Object"/>
      <property name="commandName" scope="instance-prototype" type="Object"/>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="alwaysAvailable" scope="instance-prototype" type="Object"/>
      <property name="undoEnabled" scope="prototype" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
      <property name="_onBlur" scope="instance" type="Object"/>
      <property name="menu" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="valBeforeUndo" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins._createContextMenu">
    <methods>
      <method name="_onBlur" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins.TablePlugins.button.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onInsert" scope="prototype"/>
      <method name="onBuildTable" scope="prototype">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorModifyTableDialog" superclass="dijit.Dialog">
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="table" scope="prototype" type="Object"/>
      <property name="tableAtts" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="this.editor">
    <methods>
      <method name="getAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectElement" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="returnFirstOnly" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.editor"/>
  <class type="dojox.editor.plugins.UploadImage" superclass="dijit._editor._Plugin">
    <description>Adds an icon to the Editor toolbar that when clicked, opens a system dialog
	Although the toolbar icon is a tiny &amp;quot;image&amp;quot; the uploader could be used for
	any file type</description>
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="createFileInput" scope="prototype"/>
      <method name="onComplete" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
          <parameter name="widgetRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTempImage" scope="prototype"/>
    </methods>
    <properties>
      <property name="tempImageUrl" scope="prototype" type="Object"/>
      <property name="iconClassPrefix" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="uploadUrl" scope="prototype" type="Object"/>
      <property name="fileInput" scope="instance-prototype" type="Object"/>
      <property name="label" scope="prototype" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="currentImageId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="kwArgs">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed">
    <methods>
      <method name="__flashArgs" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>The URL of the movie to embed.</description>
          </parameter>
          <parameter name="id" type="String" usage="optional">
            <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
          </parameter>
          <parameter name="width" type="Number" usage="optional">
            <description>The width of the embedded movie; the default value is 320px.</description>
          </parameter>
          <parameter name="height" type="Number" usage="optional">
            <description>The height of the embedded movie; the default value is 240px</description>
          </parameter>
          <parameter name="style" type="String" usage="optional">
            <description>Any CSS style information (i.e. style=&amp;quot;background-color:transparent&amp;quot;) you want
	to define on the markup.</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>A set of key/value pairs that you want to define in the resultant markup.</description>
          </parameter>
          <parameter name="vars" type="Object" usage="optional">
            <description>A set of key/value pairs that the Flash movie will interpret as FlashVars.</description>
          </parameter>
          <parameter name="expressInstall" type="Boolean" usage="optional">
            <description>Whether or not to include any kind of expressInstall info. Default is false.</description>
          </parameter>
          <parameter name="redirect" type="String" usage="optional">
            <description>A url to redirect the browser to if the current Flash version is not supported.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.embed.Flash">
    <description>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).</description>
    <example>Embed a flash movie in a document using the new operator, and get a reference to it.
		var movie = new dojox.embed.Flash({
			path: "path/to/my/movie.swf",
			width: 400,
			height: 300
		}, myWrapperNode);</example>
    <methods>
      <method name="onReady" scope="prototype">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="dojox.embed.__flashArgs" usage="required"/>
          <parameter name="node" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
      <method name="_destroy" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="onInitialize" scope="instance"/>
      <method name="__ie_markup__" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="proxy" scope="instance">
        <description>Create the set of passed methods on the dojox.embed.Flash object
	so that you can call that object directly, as opposed to having to
	delve into the internal movie to do this.  Intended to make working
	with Flash movies that use ExternalInterface much easier to use.</description>
        <example>Create "setMessage" and "getMessage" methods on foo.
		var foo = new dojox.embed.Flash(args, someNode);
		dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			console.log(this.getMessage());
		}));</example>
        <parameters>
          <parameter name="obj" type="dojox.embed.Flash" usage="required"/>
          <parameter name="methods" type="Array | String" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="String">
        <description>The ID of the internal embed/object tag.  Can be used to get a reference to
	the movie itself.</description>
      </property>
      <property name="movie" scope="instance" type="HTMLObject">
        <description>A reference to the Flash movie itself.</description>
      </property>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_poller" scope="instance" type="Object"/>
      <property name="_pollCount" scope="instance" type="Object"/>
      <property name="minSupported" scope="instance" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
      <property name="supported" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.IE">
    <properties>
      <property name="flash" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Object" superclass="dijit._Widget">
    <description>A widget you can use to embed either a Flash or Quicktime
	movie.</description>
    <example>From markup:
		&lt;div dojoType="dojox.embed.Object" src="path/to/movie.swf"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
    </methods>
    <properties>
      <property name="width" scope="instance-prototype" type="Number?">
        <description>The width of the movie. If not provided, the width of this.domNode is used.</description>
      </property>
      <property name="height" scope="prototype" type="Number?">
        <description>The height of the movie. If not provided, the height of this.domNode is used.</description>
      </property>
      <property name="src" scope="prototype" type="String">
        <description>The URL of the movie to embed.</description>
      </property>
      <property name="movie" scope="instance-prototype" type="HTMLEmbed">
        <description>The eventual reference to the movie embedded.  If you are looking to script
	control over the movie, you'd access it this way.</description>
      </property>
      <property name="params" scope="instance-prototype" type="Object">
        <description>A property bag that is created postCreate.  Any additional attributes you
	define on your domNode will be collected and placed into this, which will
	then be passed to the movie constructor.</description>
      </property>
      <property name="reFlash" scope="prototype" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
      <property name="reQtMovie" scope="prototype" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
      <property name="reQtAudio" scope="prototype" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
    </properties>
  </class>
  <class type="n">
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="n.style">
    <properties>
      <property name="cssText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Quicktime">
    <description>Returns a reference to the HTMLObject/HTMLEmbed that is created to
	place the movie in the document.  You can use this either with or
	without the new operator.  Note that with any other DOM manipulation,
	you must wait until the document is finished loading before trying
	to use this.</description>
    <example>Embed a QuickTime movie in a document using the new operator, and get a reference to it.
		var movie = new dojox.embed.QuickTime({
			path: "path/to/my/movie.mov",
			width: 400,
			height: 300
		}, myWrapperNode);</example>
    <methods>
      <method name="onInitialize" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="QuickTimeObject"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="supported" scope="instance" type="Object"/>
      <property name="minSupported" scope="instance" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.__QTArgs">
    <properties>
      <property name="id" scope="instance" type="String?">
        <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
      </property>
      <property name="path" scope="instance" type="String">
        <description>The URL of the movie to embed.</description>
      </property>
      <property name="width" scope="instance" type="Number?">
        <description>The width of the embedded movie; the default value is 320px.</description>
      </property>
      <property name="height" scope="instance" type="Number?">
        <description>The height of the embedded movie; the default value is 240px</description>
      </property>
      <property name="params" scope="instance" type="Object?">
        <description>A set of key/value pairs that you want to define in the resultant markup.</description>
      </property>
      <property name="redirect" scope="instance" type="String?">
        <description>A url to redirect the browser to if the current QuickTime version is not supported.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.embed.Quicktime.version">
    <properties>
      <property name="major" scope="instance" type="Object"/>
      <property name="minor" scope="instance" type="Object"/>
      <property name="rev" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding">
    <description>Various encoding algorithms, including crypto and digests.</description>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.ascii85">
    <methods>
      <method name="encode" scope="instance">
        <description>encodes input data in ascii85 string</description>
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <description>decodes the input string back to array of numbers</description>
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="ba" type="byte[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="byte[]"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits"/>
  <class type="dojox.encoding.bits.OutputStream">
    <methods>
      <method name="reset" scope="prototype"/>
      <method name="putBits" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype"/>
      <method name="getBuffer" scope="prototype"/>
    </methods>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
      <property name="accumulator" scope="instance" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.InputStream">
    <methods>
      <method name="getBits" scope="prototype">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype"/>
    </methods>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="bbyte" scope="instance" type="Object"/>
      <property name="bit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw"/>
  <class type="dojox.encoding.compression.lzw.Encoder">
    <methods>
      <method name="init" scope="prototype"/>
      <method name="encode" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flush" scope="prototype">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="size" scope="instance" type="Object"/>
      <property name="dict" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder">
    <methods>
      <method name="init" scope="prototype"/>
      <method name="decode" scope="prototype">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="size" scope="instance" type="Object"/>
      <property name="codes" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.p">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression">
    <properties>
      <property name="splay" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.Splay">
    <methods>
      <method name="reset" scope="prototype"/>
      <method name="splay" scope="prototype">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encode" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="prototype">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="up" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.Blowfish">
    <methods>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="plaintext" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="ao" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ciphertext" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="ao" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIV" scope="instance">
        <parameters>
          <parameter name="outputType" type="dojox.encoding.crypto.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="setIV" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="inputType" type="dojox.encoding.crypto.outputTypes" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.crypto.cipherModes">
    <properties>
      <property name="ECB" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests">
    <methods>
      <method name="addWords" scope="instance">
        <parameters>
          <parameter name="a" type="word" usage="required"/>
          <parameter name="b" type="word" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word"/>
        </return-types>
      </method>
      <method name="stringToWord" scope="instance">
        <parameters>
          <parameter name="s" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
        </return-types>
      </method>
      <method name="wordToString" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToHex" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToBase64" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests.MD5">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.easy64">
    <methods>
      <method name="encode" scope="instance">
        <description>encodes input data in easy64 string</description>
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <description>decodes the input string back to array of numbers</description>
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash">
    <description>Utilities to embed and communicate with Flash-based objects</description>
    <methods>
      <method name="setSwf" scope="instance">
        <description>Sets the SWF files and versions we are using.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL to this Flash file.</description>
          </parameter>
          <parameter name="visible" type="boolean" usage="optional">
            <description>Whether the Flash file is visible or not. If it is not visible we hide
	it off the screen. This defaults to true (i.e. the Flash file is
	visible).</description>
          </parameter>
        </parameters>
      </method>
      <method name="addLoadedListener" scope="instance">
        <description>Adds a listener to know when Flash is finished loading.
	Useful if you don't want a dependency on dojo.event.</description>
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called when Flash is done loading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addInstallingListener" scope="instance">
        <description>Adds a listener to know if Flash is being installed.
	Useful if you don't want a dependency on dojo.event.</description>
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called if Flash is being
	installed</description>
          </parameter>
        </parameters>
      </method>
      <method name="loaded" scope="instance">
        <description>Called back when the Flash subsystem is finished loading.</description>
      </method>
      <method name="installing" scope="instance">
        <description>Called if Flash is being installed.</description>
      </method>
      <method name="_initialize" scope="instance"/>
    </methods>
    <properties>
      <property name="ready" scope="instance" type="Object"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="_visible" scope="instance" type="Object"/>
      <property name="_loadedListeners" scope="instance" type="Object"/>
      <property name="_installingListeners" scope="instance" type="Object"/>
      <property name="info" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Info">
    <description>A class that helps us determine whether Flash is available.</description>
  </class>
  <class type="dojox.flash.Info.prototype">
    <methods>
      <method name="isVersionOrAbove" scope="instance">
        <description>Boolean
	Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.</description>
        <parameters>
          <parameter name="reqMajorVer" type="int" usage="required"/>
          <parameter name="reqMinorVer" type="int" usage="required"/>
          <parameter name="reqVer" type="int" usage="required"/>
        </parameters>
        <return-description>Returns true if the player is equal
	or above the given version, false otherwise.
	make the revision a decimal (i.e. transform revision 14 into
	0.14</return-description>
      </method>
      <method name="_detectVersion" scope="instance"/>
    </methods>
    <properties>
      <property name="version" scope="instance" type="String">
        <description>The full version string, such as &amp;quot;8r22&amp;quot;.</description>
      </property>
      <property name="versionMajor" scope="instance" type="Object"/>
      <property name="versionMinor" scope="instance" type="Object"/>
      <property name="versionRevision" scope="instance" type="Object"/>
      <property name="capable" scope="instance" type="Boolean">
        <description>Whether this platform has Flash already installed.</description>
      </property>
      <property name="installing" scope="instance" type="Boolean">
        <description>Set if we are in the middle of a Flash installation session.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.flash.Info.prototype._JSFlashInfo"/>
  <class type="dojox.flash.Embed">
    <description>A class that is used to write out the Flash object into the page.</description>
    <properties>
      <property name="_visible" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Embed.prototype">
    <methods>
      <method name="protocol" scope="instance"/>
      <method name="write" scope="instance">
        <description>Writes the Flash into the page.</description>
        <parameters>
          <parameter name="doExpressInstall" type="Boolean" usage="optional">
            <description>Whether to write out Express Install
	information. Optional value; defaults to false.
	figure out the SWF file to get and how to write out the correct HTML
	for this Flash version</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Object
	Gets the Flash object DOM node.</description>
      </method>
      <method name="setVisible" scope="instance">
        <description>console.debug(&amp;quot;setVisible, visible=&amp;quot;+visible);
	Sets the visibility of this Flash object.</description>
        <parameters>
          <parameter name="visible" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="instance">
        <description>Centers the flash applet on the page.</description>
      </method>
    </methods>
    <properties>
      <property name="width" scope="instance" type="int">
        <description>The width of this Flash applet. The default is the minimal width
	necessary to show the Flash settings dialog. Current value is
	215 pixels.</description>
      </property>
      <property name="height" scope="instance" type="int">
        <description>The height of this Flash applet. The default is the minimal height
	necessary to show the Flash settings dialog. Current value is
	138 pixels.</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>The id of the Flash object. Current value is 'flashObject'.</description>
      </property>
      <property name="_visible" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Communicator">
    <description>A class that is used to communicate between Flash and JavaScript.</description>
  </class>
  <class type="dojox.flash.Communicator.prototype">
    <methods>
      <method name="_addExternalInterfaceCallback" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execFlash" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
          <parameter name="methodArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.Install">
    <description>Helps install Flash plugin if needed.</description>
  </class>
  <class type="dojox.flash.Install.prototype">
    <methods>
      <method name="needed" scope="instance">
        <description>Boolean
	Determines if installation or revving of the current plugin is
	needed.
	do we even have flash?</description>
      </method>
      <method name="install" scope="instance">
        <description>Performs installation or revving of the Flash plugin.</description>
      </method>
      <method name="_onInstallStatus" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form">
    <properties>
      <property name="RangeSlider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.BusyButton" superclass="dijit.form.Button">
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <description>stores initial label and timeout for reference</description>
      </method>
      <method name="makeBusy" scope="prototype">
        <description>sets state from idle to busy</description>
      </method>
      <method name="cancel" scope="prototype">
        <description>if no timeout is set or for other reason the user can put the button back
	to being idle</description>
      </method>
      <method name="resetTimeout" scope="prototype">
        <description>to reset existing timeout and setting a new timeout</description>
        <parameters>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="prototype">
        <description>reset the label (text) of the button; takes an HTML string</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="prototype">
        <description>on button click the button state gets changed
	only do something if button is not busy</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isBusy" scope="instance-prototype" type="Object"/>
      <property name="busyLabel" scope="instance-prototype" type="Object"/>
      <property name="timeout" scope="instance-prototype" type="Object"/>
      <property name="useIcon" scope="prototype" type="Object"/>
      <property name="_label" scope="instance" type="Object"/>
      <property name="_initTimeout" scope="instance" type="Object"/>
      <property name="_timeout" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="showLabel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.BusyButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem" superclass="dijit._Widget">
    <description>The individual items for a CheckedMultiSelect</description>
    <methods>
      <method name="postMixInProperties" scope="prototype">
        <description>Set the appropriate _subClass value - based on if we are multi-
	or single-select</description>
      </method>
      <method name="postCreate" scope="prototype">
        <description>Set innerHTML here - since the template gets messed up sometimes
	with rich text</description>
      </method>
      <method name="_changeBox" scope="prototype">
        <description>Called to force the select to match the state of the check box
	(only on click of the checkbox)  Radio-based calls _setValueAttr
	instead.</description>
      </method>
      <method name="_onMouse" scope="prototype">
        <description>Sets the hover state depending on mouse state (passes through
	to the check box)</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <description>Sets the click state (passes through to the check box)</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBox" scope="prototype">
        <description>Called to force the box to match the state of the select</description>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <description>Disables (or enables) all the children as well</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="parent" scope="prototype" type="Object"/>
      <property name="disabled" scope="instance-prototype" type="boolean">
        <description>Whether or not this widget is disabled</description>
      </property>
      <property name="_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.labelNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.option">
    <description>The option that is associated with this item</description>
    <properties>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.CheckedMultiSelect" superclass="dojox.form._FormSelectWidget">
    <description>Extends the core dijit MultiSelect to provide a &amp;quot;checkbox&amp;quot; selector</description>
    <methods>
      <method name="_mouseDown" scope="prototype">
        <description>Cancels the mousedown event to prevent others from stealing
	focus</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelection" scope="prototype"/>
      <method name="_getChildren" scope="prototype"/>
      <method name="invertSelection" scope="prototype">
        <description>Invert the selection</description>
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <description>If null, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <description>Disable (or enable) all the children as well</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <description>A validating, serializable, range-bound date text box with a popup calendar</description>
    <methods>
      <method name="_open" scope="prototype"/>
    </methods>
    <properties>
      <property name="popupClass" scope="prototype" type="Object"/>
      <property name="_selector" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox" superclass="dojox.form.DateTextBox">
    <description>A validating, serializable, range-bound date text box with a popup calendar that contains just months.</description>
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
    </methods>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <description>The popup widget to use. In this case, a calendar with just a Month view.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox._picker">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox" superclass="dojox.form.DateTextBox">
    <description>A validating, serializable, range-bound date text box with a popup calendar that contains just months.</description>
    <methods>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
    </methods>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <description>The popup widget to use. In this case, a calendar with just a Month view.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox._picker">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox" superclass="dojox.form.DateTextBox">
    <description>A validating, serializable, range-bound date text box with a popup calendar that contains only years</description>
    <methods>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
    </methods>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <description>The popup widget to use. In this case, a calendar with just a Year view.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox._picker">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownSelect" superclass="dojox.form._FormSelectWidget">
    <description>This is a &amp;quot;Styleable&amp;quot; select box - it is basically a DropDownButton which
	can take as its input a &amp;lt;select&amp;gt;.</description>
    <methods>
      <method name="_fillContent" scope="prototype">
        <description>Set the value to be the first, or the selected index</description>
      </method>
      <method name="_getMenuItemForOption" scope="prototype">
        <description>For the given option, return the menu item that should be
	used to display it.  This can be overridden as needed</description>
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <description>For the given option, add a option to our dropdown
	If the option doesn't have a value, then a separator is added
	in that place.</description>
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="prototype"/>
      <method name="_loadChildren" scope="prototype">
        <description>Resets the menu and the length attribute of the button - and
	ensures that the label is appropriately set.</description>
      </method>
      <method name="_setDisplay" scope="prototype">
        <description>sets the display for the given value (or values)</description>
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="prototype">
        <description>Called by oninit, onblur, and onkeypress.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype">
        <description>Whether or not this is a valid value</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>Overridden so that the state will be cleared.</description>
      </method>
      <method name="postMixInProperties" scope="prototype">
        <description>set the missing message</description>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_onMenuMouseup" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="prototype"/>
      <method name="loadDropDown" scope="prototype">
        <description>populates the menu</description>
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.form._HasDropDown" scope="prototype"/>
      <mixin type="dojox.form._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object">
        <description>Add in our style to be applied to the focus node</description>
      </property>
      <property name="required" scope="prototype" type="Boolean">
        <description>Can be true or false, default is false.</description>
      </property>
      <property name="state" scope="instance-prototype" type="String">
        <description>Shows current state (ie, validation result) of input (Normal, Warning, or Error)</description>
      </property>
      <property name="tooltipPosition" scope="prototype" type="String[]">
        <description>See description of dijit.Tooltip.defaultPosition for details on this parameter.</description>
      </property>
      <property name="emptyLabel" scope="prototype" type="string">
        <description>What to display in an &amp;quot;empty&amp;quot; dropdown</description>
      </property>
      <property name="_isLoaded" scope="instance-prototype" type="boolean">
        <description>Whether or not we have been loaded</description>
      </property>
      <property name="_childrenLoaded" scope="instance-prototype" type="boolean">
        <description>Whether or not our children have been loaded</description>
      </property>
      <property name="value" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_message" scope="instance" type="Object"/>
      <property name="_missingMsg" scope="instance" type="Object"/>
      <property name="_iReadOnly" scope="instance" type="Object"/>
      <property name="readOnly" scope="instance" type="Object"/>
      <property name="_iDisabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownSelect.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownSelect.options">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownStack" superclass="dojox.form.DropDownSelect">
    <description>A dropdown-based select stack.</description>
    <mixins scope="prototype">
      <mixin type="dojox.form._SelectStackMixin" scope="prototype"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.FileInput" superclass="dijit.form._FormWidget">
    <description>A styled input type=&amp;quot;file&amp;quot;</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>listen for changes on our real file input</description>
      </method>
      <method name="_matchValue" scope="prototype">
        <description>set the content of the upper input based on the semi-hidden file input</description>
      </method>
      <method name="setLabel" scope="prototype">
        <description>method to allow use to change button label</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="cssClass" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>on click of cancel button, since we can't clear the input because of
	security reasons, we destroy it, and add a new one in it's place.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="label" scope="prototype" type="Object"/>
      <property name="cancelText" scope="prototype" type="String">
        <description>the title of the &amp;quot;Cancel&amp;quot; button</description>
      </property>
      <property name="name" scope="prototype" type="String">
        <description>ugh, this should be pulled from this.domNode</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_listener" scope="instance" type="Object"/>
      <property name="_keyListener" scope="instance" type="Object"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.inputNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.cancelNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto" superclass="dojox.form.FileInput">
    <description>An extension on dojox.form.FileInput providing background upload progress</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>add our extra blur listeners</description>
      </method>
      <method name="_onFocus" scope="prototype">
        <description>clear the upload timer</description>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>start the upload timer</description>
      </method>
      <method name="setMessage" scope="prototype">
        <description>set the text of the progressbar
	innerHTML throws errors in IE! so use DOM manipulation instead
	this.overlay.innerHTML = title;</description>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_sendFile" scope="prototype">
        <description>triggers the chain of events needed to upload a file in the background.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleSend" scope="prototype">
        <description>The callback to toggle the progressbar, and fire the user-defined callback</description>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>accomodate our extra focusListeners</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="prototype">
        <description>stub function fired when an upload has finished.</description>
        <parameters>
          <parameter name="data" type="the" usage="required">
            <description>raw data found in the first [TEXTAREA] tag of the post url</description>
          </parameter>
          <parameter name="ioArgs" type="the" usage="required">
            <description>dojo.Deferred data being passed from the handle: callback</description>
          </parameter>
          <parameter name="widgetRef" type="this" usage="required">
            <description>widget pointer, so you can set this.overlay to a completed/error message easily</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="prototype" type="Object"/>
      <property name="blurDelay" scope="prototype" type="Integer">
        <description>time in ms before an un-focused widget will wait before uploading the file to the url=&amp;quot;&amp;quot; specified
	default: 2 seconds</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>The time in ms to use as the generic timing mechanism for the animations
	set to 1 or 0 for &amp;quot;immediate respose&amp;quot;</description>
      </property>
      <property name="uploadMessage" scope="prototype" type="String">
        <description>FIXME: i18n somehow?</description>
      </property>
      <property name="triggerEvent" scope="prototype" type="String">
        <description>Event which triggers the upload. Defaults to onblur, sending the file selected
	'blurDelay' milliseconds after losing focus. Set to &amp;quot;onchange&amp;quot; with a low blurDelay
	to send files immediately after uploading.</description>
      </property>
      <property name="_sent" scope="instance-prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_blurListener" scope="instance" type="Object"/>
      <property name="_focusListener" scope="instance" type="Object"/>
      <property name="_blurTimer" scope="instance" type="Object"/>
      <property name="_sending" scope="instance" type="Object"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.overlay.style">
    <properties>
      <property name="backgroundImage" scope="instance" type="Object"/>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fileInput.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fakeNodeHolder.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind" superclass="dojox.form.FileInputAuto">
    <description>An extended version of dojox.form.FileInputAuto
	that does not display an input node, but rather only a button
	and otherwise behaves just like FileInputAuto</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>hide our fileInput input field</description>
      </method>
      <method name="_fixPosition" scope="prototype">
        <description>in this case, set the button under where the visible button is</description>
      </method>
      <method name="reset" scope="prototype">
        <description>onclick, we need to reposition our newly created input type=&amp;quot;file&amp;quot;</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_off" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind.inputNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox" superclass="dijit.form.ValidationTextBox">
    <description>A validating text box tied to a file picker popup</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <description>sets the value of this widget</description>
        <parameters>
          <parameter name="value" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_onWidgetChange" scope="prototype">
        <description>called when the path gets changed in the dropdown</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="openDropDown" scope="prototype"/>
      <method name="toggleDropDown" scope="prototype"/>
      <method name="_focusBlur" scope="prototype">
        <description>called when the focus node gets blurred</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusFocus" scope="prototype">
        <description>called when the focus node gets focus</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>called when focus is shifted away from this widget</description>
      </method>
      <method name="_setBlurValue" scope="prototype">
        <description>sets the value of the widget once focus has left</description>
      </method>
      <method name="parse" scope="prototype">
        <description>Function to convert a formatted string to a value - we use
	it to verify that it *really* is a valid value</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchFromInput" scope="prototype">
        <description>kicks off a search based off the current text value of the widget</description>
      </method>
      <method name="_onKey" scope="prototype">
        <description>callback when the user presses a key on menu popup node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.form._HasDropDown" scope="prototype"/>
      <mixin type="dojox.form._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="searchDelay" scope="prototype" type="Integer">
        <description>Delay in milliseconds between when user types something and we start
	searching based on that value</description>
      </property>
      <property name="_stopClickEvents" scope="prototype" type="Object"/>
      <property name="valueItem" scope="instance-prototype" type="item">
        <description>The item, in our store, of the directory relating to our value</description>
      </property>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_skip" scope="instance" type="Object"/>
      <property name="_hasValidPath" scope="instance" type="Object"/>
      <property name="_menuFocus" scope="instance" type="Object"/>
      <property name="_allowBlur" scope="instance" type="Object"/>
      <property name="_hasSelection" scope="instance" type="Object"/>
      <property name="_searchInProgress" scope="instance" type="Object"/>
      <property name="_searchTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.dropDown.domNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputFlash">
    <methods>
      <method name="onChange" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upload" scope="prototype"/>
      <method name="_error" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_openDialog" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_change" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="prototype">
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyAll" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="uploadUrl" scope="instance-prototype" type="String">
        <description>*/
	The Url the file will be uploaded</description>
      </property>
      <property name="button" scope="instance-prototype" type="dijit.form.Button">
        <description>or a domNode */
	REQUIRED: The button that when clicked, launches the Flash Upload dialog</description>
      </property>
      <property name="uploadOnChange" scope="instance-prototype" type="Boolean">
        <description>*/
	if true, begins upload immediately
	leave false if you wish to display the text of the selection
	and present an &amp;quot;upload&amp;quot; button</description>
      </property>
      <property name="selectMultipleFiles" scope="instance-prototype" type="fieldName:">
        <description>/* String */
	The form field attribute. This will be needed by the server to get the value.
	If using the ReceiveFile.php test, leave this as-is.
	TODO:fieldName:&amp;quot;uploadedfile&amp;quot;,
	Boolean */
	Option to restrict to single-file upload, or allow
	multi-file uploader</description>
      </property>
      <property name="fileMask" scope="instance-prototype" type="Array[">
        <description>Array[Description, FileTypes], Array[...]...] */
	(an array, or an array of arrays)
	Restrict file selection to certain file types
	Empty array defaults to &amp;quot;All Files&amp;quot;
	Usage:
	fileMask = [&amp;quot;Images&amp;quot;, &amp;quot;*.jpg;*.jpeg;*.gif;*.png&amp;quot;]
	or
	fileMask = [
	[&amp;quot;Jpeg File&amp;quot;, 	&amp;quot;*.jpg;*.jpeg&amp;quot;],
	[&amp;quot;GIF File&amp;quot;, 	&amp;quot;*.gif&amp;quot;],
	[&amp;quot;PNG File&amp;quot;, 	&amp;quot;*.png&amp;quot;],
	[&amp;quot;All Images&amp;quot;, 	&amp;quot;*.jpg;*.jpeg;*.gif;*.png&amp;quot;],
	]
	NOTE: MacType is not supported, as it does not work very well.
	fileMask will work on a Mac, but differently than
	Windows. The second example above in Windows will mask
	All but the selected file type, shown in a drop-down at
	the bottom of the system dialog. In Mac, all types in
	all arrays will be shown and non-types masked.</description>
      </property>
      <property name="flashMovie" scope="instance-prototype" type="Object"/>
      <property name="flashDiv" scope="instance-prototype" type="Object"/>
      <property name="fileList" scope="instance" type="Object"/>
      <property name="_subs" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputFlash.flashObject">
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputOverlay">
    <description>Handles the basic tasks of a fileInput...
	Does NOT create a button, it transparently overlays a button passed to it.
	This can be used for toolbar buttons for example.
	Handles the file upload. Use an example PHP script included in resources.
	NOTE:
	This looks like it is duplicating efforts of the other FileInput files,
	but its actually seperating the lower-level functionality, and allowing
	for custom buttons.
	LIMITATIONS:
	Because of the nature of this &amp;quot;hack&amp;quot; - floating a zero-opacity fileInput
	over a &amp;quot;fake&amp;quot; button - this won't work in all circumstances. For instance
	you couldn't put a fileInput in a scrolling div. Some complicated CSS can
	mess up the placement - or for that matter, some simple, but not expected
	CSS can mess up the placement. Being near the botton of a complex document
	can throw off the positioning.
	OPERA USERS:
	Not much love from Opera on FileInput hacks.
	ALSO:
	Only works programmatically. Does not work in markup. Use the other
	other FileInput files for markup solutions.
	USAGE:
	this.fileInput = new dojox.form.FileInputOverlay({button:this.button, uploadUrl:this.uploadUrl, uploadOnChange:true});
	dojo.connect(this.fileInput, &amp;quot;onChange&amp;quot;, this, &amp;quot;handleChange&amp;quot;);
	dojo.connect(this.fileInput, &amp;quot;onComplete&amp;quot;, this, &amp;quot;onComplete&amp;quot;);</description>
    <methods>
      <method name="onChange" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="prototype">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upload" scope="prototype"/>
      <method name="createFileInput" scope="prototype"/>
      <method name="setPosition" scope="prototype"/>
      <method name="_getFakeButtonSize" scope="prototype"/>
      <method name="_buildFileInput" scope="prototype">
        <parameters>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeFileInput" scope="prototype"/>
      <method name="_buildForm" scope="prototype">
        <parameters>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectInput" scope="prototype"/>
      <method name="_disconnectInput" scope="prototype"/>
      <method name="_setFormStyle" scope="prototype"/>
      <method name="onMouseOver" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyAll" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="_fileInput" scope="instance-prototype" type="node">
        <description>*/
	the form node (do not set)</description>
      </property>
      <property name="uploadUrl" scope="instance-prototype" type="String">
        <description>*/
	The Url the file will be uploaded</description>
      </property>
      <property name="uploadOnChange" scope="instance-prototype" type="Boolean">
        <description>*/
	if true, begins upload immediately
	leave false if you wish to display the text of the selection
	and present an &amp;quot;upload&amp;quot; button</description>
      </property>
      <property name="fieldName" scope="prototype" type="String">
        <description>*/
	The form field attribute. This will be needed by the server to get the value.
	If using the ReceiveFile.php test, leave this as-is.</description>
      </property>
      <property name="id" scope="instance-prototype" type="String">
        <description>*/
	The attribute of the form field. Also accesses this object.</description>
      </property>
      <property name="selectMultipleFiles" scope="instance-prototype" type="Object"/>
      <property name="fileInputs" scope="instance" type="Object"/>
      <property name="fileCount" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputOverlay.button">
    <description>or a domNode */
	REQUIRED: The button that will get the FileInput overlay</description>
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputOverlay._fileInput.style">
    <properties>
      <property name="clip" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputOverlay._formNode">
    <properties>
      <property name="encoding" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader">
    <description>Handles File Uploading to a server (PHP script included for testing)
	Does *NOT* create a button, it transforms a button into an uploader.
	This can be used for toolbar buttons for example.
	FileUploader is a wrapper class. If the correct version of Flash
	Player is available, FileInputFlash is used. If degradable is true,
	and Flash Player is not installed or is outdated, FileInputOverlay
	is used.
	arguments:</description>
    <properties>
      <property name="degradable" scope="instance" type="Boolean">
        <description>*/
	If true, will check if user has the correct version of the
	Flash Player installed, and if not, will cancel FileInputFlash
	and install FileInputOverlay instead.
	If false and user does not have the correct version of Flash,
	(or if user has Opera) FileInputFlash will install regardless,
	hopefully triggering the browser update mechanism.</description>
      </property>
      <property name="uploadUrl" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.MultiComboBox" superclass="dijit.form.ValidationTextBox">
    <description>A ComboBox that accpets multiple inputs on a single line?</description>
    <methods>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addPreviousMatches" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanupDelimiters" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_autoCompleteText" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit.form.ComboBoxMixin" scope="prototype"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="delimiter" scope="prototype" type="String">
        <description>The character to use to separate items in the ComboBox input</description>
      </property>
      <property name="_previousMatches" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._ChildTextBox" superclass="dijit.form.ValidationTextBox">
    <description>A class that is shared between all our children - extends
	ValidationTextBox and provides some shared functionality</description>
    <methods>
      <method name="reset" scope="prototype">
        <description>Force-set to empty string (we don't save passwords EVER)...and
	since _OldPWBox overrides _setValueAttr to check for empty string,
	call our parent class directly (not this.inherited())</description>
      </method>
    </methods>
    <properties>
      <property name="containerWidget" scope="prototype" type="widget">
        <description>Our parent (the PasswordValidator)</description>
      </property>
      <property name="type" scope="prototype" type="string">
        <description>Don't override this - we are all &amp;quot;password&amp;quot; types</description>
      </property>
      <property name="_hasBeenBlurred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._OldPWBox" superclass="dojox.form._ChildTextBox">
    <description>A class representing our &amp;quot;old password&amp;quot; box.</description>
    <methods>
      <method name="_setValueAttr" scope="prototype">
        <description>Updates _isPWValid if this isn't our initial update by calling
	our PasswordValidator's pwCheck function</description>
        <parameters>
          <parameter name="newVal" type="anything" usage="required"/>
          <parameter name="priority" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype"/>
    </methods>
    <properties>
      <property name="_isPWValid" scope="instance-prototype" type="boolean">
        <description>Whether or not the password is valid</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._NewPWBox" superclass="dojox.form._ChildTextBox">
    <description>A class representing our new password textbox</description>
    <methods>
      <method name="onChange" scope="prototype">
        <description>Validates our verify box - to make sure that a change to me is
	reflected there</description>
      </method>
    </methods>
    <properties>
      <property name="required" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._VerifyPWBox" superclass="dojox.form._ChildTextBox">
    <description>A class representing our verify textbox</description>
    <methods>
      <method name="isValid" scope="prototype">
        <description>Validates that we match the &amp;quot;real&amp;quot; password</description>
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.PasswordValidator" superclass="dijit.form._FormValueWidget">
    <description>A password validation widget that simplifies the &amp;quot;old/new/verify&amp;quot;
	style of requesting passwords.  You will probably want to override
	this class and implement your own pwCheck function.</description>
    <methods>
      <method name="isValid" scope="prototype">
        <description>we are valid if ALL our children are valid</description>
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="prototype">
        <description>Validating this widget validates all our children</description>
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>Resetting this widget resets all our children</description>
      </method>
      <method name="_createSubWidgets" scope="prototype">
        <description>Turns the inputs inside this widget into &amp;quot;real&amp;quot; validation
	widgets - and sets up the needed connections.</description>
      </method>
      <method name="pwCheck" scope="prototype">
        <description>Overridable function for validation of the old password box.
	This function is called and passed the old password.  Return
	true if it's OK to continue, and false if it is not.
	IMPORTANT SECURITY NOTE:  Do NOT EVER EVER EVER check this in
	HTML or JavaScript!!!
	You will probably want to override this function to callback
	to a server to verify the password (the callback will need to
	be syncronous) - and it's probably a good idea to validate
	it again on form submission before actually doing
	anything destructive - that's why the &amp;quot;oldName&amp;quot; value
	is available.
	And don't just fetch the password from the server
	either :)  Send the test password (probably hashed, for
	security) and return from the server a status instead.
	Again - DON'T BE INSECURE!!!  Security is left as an exercise
	for the reader :)</description>
        <parameters>
          <parameter name="password" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype">
        <description>Sets up the correct widgets.  You *MUST* specify one child
	text box (a simple HTML &amp;lt;input&amp;gt; element) with pwType=&amp;quot;new&amp;quot;
	*and* one child text box with pwType=&amp;quot;verify&amp;quot;.  You *MAY*
	specify a third child text box with pwType=&amp;quot;old&amp;quot; in order to
	prompt the user to enter in their old password before the
	widget returns that it is valid.</description>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttribute" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype"/>
      <method name="focus" scope="prototype">
        <description>places focus on the first invalid input widget - if all
	input widgets are valid, the first widget is focused.</description>
      </method>
    </methods>
    <properties>
      <property name="required" scope="instance-prototype" type="boolean">
        <description>Whether or not it is required for form submission</description>
      </property>
      <property name="_inputWidgets" scope="instance-prototype" type="Object"/>
      <property name="oldName" scope="prototype" type="string?">
        <description>The name to send our old password as (when form is posted)</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.RadioStack" superclass="dojox.form.CheckedMultiSelect">
    <description>A radio-based select stack.</description>
    <mixins scope="prototype">
      <mixin type="dojox.form._SelectStackMixin" scope="prototype"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._RangeSliderMixin">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClickMax" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="prototype"/>
      <method name="_bumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRemainingBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
          <parameter name="isMaxVal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueByPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Array or Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
          <parameter name="isMaxVal" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="_printSliderBar" scope="prototype">
        <parameters>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="isMaxVal" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="value" scope="prototype" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="_movableMax" scope="instance" type="Object"/>
      <property name="_movableBar" scope="instance" type="Object"/>
      <property name="_descending" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._RangeSliderMixin.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMoverMax" superclass="dijit.form._SliderMover">
    <methods>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form._SliderBarMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.HorizontalRangeSlider" superclass="dijit.form.HorizontalSlider">
    <mixins scope="prototype">
      <mixin type="dojox.form._RangeSliderMixin" scope="prototype"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.VerticalRangeSlider" superclass="dijit.form.VerticalSlider">
    <mixins scope="prototype">
      <mixin type="dojox.form._RangeSliderMixin" scope="prototype"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Rating" superclass="dijit.form._FormWidget">
    <description>A widget for rating using stars.
	required: Boolean
	TODO: Can be true or false, default is false.
	required: false,</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_onMouse" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStars" scope="prototype">
        <description>Render the stars depending on the value.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="hover" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>Connect here, the value is passed to this function as the second parameter!</description>
      </method>
      <method name="setAttribute" scope="prototype">
        <description>When calling setAttribute(&amp;quot;value&amp;quot;, 4), set the value and render the stars accordingly.</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="numStars" scope="prototype" type="Integer/Float">
        <description>The number of stars to show, default is 3.</description>
      </property>
      <property name="value" scope="prototype" type="Integer/Float">
        <description>The current value of the Rating</description>
      </property>
      <property name="constructor" scope="prototype" type="Object"/>
      <property name="onStarClick" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.TimeSpinner" superclass="dijit.form._Spinner">
    <description>Time Spinner</description>
    <methods>
      <method name="adjust" scope="prototype">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype"/>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="required" scope="prototype" type="Object"/>
      <property name="smallDelta" scope="prototype" type="Object"/>
      <property name="largeDelta" scope="prototype" type="Object"/>
      <property name="timeoutChangeRate" scope="prototype" type="Object"/>
      <property name="serialize" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._FormSelectWidget" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="getOptions" scope="prototype">
        <description>Returns a given option (or options).</description>
        <parameters>
          <parameter name="valueOrIdx" type="anything" usage="required">
            <description>If passed in as a string, that string is used to look up the option
	in the array of options - based on the value property.
	(See dojox.form.__SelectOption).
	If passed in a number, then the option with the given index (0-based)
	within this select will be returned.
	If passed in a dojox.form.__SelectOption, the same option will be
	returned if and only if it exists within this select.
	If passed an array, then an array will be returned with each element
	in the array being looked up.
	If not passed a value, then all options will be returned</description>
          </parameter>
        </parameters>
        <return-description>The option corresponding with the given value or index.  null
	is returned if any of the following are true:
	- A string value is passed in which doesn't exist
	- An index is passed in which is outside the bounds of the array of options
	- A dojox.form.__SelectOption is passed in which is not a part of the select
	NOTE: the compare for passing in a dojox.form.__SelectOption checks
	if the value property matches - NOT if the exact option exists
	NOTE: if passing in an array, null elements will be placed in the returned
	array when a value is not found.</return-description>
        <return-types>
          <return-type type="dojox.form.__SelectOption[]"/>
          <return-type type="dojox.form.__SelectOption"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="addOption" scope="prototype">
        <description>Adds an option or options to the end of the select.  If value
	of the option is empty or missing, a separator is created instead.
	Passing in an array of options will yeild slightly better performance
	since the children are only loaded once.</description>
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption, dojox.form.__SelectOption[]" usage="required"/>
        </parameters>
      </method>
      <method name="removeOption" scope="prototype">
        <description>Removes the given option or options.  You can remove by string
	(in which case the value is removed), number (in which case the
	index in the options array is removed), or select option (in
	which case, the select option with a matching value is removed).
	You can also pass in an array of those values for a slightly
	better performance since the children are only loaded once.</description>
        <parameters>
          <parameter name="valueOrIdx" type="string, dojox.form.__SelectOption, number, or array" usage="required"/>
        </parameters>
      </method>
      <method name="updateOption" scope="prototype">
        <description>Updates the values of the given option.  The option to update
	is matched based on the value of the entered option.  Passing
	in an array of new options will yeild better performance since
	the children will only be loaded once.</description>
        <parameters>
          <parameter name="newOption" type="dojox.form.__SelectOption, dojox.form.__SelectOption[]" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>set the value of the widget.
	If a string is passed, then we set our value from looking it up.</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean, optional" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>get the value of the widget.</description>
      </method>
      <method name="undo" scope="prototype">
        <description>restore the value to the last value passed to onChange</description>
      </method>
      <method name="_loadChildren" scope="prototype">
        <description>Loads the children represented by this widget's optiosn.
	reset the menu to make it &amp;quot;populatable on the next click</description>
      </method>
      <method name="_updateSelection" scope="prototype">
        <description>Sets the &amp;quot;selected&amp;quot; class on the item for styling purposes</description>
      </method>
      <method name="_getValueFromOpts" scope="prototype">
        <description>Returns the value of the widget by reading the options for
	the selected flag</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_fillContent" scope="prototype">
        <description>Loads our options and sets up our dropdown correctly.  We
	don't want any content, so we don't call any inherit chain
	function.</description>
      </method>
      <method name="postCreate" scope="prototype">
        <description>sets up our event handling that we need for functioning
	as a select</description>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <description>User-overridable function which, for the given option, adds an
	item to the select.  If the option doesn't have a value, then a
	separator is added in that place.  Make sure to store the option
	in the created option widget.</description>
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_removeOptionItem" scope="prototype">
        <description>User-overridable function which, for the given option, removes
	its item from the select.</description>
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="prototype">
        <description>Overridable function which will set the display for the
	widget.  newDisplay is either a string (in the case of
	single selects) or array of strings (in the case of multi-
	selects)</description>
        <parameters>
          <parameter name="newDisplay" type="String or String[]" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="prototype">
        <description>Overridable function to return the children that this widget
	contains.</description>
      </method>
      <method name="_getSelectedOptionsAttr" scope="prototype">
        <description>hooks into this.attr to provide a mechanism for getting the
	option items for the current value of the widget.</description>
      </method>
    </methods>
    <properties>
      <property name="multiple" scope="prototype" type="Boolean">
        <description>Matches the select's &amp;quot;multiple=&amp;quot; value</description>
      </property>
      <property name="_multiValue" scope="instance-prototype" type="Boolean">
        <description>Whether or not we are multi-valued (for form)</description>
      </property>
      <property name="_getValueDeprecated" scope="prototype" type="Object"/>
      <property name="options" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._HasDropDown">
    <description>Mixin for widgets that need drop down ability.</description>
    <methods>
      <method name="_onMenuMouseup" scope="prototype">
        <description>called with the mouseup event if the mouseup occurred
	over the menu.  You can try and use this event in
	order to automatically execute your dropdown (as
	if it were clicked).  You mightwant to close your menu
	as a part of this function.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouse" scope="prototype">
        <description>callback when the user mouse clicks on menu popup node
	We handle mouse events using onmousedown in order to allow for
	selecting via a drag.  So, our click is already handled, unless
	we are executed via keypress - in which case, this._seenKeydown
	will be set to true.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseup" scope="prototype">
        <description>callback when the user lifts their mouse - if we are
	over the menu, we execute it, otherwise, we focus our
	dropDown node.  If the event is missing, then we are not
	a mouseup event.</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupDropdown" scope="prototype">
        <description>set up nodes and connect our mouse and keypress events</description>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="destroyDescendants" scope="prototype"/>
      <method name="_onDropDownKeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <description>callback when the user presses a key on menu popup node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <description>called magically when focus has shifted away from this widget and it's dropdown</description>
      </method>
      <method name="isLoaded" scope="prototype">
        <description>returns whether or not the dropdown is loaded.  This can
	be overridden in order to force a call to loadDropDown().</description>
      </method>
      <method name="loadDropDown" scope="prototype">
        <description>loads the data for the dropdown, and at some point, calls
	the given callback</description>
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="toggleDropDown" scope="prototype">
        <description>toggle the drop-down widget; if it is up, close it, if not, open it</description>
      </method>
      <method name="openDropDown" scope="prototype">
        <description>opens the dropdown for this widget - it returns the
	return value of dijit.popup.open</description>
      </method>
      <method name="closeDropDown" scope="prototype">
        <description>Closes the drop down on this widget</description>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dropDownNode" scope="instance-prototype" type="DomNode">
        <description>responds to click events.  &amp;quot;dropDownNode&amp;quot; can be set via
	a dojoAttachPoint assignment.  If missing, then either focusNode
	or domNode (if focusNode is also missing) will be used.</description>
      </property>
      <property name="popupStateNode" scope="instance-prototype" type="DomNode">
        <description>the node to set the popupActive class on.  If missing, then
	focusNode or dropDownNode (if focusNode is missing) will be used.</description>
      </property>
      <property name="aroundNode" scope="instance-prototype" type="DomNode">
        <description>the node to display the popup around.  If missing, then
	domNode will be used.</description>
      </property>
      <property name="dropDown" scope="prototype" type="Widget">
        <description>the widget to display in the popup.  This widget *must* be
	defined before the startup function is called.</description>
      </property>
      <property name="autoWidth" scope="prototype" type="Boolean">
        <description>Set to true to make the drop down at least as wide as this
	widget.  Set to false if the drop down should just be its
	default width</description>
      </property>
      <property name="_stopClickEvents" scope="prototype" type="Boolean">
        <description>When set to false, the click events will not be stopped, in
	case you want to use them in your subwidget</description>
      </property>
      <property name="_seenKeydown" scope="instance" type="Object"/>
      <property name="_docHandler" scope="instance" type="Object"/>
      <property name="_opened" scope="instance" type="Object"/>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._SelectStackMixin">
    <description>Mix this class in to a dojox.form._FormSelectWidget in order to
	provide support for &amp;quot;selectable&amp;quot; multiforms.  The widget is pointed
	to a dijit.layout.StackContainer and will handle displaying and
	submitting the values of only the appropriate pane.
	The options for this widget will be automatically set - based on
	the panes that are in the stack container.  The &amp;quot;title&amp;quot; attribute of
	the pane will be used for the display of the option.  The &amp;quot;id&amp;quot; attribute
	of the pane will be used as the value of the option.  In order to
	avoid running into unique ID constraint issues, a stackPrefix mechanism
	is provided.</description>
    <methods>
      <method name="_paneIdFromOption" scope="prototype">
        <description>Gets the pane ID given an option value</description>
        <parameters>
          <parameter name="oVal" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_optionValFromPane" scope="prototype">
        <description>Gets the option value given a pane ID</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_togglePane" scope="prototype">
        <description>called when a pane is either shown or hidden (so that
	we can toggle the widgets on it)</description>
        <parameters>
          <parameter name="pane" type="Widget" usage="required"/>
          <parameter name="shown" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="prototype">
        <description>Called when the stack container adds a new pane</description>
        <parameters>
          <parameter name="pane" type="Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="prototype">
        <description>Called when the stack container removes a pane</description>
        <parameters>
          <parameter name="pane" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="prototype">
        <description>Called when the stack container selects a new pane</description>
        <parameters>
          <parameter name="pane" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="prototype">
        <description>Called when the stack container is started up</description>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="onChange" scope="prototype">
        <description>Called when form select widget's value has changed</description>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="stackId" scope="prototype" type="Object"/>
      <property name="stackPrefix" scope="prototype" type="string">
        <description>A prefix to remove from our stack pane ids when setting our options.
	This exists so that we won't run into unique ID constraints.  For
	example, if stackPrefix is set to &amp;quot;foo_&amp;quot;, and there are three panes
	in our stack with ids of &amp;quot;foo_a&amp;quot;, &amp;quot;foo_b&amp;quot;, and &amp;quot;foo_c&amp;quot;, then the values
	of the options created for the stack controller widget will be &amp;quot;a&amp;quot;,
	&amp;quot;b&amp;quot;, and &amp;quot;c&amp;quot;.  This allows you to have multiple select stack widgets
	with the same values - without having to have the panes require the
	same ids.</description>
      </property>
      <property name="_savedValue" scope="instance" type="Object"/>
      <property name="_panes" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx">
    <description>Extension animations to the core dojo FX project</description>
    <methods>
      <method name="sizeTo" scope="instance">
        <description>Creates an animation that will size a node</description>
        <example>
		// size #myNode to 400px x 200px over 1 second
		dojo.fx.sizeTo({
			node:'myNode',
			duration: 1000,
			width: 400,
			height: 200,
			method: "combine"
		}).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <description>Returns an animation to slide a node by a defined offset.</description>
        <example>
		// slide domNode 50px down, and 22px left
		dojox.fx.slideBy({
			node: domNode, duration:400,
			top: 50, left: -22
		}).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="crossFade" scope="instance">
        <description>Returns an animation cross fading two element simultaneously</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.nodes Array - two element array of domNodes, or id's
	all other standard animation args mixins apply. args.node ignored.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <description>Highlight a node</description>
        <example>dojox.fx.highlight({ node:"foo" }).play();</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="wipeTo" scope="instance">
        <description>Animate a node wiping to a specific width or height</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <description>Animate a node flipping following a specific direction</description>
        <example>
		var anim = dojox.fx.flip({
			node: dojo.byId("nodeId"),
			dir: "top",
			darkColor: "#555555",
			lightColor: "#dddddd",
			endColor: "#666666",
			duration:300
		  });</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="flipCube" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a more 3d-like rotation</description>
        <example>See `dojox.fx.flip`</example>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="smoothScroll" scope="instance">
        <description>Returns an animation that will smooth-scroll to a node (specified in etup())</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_split" scope="instance">
        <description>Split a node into rectangular pieces and animate them.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop Boolean - If true, pieces will only be visible inside node's boundries
	args.rows: Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.pieceAnimation: Function(piece, x, y, coords) - Returns either the dojo._Animation
	or an array of dojo._Animation objects for the piece at location (x, y) in the node's grid;
	coords is the result of dojo.coords(args.node, true);</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Explode a node into rectangular pieces</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions.  The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Split a node into rectangular pieces and let them fall</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced.
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shear" scope="instance">
        <description>Split a node into rectangular pieces and slide them in alternating directions</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows Integer - The number of horizontal pieces (default is 6)
	args.columns: Integer - The number of vertical pieces (default is 6)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The multiple of the node's dimensions to slide (default is 1)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="unShear" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pinwheel" scope="instance">
        <description>Split a node into rectangular pieces and wipe them in alternating directions</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows Integer - The number of horizontal pieces (default is 4)
	args.columns: Integer - The number of vertical pieces (default is 4)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The percentage of the piece's dimensions the piece should wipe
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced.
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="unPinwheel" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Split a node into rectangular pieces and fade them</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="anim" scope="instance" type="Object"/>
      <property name="animateProperty" scope="instance" type="Object"/>
      <property name="fadeTo" scope="instance" type="Object"/>
      <property name="fadeIn" scope="instance" type="Object"/>
      <property name="fadeOut" scope="instance" type="Object"/>
      <property name="combine" scope="instance" type="Object"/>
      <property name="chain" scope="instance" type="Object"/>
      <property name="slideTo" scope="instance" type="Object"/>
      <property name="wipeIn" scope="instance" type="Object"/>
      <property name="wipeOut" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="_core" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scroll" scope="instance" type="Object">
        <description>Module to provide scroll-related FX</description>
      </property>
      <property name="split" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object">
        <description>Module to provide CSS animations</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx.Shadow" superclass="dijit._Widget">
    <description>Adds a drop-shadow to a node.</description>
    <example>
		// add drop shadows to all nodes with class="hasShadow"
		dojo.query(".hasShadow").forEach(function(n){
			var foo = new dojox.fx.Shadow({ node: n });
			foo.startup();
		});</example>
    <methods>
      <method name="startup" scope="prototype">
        <description>Initializes the shadow.</description>
      </method>
      <method name="_makePiece" scope="prototype">
        <description>append a shadow pieces to the node, and position it</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="vertAttach" type="Object" usage="required"/>
          <parameter name="vertCoord" type="Object" usage="required"/>
          <parameter name="horzAttach" type="Object" usage="required"/>
          <parameter name="horzCoord" type="Object" usage="required"/>
          <parameter name="sizing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpacity" scope="prototype">
        <description>set the opacity of the underlay
	note: does not work in IE? FIXME.</description>
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
          <parameter name="animArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <description>enable / disable the shadow</description>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <description>Resizes the shadow based on width and height.</description>
        <parameters>
          <parameter name="args" type="dojox.fx._arg.ShadowResizeArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="shadowPng" scope="prototype" type="String">
        <description>Base location for drop-shadow images</description>
      </property>
      <property name="shadowThickness" scope="prototype" type="Integer">
        <description>How wide (in px) to make the shadow</description>
      </property>
      <property name="shadowOffset" scope="prototype" type="Integer">
        <description>How deep to make the shadow appear to be</description>
      </property>
      <property name="opacity" scope="prototype" type="Float">
        <description>Overall opacity of the shadow</description>
      </property>
      <property name="animate" scope="prototype" type="Boolean">
        <description>A toggle to disable animated transitions</description>
      </property>
      <property name="node" scope="prototype" type="Object"/>
      <property name="pieces" scope="instance" type="Object"/>
      <property name="nodeList" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx.Shadow.node.style">
    <properties>
      <property name="position" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="animArgs">
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._arg"/>
  <class type="dojox.fx._arg.StyleArgs">
    <description>The node and CSS class to use for style manipulations.</description>
    <properties>
      <property name="node" scope="instance" type="DOMNode">
        <description>The node to manipulate</description>
      </property>
      <property name="cssClass" scope="instance" type="String">
        <description>The class to use during the manipulation</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx._arg.ShadowResizeArgs">
    <description>The odd way to document object parameters.</description>
    <properties>
      <property name="x" scope="instance" type="Integer">
        <description>the width to set</description>
      </property>
      <property name="y" scope="instance" type="Integer">
        <description>the height to set</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx._Line">
    <description>a custom _Line to accomodate multi-dimensional values</description>
    <example>see dojox.fx.smoothScroll</example>
    <methods>
      <method name="getValue" scope="instance">
        <description>Returns the point on the line, or an array of points</description>
        <parameters>
          <parameter name="n" type="float" usage="required">
            <description>a floating point number greater than 0 and less than 1</description>
          </parameter>
        </parameters>
        <return-description>Mixed</return-description>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Integer|Array">
        <description>An Integer (or an Array of integers) to use as a starting point</description>
      </property>
      <property name="end" scope="instance" type="Integer|Array">
        <description>An Integer (or an Array of integers) to use as an ending point</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx.ext-dojo">
    <properties>
      <property name="NodeList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="hs">
    <mixins scope="normal">
      <mixin type="staticProps" scope="instance"/>
    </mixins>
    <properties>
      <property name="position" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="zIndex" scope="instance" type="Object"/>
      <property name="border" scope="instance" type="Object"/>
      <property name="fontSize" scope="instance" type="Object"/>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.top">
    <properties>
      <property name="pName" scope="instance" type="Object"/>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.top.args">
    <properties>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.right">
    <properties>
      <property name="pName" scope="instance" type="Object"/>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.right.args">
    <properties>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.bottom">
    <properties>
      <property name="pName" scope="instance" type="Object"/>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.bottom.args">
    <properties>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.left">
    <properties>
      <property name="pName" scope="instance" type="Object"/>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dims.left.args">
    <properties>
      <property name="whichAnim" scope="instance" type="Object"/>
      <property name="dir" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx.text">
    <methods>
      <method name="_split" scope="instance">
        <description>Split a block of text into words or letters</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.text: String - Text to place inside the node (otherwise node.innerHTML is used)
	args.words: Boolean - If true, the text will be split into words rather than characters
	args.pieceAnimation: Function(piece, pieceCoords, nodeCoords, number, numPieces)
	- Returns either the dojo._Animation or an array of dojo._Animation objects for the piece;
	pieceCoords is the result of dojo.coords(piece, true);
	nodeCoords is the result of dojo.coords(args.node, true);
	number is the piece's position in the array of pieces, and numPieces is the array.length</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Explode a block of text into words or letters</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions. The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Split a block of text into words or letters and let them fall</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Split a block of text into words or letters and fade them</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.words Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="backspace" scope="instance">
        <description>Split a block of text into words or letters and backspace them in sequence</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.interval Float - The number of milliseconds between each piece's animation
	(default is determined by text length and args.duration);
	args.wordDelay: Integer - The number of milliseconds between each word
	(only effective when args.unhide = true)
	args.fixed: Boolean - If true, only style.opacity changes; otherwise, style.display
	changes between none and inline, adding realism (default = false)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced (only effective when args.unhide = true)
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="type" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx">
    <description>Cross-browser vector graphics API</description>
    <methods>
      <method name="getVectorFont" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeColor" scope="instance">
        <description>converts any legal color representation to normalized dojo.Color object</description>
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <description>updates an existing object with properties from an &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the &amp;quot;update&amp;quot; object, whose properties will be used to update the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <description>copies the original object, and all copied properties from the &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <description>converts a number to a string using a fixed notation</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>	number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="optional">
            <description>if it is true, add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <description>converts a font object to a CSS font string</description>
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>converts a CSS font string to a font object</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <description>returns a number of pixels per point</description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <description>converts points to pixels</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <description>converts pixels to points</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizedLength" scope="instance">
        <description>converts any length value to pixels</description>
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., &amp;quot;12pc&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <description>compares event sources, returns true if they are equal</description>
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachNode" scope="instance">
        <description>creates a shape from a Node</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="for now"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="decompose" scope="instance">
        <description>decompose a 2D matrix into translation, scaling, and rotation components</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <description>creates a surface (VML)</description>
        <parameters>
          <parameter name="parentNode" type="Node" usage="required">
            <description>a parent node</description>
          </parameter>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <description>creates a surface from a Node</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_vectorFontCache" scope="instance" type="Object"/>
      <property name="_svgFontCache" scope="instance" type="Object"/>
      <property name="VectorText" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Object"/>
      <property name="mm_in_pt" scope="instance" type="Object"/>
      <property name="pathVmlRegExp" scope="instance" type="Object"/>
      <property name="pathSvgRegExp" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="attach" scope="instance" type="Object"/>
      <property name="canvas" scope="instance" type="Object"/>
      <property name="canvas_attach" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object"/>
      <property name="Matrix2D" scope="instance" type="Object"/>
      <property name="move" scope="instance" type="Object"/>
      <property name="silverlight_attach" scope="instance" type="Object"/>
      <property name="svg_attach" scope="instance" type="Object"/>
      <property name="utils" scope="instance" type="Object"/>
      <property name="vml_attach" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Moveable">
    <description>an object, which makes a shape moveable</description>
    <methods>
      <method name="destroy" scope="prototype">
        <description>stops watching for possible move, deletes all references, so the object can be garbage-collected</description>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown, creates a Mover for the shape</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove, used only for delayed drags</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup, used only for delayed delayed drags</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMoveStart" scope="prototype">
        <description>called before every move operation</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <description>called after every move operation</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <description>called during the very first move notification,
	can be used to initialize coordinates, can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <description>called during every move notification,
	should actually move the node, can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="prototype">
        <description>called before every incremental move,
	can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="prototype">
        <description>called after every incremental move,
	can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="events" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="dojox.gfx.Shape">
        <description>a shape object to be moved</description>
      </property>
      <property name="delay" scope="instance" type="Number">
        <description>delay move by this number of pixels</description>
      </property>
      <property name="mover" scope="instance" type="Object">
        <description>a constructor of custom Mover</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.Mover">
    <description>an object, which makes a shape follow the mouse,
	used as a default mover, and as a base class for custom movers</description>
    <methods>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <description>it is meant to be called only once</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>stops the move, deletes all references, so the object can be garbage-collected</description>
      </method>
    </methods>
    <properties>
      <property name="lastX" scope="instance" type="Object"/>
      <property name="lastY" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="dojox.gfx.Shape">
        <description>a shape object to be moved</description>
      </property>
      <property name="host" scope="instance" type="Object?">
        <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont">
    <description>Create this font object based on the SVG Font definition at url.</description>
    <methods>
      <method name="_decodeEntitySequence" scope="prototype">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parse" scope="prototype">
        <description>Take the loaded SVG Font definition file and convert the info
	into things we can use. The SVG Font definition must follow
	the SVG 1.1 Font specification.</description>
        <parameters>
          <parameter name="svg" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="prototype">
        <description>Clean off all of the given mixin parameters.</description>
      </method>
      <method name="load" scope="prototype">
        <description>Load the passed SVG and send it to the parser for parsing.</description>
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.VectorFont"/>
        </return-types>
      </method>
      <method name="initialized" scope="prototype">
        <description>Return if we've loaded a font def, and the parsing was successful.</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_round" scope="prototype">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leading" scope="prototype">
        <parameters>
          <parameter name="unit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="prototype">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidth" scope="prototype">
        <parameters>
          <parameter name="glyphs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLongestLine" scope="prototype">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trim" scope="prototype">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_split" scope="prototype">
        <description>split passed chars into nLines by finding the closest whitespace.</description>
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="nLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSizeFactor" scope="prototype">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFitFactor" scope="prototype">
        <description>Find the scaling factor for the given phrase set.</description>
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="l" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFit" scope="prototype">
        <description>Get the best number of lines to return given w and h.</description>
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="ldng" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFlow" scope="prototype">
        <description>Based on the given scale, do the best line splitting possible.</description>
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype">
        <description>Get the width of the rendered text without actually rendering it.</description>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getLineHeight" scope="prototype">
        <description>return the height of a single line, sans leading, based on scale.</description>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="getCenterline" scope="prototype">
        <description>return the y coordinate that is the center of the viewbox.</description>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getBaseline" scope="prototype">
        <description>Find the baseline coord for alignment; adjust for scale if passed.</description>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="draw" scope="prototype">
        <description>based on the passed parameters, draw the given text using paths
	defined by this font.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Container" usage="required"/>
          <parameter name="textArgs" type="dojox.gfx.__TextArgs" usage="required"/>
          <parameter name="fontArgs" type="dojox.gfx.__FontArgs" usage="required"/>
          <parameter name="fillArgs" type="dojox.gfx.__FillArgs" usage="required"/>
          <parameter name="strokeArgs" type="dojox.gfx.__StrokeArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="onLoadBegin" scope="prototype">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <parameters>
          <parameter name="font" type="dojox.gfx.VectorFont" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_entityRe" scope="prototype" type="Object"/>
      <property name="_defaultLeading" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="gl">
    <properties>
      <property name="kern" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vectorFontFitting">
    <properties>
      <property name="NONE" scope="instance" type="Object"/>
      <property name="FLOW" scope="instance" type="Object"/>
      <property name="FIT" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorText">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="leading" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorFont">
    <properties>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="g">
    <properties>
      <property name="_hasClass" scope="instance" type="Object"/>
      <property name="_addClass" scope="instance" type="Object"/>
      <property name="_removeClass" scope="instance" type="Object"/>
      <property name="createSurface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="b">
    <properties>
      <property name="_getFontMeasurements" scope="instance" type="Object"/>
      <property name="_getCachedFontMeasurements" scope="instance" type="Object"/>
      <property name="_getTextBox" scope="instance" type="Object"/>
      <property name="_getUniqueId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPath">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPolyline">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRect">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultEllipse">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="rx" scope="instance" type="Object"/>
      <property name="ry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultCircle">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLine">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultImage">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText">
    <methods>
      <method name="normalizeColor" scope="instance">
        <description>converts any legal color representation to normalized dojo.Color object</description>
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <description>updates an existing object with properties from an &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the &amp;quot;update&amp;quot; object, whose properties will be used to update the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <description>copies the original object, and all copied properties from the &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <description>converts a number to a string using a fixed notation</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>	number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="optional">
            <description>if it is true, add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <description>converts a font object to a CSS font string</description>
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>converts a CSS font string to a font object</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <description>returns a number of pixels per point</description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <description>converts points to pixels</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <description>converts pixels to points</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizedLength" scope="instance">
        <description>converts any length value to pixels</description>
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., &amp;quot;12pc&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <description>compares event sources, returns true if they are equal</description>
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="align" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Object"/>
      <property name="mm_in_pt" scope="instance" type="Object"/>
      <property name="pathVmlRegExp" scope="instance" type="Object"/>
      <property name="pathSvgRegExp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath">
    <methods>
      <method name="normalizeColor" scope="instance">
        <description>converts any legal color representation to normalized dojo.Color object</description>
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <description>updates an existing object with properties from an &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the &amp;quot;update&amp;quot; object, whose properties will be used to update the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <description>copies the original object, and all copied properties from the &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <description>converts a number to a string using a fixed notation</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>	number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="optional">
            <description>if it is true, add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <description>converts a font object to a CSS font string</description>
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>converts a CSS font string to a font object</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <description>returns a number of pixels per point</description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <description>converts points to pixels</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <description>converts pixels to points</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizedLength" scope="instance">
        <description>converts any length value to pixels</description>
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., &amp;quot;12pc&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <description>compares event sources, returns true if they are equal</description>
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="align" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Object"/>
      <property name="mm_in_pt" scope="instance" type="Object"/>
      <property name="pathVmlRegExp" scope="instance" type="Object"/>
      <property name="pathSvgRegExp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="cap" scope="instance" type="Object"/>
      <property name="join" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultTextPath.defaultFont">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="variant" scope="instance" type="Object"/>
      <property name="weight" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="cap" scope="instance" type="Object"/>
      <property name="join" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText.defaultFont">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="variant" scope="instance" type="Object"/>
      <property name="weight" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath">
    <methods>
      <method name="normalizeColor" scope="instance">
        <description>converts any legal color representation to normalized dojo.Color object</description>
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <description>updates an existing object with properties from an &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the &amp;quot;update&amp;quot; object, whose properties will be used to update the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <description>copies the original object, and all copied properties from the &amp;quot;update&amp;quot; object</description>
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <description>converts a number to a string using a fixed notation</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>	number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="optional">
            <description>if it is true, add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <description>converts a font object to a CSS font string</description>
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>converts a CSS font string to a font object</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <description>returns a number of pixels per point</description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <description>converts points to pixels</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <description>converts pixels to points</description>
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizedLength" scope="instance">
        <description>converts any length value to pixels</description>
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., &amp;quot;12pc&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <description>compares event sources, returns true if they are equal</description>
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="align" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Object"/>
      <property name="mm_in_pt" scope="instance" type="Object"/>
      <property name="pathVmlRegExp" scope="instance" type="Object"/>
      <property name="pathSvgRegExp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="cap" scope="instance" type="Object"/>
      <property name="join" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath.defaultFont">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="variant" scope="instance" type="Object"/>
      <property name="weight" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="cap" scope="instance" type="Object"/>
      <property name="join" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="cx" scope="instance" type="Object"/>
      <property name="cy" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultFont">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="variant" scope="instance" type="Object"/>
      <property name="weight" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="p2">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.arc">
    <methods>
      <method name="arcAsBezier" scope="instance">
        <description>calculates an arc as a series of Bezier curves
	given the last point and a standard set of SVG arc parameters,
	it returns an array of arrays of parameters to form a series of
	absolute Bezier curves.</description>
        <parameters>
          <parameter name="last" type="Object" usage="required">
            <description>a point-like object as a start of the arc</description>
          </parameter>
          <parameter name="rx" type="Number" usage="required">
            <description>a horizontal radius for the virtual ellipse</description>
          </parameter>
          <parameter name="ry" type="Number" usage="required">
            <description>a vertical radius for the virtual ellipse</description>
          </parameter>
          <parameter name="xRotg" type="Number" usage="required">
            <description>a rotation of an x axis of the virtual ellipse in degrees</description>
          </parameter>
          <parameter name="large" type="Boolean" usage="required">
            <description>which part of the ellipse will be used (the larger arc if true)</description>
          </parameter>
          <parameter name="sweep" type="Boolean" usage="required">
            <description>direction of the arc (CW if true)</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>the x coordinate of the end point of the arc</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>the y coordinate of the end point of the arc</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="unitArcAsBezier" scope="instance" type="Object"/>
      <property name="curvePI4" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Group" superclass="g.Shape">
    <description>a group shape (VML), which can be used
	to logically group shapes (e.g, to propagate matricies)</description>
    <methods>
      <method name="_render" scope="prototype">
        <description>render the group</description>
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="prototype">
        <description>sets a raw SVG node to be used by this shape</description>
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyTransform" scope="prototype">
        <description>applies a transformation matrix to a group</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.Shape" scope="prototype"/>
      <mixin type="dojox.gfx.silverlight.Container" scope="instance"/>
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="dojox.gfx.svg.Container" scope="instance"/>
      <mixin type="dojox.gfx.vml.Container" scope="instance"/>
      <mixin type="gs.Container._init" scope="instance"/>
      <mixin type="dojox.gfx.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Rect" superclass="gs.Rect">
    <description>a rectangle shape (VML)</description>
    <methods>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>sets a rectangle shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Rect" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Ellipse" superclass="gs.Ellipse">
    <description>an ellipse shape (VML)</description>
    <methods>
      <method name="setShape" scope="prototype">
        <description>sets an ellipse shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an ellipse shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Ellipse" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasEllipse" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Circle" superclass="gs.Circle">
    <description>a circle shape (VML)</description>
    <methods>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>sets a circle shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a circle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Circle" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Line" superclass="gs.Line">
    <description>a line shape (VML)</description>
    <methods>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>sets a line shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a line shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Line" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Polyline" superclass="gs.Polyline">
    <description>a polyline/polygon shape (VML)</description>
    <methods>
      <method name="setShape" scope="prototype">
        <description>sets a polyline/polygon shape object (VML)</description>
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="required">
            <description>if true, close the polyline explicitely</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Polyline" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPolyline" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="box" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Image" superclass="gs.Image">
    <description>an image (VML)</description>
    <methods>
      <method name="setShape" scope="prototype">
        <description>sets an image shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="prototype">
        <description>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</description>
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEventSource" scope="prototype">
        <description>returns a Node, which is used as
	a source of events for this shape</description>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="prototype">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resetImage" scope="prototype"/>
      <method name="_applyTransform" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Image" scope="prototype"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasImage" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Text" superclass="gs.Text">
    <description>an anchored text (VML)</description>
    <methods>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>sets a text shape object (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_delayAlignment" scope="prototype"/>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
      </method>
      <method name="setStroke" scope="prototype">
        <description>ignore setting a stroke style</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="prototype">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="prototype">
        <description>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</description>
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWidth" scope="prototype">
        <description>get the text width, in px</description>
      </method>
      <method name="_setFont" scope="prototype">
        <description>sets a font object (VML)</description>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <description>returns the cumulative (&amp;quot;real&amp;quot;) transformation matrix
	by combining the shape's matrix with its parent's matrix;
	it makes a correction for a font size</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Text" scope="prototype"/>
      <mixin type="dojox.gfx.silverlight.Font" scope="instance"/>
      <mixin type="dojox.gfx.svg.Font" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="_delay" scope="instance" type="Object"/>
      <property name="_delta" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
      <property name="fontStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path" superclass="g.path.Path">
    <description>a path shape (VML)</description>
    <methods>
      <method name="setShape" scope="prototype">
        <description>forms a path using a shape (VML)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an VML path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <description>updates the bounding box of path with new segment</description>
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="prototype">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addArgs" scope="prototype">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="upto" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelCrd" scope="prototype">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelPos" scope="prototype">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.path.Path" scope="prototype"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPath" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
      <property name="vmlPath" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path.lastControl">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.TextPath" superclass="g.path.TextPath">
    <description>a textpath shape (VML)</description>
    <methods>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <description>updates the bounding box of path with new segment</description>
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>forms a path using a shape (SVG)</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setText" scope="prototype">
        <description>sets a text shape object (VML)</description>
      </method>
      <method name="_setTextPath" scope="prototype"/>
      <method name="setText" scope="prototype">
        <description>sets a text to be drawn along the path</description>
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <description>sets a font for text</description>
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFont" scope="prototype">
        <description>sets a font object (VML)</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.path.TextPath" scope="prototype"/>
      <mixin type="dojox.gfx.Path" scope="prototype"/>
      <mixin type="dojox.gfx.svg.Font" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
      <mixin type="dojox.gfx.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="fontStyle" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Surface" superclass="gs.Surface">
    <description>a surface object to be used for drawings (VML)</description>
    <methods>
      <method name="setDimensions" scope="prototype">
        <description>sets the width and height of the rawNode</description>
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="prototype">
        <description>returns an object with properties &amp;quot;width&amp;quot; and &amp;quot;height&amp;quot;</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_render" scope="prototype">
        <description>render the all shapes</description>
      </method>
      <method name="makeDirty" scope="prototype">
        <description>internal method, which is called when we may need to redraw</description>
      </method>
      <method name="downloadImage" scope="prototype">
        <description>internal method, which starts an image download and renders, when it is ready</description>
        <parameters>
          <parameter name="img" type="Image" usage="required">
            <description>the image object</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>the url of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="onImageLoad" scope="prototype"/>
      <method name="getEventSource" scope="prototype"/>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="createViewport" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape.Surface" scope="prototype"/>
      <mixin type="dojox.gfx.silverlight.Container" scope="instance"/>
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="eventsProcessing" scope="instance"/>
      <mixin type="dojox.gfx.svg.Container" scope="instance"/>
      <mixin type="dojox.gfx.vml.Container" scope="instance"/>
      <mixin type="gs.Container._init" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="pendingRender" scope="instance" type="Object"/>
      <property name="pendingImageCount" scope="instance" type="Object"/>
      <property name="defNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Surface.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type=".Shape">
    <methods>
      <method name="_render" scope="prototype">
        <description>render the shape</description>
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderTransform" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderFill" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStroke" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getEventSource" scope="prototype"/>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
    </methods>
    <properties>
      <property name="canvasFill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type=".Creator">
    <methods>
      <method name="createObject" scope="instance">
        <description>creates an instance of the passed shapeType class</description>
        <parameters>
          <parameter name="shapeType" type="Function" usage="required">
            <description>a class constructor to create an instance of</description>
          </parameter>
          <parameter name="rawShape" type="Object" usage="required">
            <description>properties to be passed in to the classes &amp;quot;setShape&amp;quot; method
	overrideSize: Boolean: set the size explicitly, if true</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="result">
    <properties>
      <property name="dx" scope="instance" type="Object"/>
      <property name="dy" scope="instance" type="Object"/>
      <property name="sx" scope="instance" type="Object"/>
      <property name="sy" scope="instance" type="Object"/>
      <property name="angle1" scope="instance" type="Object"/>
      <property name="angle2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="g.fx">
    <properties>
      <property name="animateStroke" scope="instance" type="Object"/>
      <property name="animateFill" scope="instance" type="Object"/>
      <property name="animateFont" scope="instance" type="Object"/>
      <property name="animateTransform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.matrix">
    <methods>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.matrix.Matrix2D">
    <description>a 2D matrix object</description>
    <properties>
      <property name="xx" scope="instance-prototype" type="Object"/>
      <property name="xy" scope="prototype" type="Object"/>
      <property name="yx" scope="prototype" type="Object"/>
      <property name="yy" scope="prototype" type="Object"/>
      <property name="dx" scope="prototype" type="Object"/>
      <property name="dy" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path">
    <methods>
      <method name="_calcArc" scope="instance">
        <parameters>
          <parameter name="alpha" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.path.Path" superclass="dojox.gfx.Shape">
    <description>a path constructor</description>
    <methods>
      <method name="setAbsoluteMode" scope="prototype">
        <description>sets an absolute or relative mode for path points</description>
        <parameters>
          <parameter name="mode" type="Boolean" usage="required">
            <description>true/false or &amp;quot;absolute&amp;quot;/&amp;quot;relative&amp;quot; to specify the mode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getAbsoluteMode" scope="prototype">
        <description>returns a current value of the absolute mode</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box {x, y, width, height} or null</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getLastPosition" scope="prototype">
        <description>returns the last point in the path, or null</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_updateBBox" scope="prototype">
        <description>updates the bounding box of path with new point</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <description>updates the bounding box of path with new segment</description>
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="prototype">
        <description>adds a segment</description>
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_collectArgs" scope="prototype">
        <description>converts an array of arguments to plain numeric values</description>
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="prototype">
        <description>formes a move segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="prototype">
        <description>formes a line segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hLineTo" scope="prototype">
        <description>formes a horizontal line segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="vLineTo" scope="prototype">
        <description>formes a vertical line segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="curveTo" scope="prototype">
        <description>formes a curve segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="smoothCurveTo" scope="prototype">
        <description>formes a smooth curve segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qCurveTo" scope="prototype">
        <description>formes a quadratic curve segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qSmoothCurveTo" scope="prototype">
        <description>formes a quadratic smooth curve segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="arcTo" scope="prototype">
        <description>formes an elliptic arc segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="prototype">
        <description>closes a path</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setPath" scope="prototype">
        <description>forms a path using an SVG path string</description>
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>an SVG path string</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <description>forms a path using a shape</description>
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_2PI" scope="prototype" type="Object"/>
      <property name="absolute" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM node to be used by this path object</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.bbox">
    <properties>
      <property name="l" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.shape">
    <properties>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path._validSegments">
    <properties>
      <property name="m" scope="instance" type="Object"/>
      <property name="l" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
      <property name="v" scope="instance" type="Object"/>
      <property name="c" scope="instance" type="Object"/>
      <property name="s" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="a" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.TextPath" superclass="dojox.gfx.path.Path">
    <description>a TextPath shape constructor</description>
    <methods>
      <method name="getText" scope="prototype">
        <description>returns the current text object or null</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setText" scope="prototype">
        <description>sets a text to be drawn along the path</description>
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getFont" scope="prototype">
        <description>returns the current font object or null</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <description>sets a font for text</description>
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="text" scope="instance" type="Object"/>
      <property name="fontStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape">
    <description>a Shape object, which knows how to apply
	graphical attributes and transformations</description>
    <methods>
      <method name="getNode" scope="prototype">
        <description>returns the current DOM Node or null</description>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getShape" scope="prototype">
        <description>returns the current shape object or null
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransform" scope="prototype">
        <description>returns the current transformation matrix or null</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getFill" scope="prototype">
        <description>returns the current fill object or null
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getStroke" scope="prototype">
        <description>returns the current stroke object or null
	(see dojox.gfx.defaultStroke)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getParent" scope="prototype">
        <description>returns the parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box or null
	(see dojox.gfx.defaultRect)</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getTransformedBoundingBox" scope="prototype">
        <description>returns an array of four points or null
	four points represent four corners of the untransformed bounding box</description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getEventSource" scope="prototype">
        <description>returns a Node, which is used as
	a source of events for this shape</description>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="setShape" scope="prototype">
        <description>sets a shape object (SVG)</description>
        <parameters>
          <parameter name="shape" type="Object" usage="required">
            <description>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="prototype">
        <description>sets a fill object (VML)</description>
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="prototype">
        <description>sets a stroke object (VML)</description>
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setTransform" scope="prototype">
        <description>sets a transformation matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="prototype">
        <description>physically sets a matrix</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToFront" scope="prototype">
        <description>moves a shape to front of its parent's list of shapes</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToBack" scope="prototype">
        <description>moves a shape to back of its parent's list of shapes</description>
      </method>
      <method name="_moveToFront" scope="prototype">
        <description>moves a shape to front of its parent's list of shapes (VML)</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="prototype">
        <description>moves a shape to back of its parent's list of shapes (VML)</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="prototype">
        <description>a shortcut for dojox.gfx.Shape.applyRightTransform</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeShape" scope="prototype">
        <description>removes the shape from its parent's list of shapes</description>
        <parameters>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setParent" scope="prototype">
        <description>sets a parent</description>
        <parameters>
          <parameter name="parent" type="Object" usage="required">
            <description>a parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</description>
          </parameter>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateParentMatrix" scope="prototype">
        <description>updates the parent matrix with new matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <description>returns the cumulative (&amp;quot;real&amp;quot;) transformation matrix
	by combining the shape's matrix with its parent's matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="prototype">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getParentSurface" scope="prototype"/>
      <method name="setRawNode" scope="prototype">
        <description>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</description>
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <description>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_setFillObject" scope="prototype">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="nodeType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_translate" scope="prototype">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape._eventsProcessing" scope="instance"/>
      <mixin type="eventsProcessing" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="parentMatrix" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape"/>
  <class type="dojox.gfx.shape.Surface">
    <description>a surface object to be used for drawings</description>
    <methods>
      <method name="destroy" scope="prototype">
        <description>destroy all relevant external resources and release all
	external references to make this object garbage-collectible</description>
      </method>
      <method name="getEventSource" scope="prototype">
        <description>returns a node, which can be used to attach event listeners</description>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <description>always returns the identity matrix</description>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <description>local event, fired once when the surface is created
	asynchronously, used only when isLoaded is false, required
	only for Silverlight.</description>
        <parameters>
          <parameter name="surface" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
      </method>
      <method name="whenLoaded" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="optional"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx.shape._eventsProcessing" scope="instance"/>
    </mixins>
    <properties>
      <property name="isLoaded" scope="prototype" type="Object"/>
      <property name="_nodes" scope="instance" type="Object"/>
      <property name="_events" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Surface._parent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Point">
    <description>a hypothetical 2D point to be used for drawings - {x, y}</description>
  </class>
  <class type="dojox.gfx.Rectangle">
    <description>a hypothetical rectangle - {x, y, width, height}</description>
  </class>
  <class type="dojox.gfx.shape.Rect" superclass="dojox.gfx.Shape">
    <description>a generic rectangle</description>
    <methods>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box (its shape in this case)</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Ellipse" superclass="dojox.gfx.Shape">
    <description>a generic ellipse</description>
    <methods>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Circle" superclass="dojox.gfx.Shape">
    <description>a generic circle
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Line" superclass="dojox.gfx.Shape">
    <description>a generic line
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline" superclass="dojox.gfx.Shape">
    <description>a generic polyline/polygon
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="setShape" scope="prototype">
        <description>sets a polyline/polygon shape object</description>
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="required">
            <description>close the polyline to make a polygon</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Image" superclass="dojox.gfx.Shape">
    <description>a generic image
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="getBoundingBox" scope="prototype">
        <description>returns the bounding box (its shape in this case)</description>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="setStroke" scope="prototype">
        <description>ignore setting a stroke style</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="prototype">
        <description>ignore setting a fill style</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Text" superclass="dojox.gfx.Shape">
    <description>a generic text</description>
    <methods>
      <method name="getFont" scope="prototype">
        <description>returns the current font object or null</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <description>sets a font for text</description>
        <parameters>
          <parameter name="newFont" type="Object" usage="required">
            <description>a font object (see dojox.gfx.defaultFont) or a font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="fontStyle" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="connect" scope="instance">
        <description>connects a handler to an event on this shape</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>connects a handler by token from an event on this shape</description>
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Container">
    <description>a container of shapes, which can be used
	as a foundation for renderer-specific groups, or as a way
	to logically group shapes (e.g, to propagate matricies)</description>
    <methods>
      <method name="_init" scope="instance"/>
      <method name="add" scope="instance">
        <description>adds a shape to the list</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>removes a shape from the list</description>
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <description>removes all shapes from a group/surface</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToFront" scope="instance">
        <description>moves a shape to front of the list of shapes</description>
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToBack" scope="instance">
        <description>moves a shape to back of the list of shapes</description>
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Creator">
    <description>shape creators</description>
    <methods>
      <method name="createShape" scope="instance">
        <description>creates a shape object based on its type; it is meant to be used
	by group-like objects</description>
        <parameters>
          <parameter name="shape" type="Object" usage="required">
            <description>a shape descriptor object</description>
          </parameter>
        </parameters>
      </method>
      <method name="createGroup" scope="instance">
        <description>creates a VML group shape</description>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="createRect" scope="instance">
        <description>creates an SVG rectangle shape</description>
        <parameters>
          <parameter name="rect" type="Object" usage="required">
            <description>a path object (see dojox.gfx.defaultRect)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Rect"/>
        </return-types>
      </method>
      <method name="createEllipse" scope="instance">
        <description>creates an SVG ellipse shape</description>
        <parameters>
          <parameter name="ellipse" type="Object" usage="required">
            <description>an ellipse object (see dojox.gfx.defaultEllipse)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Ellipse"/>
        </return-types>
      </method>
      <method name="createCircle" scope="instance">
        <description>creates an SVG circle shape</description>
        <parameters>
          <parameter name="circle" type="Object" usage="required">
            <description>a circle object (see dojox.gfx.defaultCircle)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Circle"/>
        </return-types>
      </method>
      <method name="createLine" scope="instance">
        <description>creates an SVG line shape</description>
        <parameters>
          <parameter name="line" type="Object" usage="required">
            <description>a line object (see dojox.gfx.defaultLine)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Line"/>
        </return-types>
      </method>
      <method name="createPolyline" scope="instance">
        <description>creates an SVG polyline/polygon shape</description>
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a points object (see dojox.gfx.defaultPolyline)
	or an Array of points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Polyline"/>
        </return-types>
      </method>
      <method name="createImage" scope="instance">
        <description>creates a VML image shape</description>
        <parameters>
          <parameter name="image" type="Object" usage="required">
            <description>an image object (see dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Image"/>
        </return-types>
      </method>
      <method name="createText" scope="instance">
        <description>creates an SVG text shape</description>
        <parameters>
          <parameter name="text" type="Object" usage="required">
            <description>a text object (see dojox.gfx.defaultText)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Text"/>
        </return-types>
      </method>
      <method name="createPath" scope="instance">
        <description>creates an SVG path shape</description>
        <parameters>
          <parameter name="path" type="Object" usage="required">
            <description>a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Path"/>
        </return-types>
      </method>
      <method name="createTextPath" scope="instance">
        <description>creates an SVG text shape</description>
        <parameters>
          <parameter name="text" type="Object" usage="required">
            <description>a textpath object (see dojox.gfx.defaultTextPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.TextPath"/>
        </return-types>
      </method>
      <method name="createObject" scope="instance">
        <description>creates an instance of the passed shapeType class</description>
        <parameters>
          <parameter name="shapeType" type="Function" usage="required">
            <description>a class constructor to create an instance of</description>
          </parameter>
          <parameter name="rawShape" type="Object" usage="required">
            <description>properties to be passed in to the classes &amp;quot;setShape&amp;quot; method
	overrideSize: Boolean: set the size explicitly, if true</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="_overrideSize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.Polyline.rawNode">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Text.rawNode">
    <properties>
      <property name="foreground" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path.rawNode">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight">
    <methods>
      <method name="hexColor" scope="instance">
        <description>converts a color object to a Silverlight hex color string (#aarrggbb)</description>
        <parameters>
          <parameter name="color" type="String|Array|dojo.Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="nullFunc" scope="instance"/>
    </methods>
    <properties>
      <property name="surfaces" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.dasharray">
    <properties>
      <property name="solid" scope="instance" type="Object"/>
      <property name="shortdash" scope="instance" type="Object"/>
      <property name="shortdot" scope="instance" type="Object"/>
      <property name="shortdashdot" scope="instance" type="Object"/>
      <property name="shortdashdotdot" scope="instance" type="Object"/>
      <property name="dot" scope="instance" type="Object"/>
      <property name="dash" scope="instance" type="Object"/>
      <property name="longdash" scope="instance" type="Object"/>
      <property name="dashdot" scope="instance" type="Object"/>
      <property name="longdashdot" scope="instance" type="Object"/>
      <property name="longdashdotdot" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.fontweight">
    <properties>
      <property name="normal" scope="instance" type="Object"/>
      <property name="bold" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.caps">
    <properties>
      <property name="butt" scope="instance" type="Object"/>
      <property name="round" scope="instance" type="Object"/>
      <property name="square" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.joins">
    <properties>
      <property name="bevel" scope="instance" type="Object"/>
      <property name="round" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.fonts">
    <properties>
      <property name="serif" scope="instance" type="Object"/>
      <property name="times" scope="instance" type="Object"/>
      <property name="sans-serif" scope="instance" type="Object"/>
      <property name="helvetica" scope="instance" type="Object"/>
      <property name="monotone" scope="instance" type="Object"/>
      <property name="courier" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Font">
    <methods>
      <method name="_setFont" scope="instance">
        <description>sets a font object (Silverlight)</description>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight.Container">
    <methods>
      <method name="_init" scope="instance"/>
      <method name="add" scope="instance">
        <description>adds a shape to a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a Silverlight shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>remove a shape from a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a Silverlight shape object</description>
          </parameter>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, regenerate a picture</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <description>removes all shapes from a group/surface</description>
      </method>
    </methods>
    <properties>
      <property name="_moveChildToFront" scope="instance" type="Object"/>
      <property name="_moveChildToBack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape.rawNode">
    <description>underlying node</description>
    <properties>
      <property name="filled" scope="instance" type="Object"/>
      <property name="fillcolor" scope="instance" type="Object"/>
      <property name="stroked" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg">
    <methods>
      <method name="getRef" scope="instance">
        <description>returns a DOM Node specified by the name argument or null</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>an SVG external reference</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.svg.xmlns">
    <properties>
      <property name="xlink" scope="instance" type="Object"/>
      <property name="svg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.dasharray">
    <properties>
      <property name="solid" scope="instance" type="Object"/>
      <property name="shortdash" scope="instance" type="Object"/>
      <property name="shortdot" scope="instance" type="Object"/>
      <property name="shortdashdot" scope="instance" type="Object"/>
      <property name="shortdashdotdot" scope="instance" type="Object"/>
      <property name="dot" scope="instance" type="Object"/>
      <property name="dash" scope="instance" type="Object"/>
      <property name="longdash" scope="instance" type="Object"/>
      <property name="dashdot" scope="instance" type="Object"/>
      <property name="longdashdot" scope="instance" type="Object"/>
      <property name="longdashdotdot" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Font">
    <methods>
      <method name="_setFont" scope="instance">
        <description>sets a font object (SVG)</description>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.svg.Container">
    <methods>
      <method name="_init" scope="instance"/>
      <method name="add" scope="instance">
        <description>adds a shape to a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>an VML shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>remove a shape from a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>an VML shape object</description>
          </parameter>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, regenerate a picture</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <description>removes all shapes from a group/surface</description>
      </method>
    </methods>
    <properties>
      <property name="_moveChildToFront" scope="instance" type="Object"/>
      <property name="_moveChildToBack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="t">
    <properties>
      <property name="children" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="transform" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Rect.rawNode">
    <properties>
      <property name="arcsize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Line.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Polyline.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Image.rawNode.firstChild">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Image.rawNode.style">
    <properties>
      <property name="filter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Text._alignment">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="middle" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Text.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path._pathVmlToSvgMap">
    <properties>
      <property name="m" scope="instance" type="Object"/>
      <property name="l" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="c" scope="instance" type="Object"/>
      <property name="v" scope="instance" type="Object"/>
      <property name="qb" scope="instance" type="Object"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Path.renderers">
    <properties>
      <property name="M" scope="instance" type="Object"/>
      <property name="L" scope="instance" type="Object"/>
      <property name="H" scope="instance" type="Object"/>
      <property name="V" scope="instance" type="Object"/>
      <property name="C" scope="instance" type="Object"/>
      <property name="S" scope="instance" type="Object"/>
      <property name="Q" scope="instance" type="Object"/>
      <property name="T" scope="instance" type="Object"/>
      <property name="A" scope="instance" type="Object"/>
      <property name="Z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml">
    <methods>
      <method name="_parseFloat" scope="instance">
        <description>a helper function to parse VML-specific floating-point values</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a representation of a floating-point number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="xmlns" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.text_alignment">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="middle" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml._bool">
    <properties>
      <property name="t" scope="instance" type="Object"/>
      <property name="true" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Container">
    <methods>
      <method name="_init" scope="instance"/>
      <method name="add" scope="instance">
        <description>adds a shape to a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>an VML shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>remove a shape from a group/surface</description>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>an VML shape object</description>
          </parameter>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, regenerate a picture</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <description>removes all shapes from a group/surface</description>
      </method>
    </methods>
    <properties>
      <property name="_moveChildToFront" scope="instance" type="Object"/>
      <property name="_moveChildToBack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape.rawNode.fill">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="method" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape._capMap">
    <properties>
      <property name="butt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape._capMapReversed">
    <properties>
      <property name="flat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Shape.fillStyle">
    <properties>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d">
    <description>A 3d API for dojox.gfx</description>
    <methods>
      <method name="gradient" scope="instance">
        <description>calculate a cylindrical gradient</description>
        <parameters>
          <parameter name="model" type="dojox.gfx3d.lighting.Model" usage="required">
            <description>color model</description>
          </parameter>
          <parameter name="material" type="Object" usage="required">
            <description>defines visual properties</description>
          </parameter>
          <parameter name="center" type="Object" usage="required">
            <description>center of the cylinder's bottom</description>
          </parameter>
          <parameter name="radius" type="Number" usage="required">
            <description>radius of the cylinder</description>
          </parameter>
          <parameter name="from" type="Number" usage="required">
            <description>from position in radians</description>
          </parameter>
          <parameter name="to" type="Number" usage="required">
            <description>from position in radians</description>
          </parameter>
          <parameter name="matrix" type="dojox.gfx3d.Matrix3D" usage="required">
            <description>the cumulative transformation matrix
	tolerance: Number: tolerable diffirence in colors between gradient steps</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="Matrix3D" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultEdges">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultTriangles">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultQuads">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit.center">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPath3d">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPolygon">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube">
    <properties>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.bottom">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.top">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder.center">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting">
    <methods>
      <method name="black" scope="instance"/>
      <method name="white" scope="instance"/>
      <method name="toStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fromStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scaleColor" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="multiplyColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturateColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixColor" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diff2Color" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length2Color" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dot" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturate" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="faceforward" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reflect" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diffuse" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="specular" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="roughness" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phong" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.lighting.Model">
    <methods>
      <method name="constant" scope="prototype">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matte" scope="prototype">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="metal" scope="prototype">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="plastic" scope="prototype">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="npr" scope="prototype">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="incident" scope="instance" type="Object"/>
      <property name="lights" scope="instance" type="Object"/>
      <property name="npr_cool" scope="instance" type="Object"/>
      <property name="npr_warm" scope="instance" type="Object"/>
      <property name="npr_alpha" scope="instance" type="Object"/>
      <property name="npr_beta" scope="instance" type="Object"/>
      <property name="npr_scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.ambient">
    <properties>
      <property name="a" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.specular">
    <properties>
      <property name="a" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.defaults">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish"/>
  <class type="dojox.gfx3d.lighting.finish.dull">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.shiny">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.glossy">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_dull">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="phong" scope="instance" type="Object"/>
      <property name="phong_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_shiny">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="phong" scope="instance" type="Object"/>
      <property name="phong_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_glossy">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="phong" scope="instance" type="Object"/>
      <property name="phong_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.luminous">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalA">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalB">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalC">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalD">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalE">
    <properties>
      <property name="Ka" scope="instance" type="Object"/>
      <property name="Kd" scope="instance" type="Object"/>
      <property name="Ks" scope="instance" type="Object"/>
      <property name="roughness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix">
    <methods>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="translate" scope="instance">
        <description>forms a translation matrix</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>forms a scaling matrix</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a scaling factor used for the z coordinate</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateX" scope="instance">
        <description>forms a rotating matrix (about the x axis)</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateXg" scope="instance">
        <description>forms a rotating matrix (about the x axis)</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateY" scope="instance">
        <description>forms a rotating matrix (about the y axis)</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateYg" scope="instance">
        <description>forms a rotating matrix (about the y axis)</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZ" scope="instance">
        <description>forms a rotating matrix (about the z axis)</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZg" scope="instance">
        <description>forms a rotating matrix (about the z axis)</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraTranslate" scope="instance">
        <description>forms a translation matrix</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateX" scope="instance">
        <description>forms a rotating matrix (about the x axis) in cameraTransform manner</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateXg" scope="instance">
        <description>forms a rotating matrix (about the x axis)in cameraTransform manner</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateY" scope="instance">
        <description>forms a rotating matrix (about the y axis) in cameraTransform manner</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateYg" scope="instance">
        <description>forms a rotating matrix (about the y axis) in cameraTransform manner</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZ" scope="instance">
        <description>forms a rotating matrix (about the z axis) in cameraTransform manner</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZg" scope="instance">
        <description>forms a rotating matrix (about the z axis) in cameraTransform manner</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>converts an object to a matrix, if necessary</description>
        <parameters>
          <parameter name="matrix" type="Object" usage="required">
            <description>an object, which is converted to a matrix, if necessary</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <description>creates a copy of a 3D matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix-like object to be cloned</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <description>inverts a 2D matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix3D" usage="required">
            <description>a 2D matrix-like object to be inverted</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <description>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</description>
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="instance">
        <description>applies a matrix to a point</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number, optional" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <description>combines matrices by multiplying them sequentially in the given order</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="one-or-more">
            <description>a 3D matrix-like object,
	all subsequent arguments are matrix-like objects too</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_project" scope="instance">
        <description>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</description>
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <description>applies a matrix to a point</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number, optional" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix.Matrix3D">
    <description>a 3D matrix object</description>
    <properties>
      <property name="xx" scope="instance-prototype" type="Object"/>
      <property name="xy" scope="prototype" type="Object"/>
      <property name="xz" scope="prototype" type="Object"/>
      <property name="yx" scope="prototype" type="Object"/>
      <property name="yy" scope="prototype" type="Object"/>
      <property name="yz" scope="prototype" type="Object"/>
      <property name="zx" scope="prototype" type="Object"/>
      <property name="zy" scope="prototype" type="Object"/>
      <property name="zz" scope="prototype" type="Object"/>
      <property name="dx" scope="prototype" type="Object"/>
      <property name="dy" scope="prototype" type="Object"/>
      <property name="dz" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Object">
    <description>a Object object, which knows how to map
	3D objects to 2D shapes.</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>sets a Object object</description>
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="prototype">
        <description>sets a transformation matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="prototype">
        <description>a shortcut for dojox.gfx.Shape.applyRightTransform</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="prototype">
        <description>sets a fill object
	(the default implementation is to delegate to
	the underlying 2D shape).</description>
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	dojo.Color
	or dojox.gfx.MODEL)</description>
          </parameter>
        </parameters>
      </method>
      <method name="setStroke" scope="prototype">
        <description>sets a stroke object
	(the default implementation simply ignores it)</description>
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
      </method>
      <method name="toStdFill" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
          <parameter name="normal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="getOutline" scope="prototype"/>
    </methods>
    <properties>
      <property name="object" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Scene" superclass="dojox.gfx3d.Object">
    <description>a containter of other 3D objects</description>
    <methods>
      <method name="setFill" scope="prototype">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="prototype">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="deep" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTodo" scope="prototype">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="getZOrder" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx3d._creators" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="todos" scope="instance" type="Object"/>
      <property name="objects" scope="instance" type="Object"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="_draw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Edges" superclass="dojox.gfx3d.Object">
    <description>a generic edge in 3D viewport</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>setup the object</description>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String, optional" usage="required">
            <description>String optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype"/>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Edges.object">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Orbit" superclass="dojox.gfx3d.Object">
    <description>a generic edge in 3D viewport</description>
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d" superclass="dojox.gfx3d.Object">
    <description>a generic line
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="_collectArgs" scope="prototype">
        <description>converts an array of arguments to plain numeric values</description>
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="prototype">
        <description>adds a segment</description>
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="prototype">
        <description>formes a move segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="prototype">
        <description>formes a line segment</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="prototype">
        <description>closes a path</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_draw" scope="prototype"/>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Object"/>
      <property name="absolute" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d._validSegments">
    <properties>
      <property name="m" scope="instance" type="Object"/>
      <property name="l" scope="instance" type="Object"/>
      <property name="z" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Triangles" superclass="dojox.gfx3d.Object">
    <description>a generic triangle
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>setup the object</description>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String, optional" usage="required">
            <description>String optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Triangles.object">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Quads" superclass="dojox.gfx3d.Object">
    <description>a generic triangle
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>setup the object</description>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String, optional" usage="required">
            <description>String optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Quads.object">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Polygon" superclass="dojox.gfx3d.Object">
    <description>a generic triangle
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>setup the object</description>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="getOutline" scope="prototype"/>
    </methods>
    <properties>
      <property name="object" scope="instance" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube" superclass="dojox.gfx3d.Object">
    <description>a generic triangle
	(this is a helper object, which is defined for convenience)</description>
    <methods>
      <method name="setObject" scope="prototype">
        <description>setup the object</description>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
    <properties>
      <property name="object" scope="instance" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="polygons" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype"/>
    </methods>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder.fillStyle">
    <properties>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport" superclass="dojox.gfx.Group">
    <description>a viewport/container for 3D objects, which knows
	the camera and lightings</description>
    <methods>
      <method name="setCameraTransform" scope="prototype">
        <description>sets a transformation matrix</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraRightTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraLeftTransform" scope="prototype">
        <description>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraTransform" scope="prototype">
        <description>a shortcut for dojox.gfx3d.Object.applyRightTransform</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setLights" scope="prototype">
        <description>set the lights</description>
        <parameters>
          <parameter name="lights" type="Array || Object" usage="required">
            <description>Array an array of light object
	or lights object</description>
          </parameter>
          <parameter name="ambient" type="Color, optional" usage="required">
            <description>Color an ambient object</description>
          </parameter>
          <parameter name="specular" type="Color, optional" usage="required">
            <description>Color an specular object</description>
          </parameter>
        </parameters>
      </method>
      <method name="addLights" scope="prototype">
        <description>add new light/lights to the viewport.</description>
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <description>|| light object: light object(s)</description>
          </parameter>
        </parameters>
      </method>
      <method name="addTodo" scope="prototype">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="setDimensions" scope="prototype">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <description>iterate all children and call their render callback function.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojox.gfx3d._creators" scope="instance"/>
    </mixins>
    <properties>
      <property name="camera" scope="instance" type="Object"/>
      <property name="lights" scope="instance" type="Object"/>
      <property name="lighting" scope="instance" type="Object"/>
      <property name="deep" scope="instance" type="Object"/>
      <property name="todos" scope="instance" type="Object"/>
      <property name="dimension" scope="instance" type="Object"/>
      <property name="objects" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="draw" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d._creators">
    <description>object creators</description>
    <methods>
      <method name="createEdges" scope="instance">
        <description>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</description>
        <parameters>
          <parameter name="edges" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createTriangles" scope="instance">
        <description>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</description>
        <parameters>
          <parameter name="tris" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createQuads" scope="instance">
        <description>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</description>
        <parameters>
          <parameter name="quads" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createPolygon" scope="instance">
        <description>creates an triangle object</description>
        <parameters>
          <parameter name="points" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Polygon"/>
        </return-types>
      </method>
      <method name="createOrbit" scope="instance">
        <description>creates an triangle object
	points: Array of points || Object</description>
        <parameters>
          <parameter name="orbit" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCube" scope="instance">
        <description>creates an triangle object
	points: Array of points || Object</description>
        <parameters>
          <parameter name="cube" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCylinder" scope="instance">
        <description>creates an triangle object
	points: Array of points || Object</description>
        <parameters>
          <parameter name="cylinder" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createPath3d" scope="instance">
        <description>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</description>
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createScene" scope="instance">
        <description>creates an triangle object
	line: Object: a triangle object (see dojox.gfx3d.defaultPath)</description>
        <return-types>
          <return-type type="dojox.gfx3d.Scene"/>
        </return-types>
      </method>
      <method name="create3DObject" scope="instance">
        <description>creates an instance of the passed shapeType class
	shapeType: Function: a class constructor to create an instance of
	rawShape: Object: properties to be passed in to the classes &amp;quot;setShape&amp;quot; method</description>
        <parameters>
          <parameter name="objectType" type="Object" usage="required"/>
          <parameter name="rawObject" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Object"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <description>adds a shape to the list
	shape: dojox.gfx.Shape: a shape</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="abandon" scope="instance">
        <description>removes a shape from the list</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setScheduler" scope="instance">
        <parameters>
          <parameter name="scheduler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDrawer" scope="instance">
        <parameters>
          <parameter name="drawer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.scheduler">
    <methods>
      <method name="zOrder" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="order" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bsp" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="order" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="outline" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.scheduler.BinarySearchTree">
    <description>build the binary search tree, using binary space partition algorithm.
	The idea is for any polygon, for example, (a, b, c), the space is divided by
	the plane into two space: plus and minus.
	for any arbitary vertex p, if(p - a) dotProduct n = 0, p is inside the plane,
	&amp;gt; 0, p is in the plus space, vice versa for minus space.
	n is the normal vector that is perpendicular the plate, defined as:
	n = ( b - a) crossProduct ( c - a )
	in this implementation, n is declared as normal, ,a is declared as orient.</description>
    <methods>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iterate" scope="prototype">
        <parameters>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="minus" scope="instance" type="Object"/>
      <property name="plus" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="orient" scope="instance" type="Object"/>
      <property name="normal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.drawer">
    <methods>
      <method name="conservative" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="chart" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.vector">
    <methods>
      <method name="sum" scope="instance">
        <description>sum of the vectors</description>
      </method>
      <method name="center" scope="instance">
        <description>center of the vectors</description>
      </method>
      <method name="substract" scope="instance">
        <parameters>
          <parameter name="a" type="Pointer" usage="required"/>
          <parameter name="b" type="Pointer" usage="required"/>
        </parameters>
      </method>
      <method name="_crossProduct" scope="instance">
        <description>applies a cross product of two vectorss, (x, y, z) and (u, v, w)</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="crossProduct" scope="instance">
        <description>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</description>
        <parameters>
          <parameter name="a" type="Number||Point" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number||Point" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number, optional" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number, optional" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_dotProduct" scope="instance">
        <description>applies a cross product of two vectorss, (x, y, z) and (u, v, w)</description>
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="dotProduct" scope="instance">
        <description>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</description>
        <parameters>
          <parameter name="a" type="Number||Point" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number||Point" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number, optional" usage="required">
            <description>Number an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number, optional" usage="required">
            <description>Number a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number, optional" usage="required">
            <description>Number a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>find the normal of the implicit surface</description>
        <parameters>
          <parameter name="a" type="Point||Array" usage="required">
            <description>Object a point</description>
          </parameter>
          <parameter name="b" type="Point" usage="required">
            <description>Object a point</description>
          </parameter>
          <parameter name="c" type="Point" usage="required">
            <description>Object a point</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid">
    <description>An advanced Grid widget with virtual scrolling, cell editing, and much more</description>
    <methods>
      <method name="nop" scope="instance">
        <description>a null function?</description>
      </method>
      <method name="getTdIndex" scope="instance">
        <parameters>
          <parameter name="td" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTrIndex" scope="instance">
        <parameters>
          <parameter name="tr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTr" scope="instance">
        <parameters>
          <parameter name="rowOwner" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTd" scope="instance">
        <parameters>
          <parameter name="rowOwner" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTable" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ascendDom" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inWhile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeNotTagName" scope="instance">
        <parameters>
          <parameter name="inTagName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fire" scope="instance">
        <parameters>
          <parameter name="ob" type="Object" usage="required"/>
          <parameter name="ev" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleText" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inStyleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStyleText" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inStyleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyle" scope="instance">
        <parameters>
          <parameter name="inElement" type="Object" usage="required"/>
          <parameter name="inStyle" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleHeightPx" scope="instance">
        <parameters>
          <parameter name="inElement" type="Object" usage="required"/>
          <parameter name="inHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="funnelEvents" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inObject" type="Object" usage="required"/>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inEvents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollbarWidth" scope="instance"/>
      <method name="getRef" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="create" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProp" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="create" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="indexInParent" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cleanNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTagName" scope="instance">
        <parameters>
          <parameter name="inNodeOrId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nodeKids" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inTag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="divkids" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusSelectNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="whenIdle" scope="instance"/>
      <method name="arrayCompare" scope="instance">
        <parameters>
          <parameter name="inA" type="Object" usage="required"/>
          <parameter name="inB" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayInsert" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayRemove" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arraySwap" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inI" type="Object" usage="required"/>
          <parameter name="inJ" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initTextSizePoll" scope="instance">
        <parameters>
          <parameter name="inInterval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="textSizeChanged" scope="instance"/>
    </methods>
    <properties>
      <property name="Grid" scope="instance" type="Object"/>
      <property name="VirtualGrid" scope="instance" type="Object"/>
      <property name="rowIndexTag" scope="instance" type="Object"/>
      <property name="gridViewTag" scope="instance" type="Object"/>
      <property name="drag" scope="instance" type="Object"/>
      <property name="na" scope="instance" type="Object"/>
      <property name="mouseEvents" scope="instance" type="Object"/>
      <property name="keyEvents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid" superclass="dojox.grid._Grid">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="createSelection" scope="prototype"/>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRevert" scope="prototype"/>
      <method name="setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItems" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="prototype">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchError" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="prototype">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearData" scope="prototype"/>
      <method name="getItem" scope="prototype">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItemIndex" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="reRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemAttr" scope="prototype">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="prototype"/>
      <method name="_requestsPending" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rowToPage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageToRow" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requestPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="prototype">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="canSort" scope="prototype"/>
      <method name="getSortProps" scope="prototype"/>
      <method name="styleRowState" scope="prototype">
        <description>Perform row styling</description>
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="prototype">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDataAttr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <description>Remove the selected rows from the grid.</description>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="query" scope="instance-prototype" type="Object"/>
      <property name="queryOptions" scope="instance-prototype" type="Object"/>
      <property name="fetchText" scope="prototype" type="Object"/>
      <property name="items" scope="instance-prototype" type="Object"/>
      <property name="_store_connects" scope="instance-prototype" type="Object"/>
      <property name="_by_idty" scope="instance-prototype" type="Object"/>
      <property name="_by_idx" scope="instance-prototype" type="Object"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_pages" scope="instance-prototype" type="Object"/>
      <property name="_pending_requests" scope="instance-prototype" type="Object"/>
      <property name="_bop" scope="instance-prototype" type="Object"/>
      <property name="_eop" scope="instance-prototype" type="Object"/>
      <property name="_requests" scope="prototype" type="Object"/>
      <property name="rowCount" scope="instance-prototype" type="Object"/>
      <property name="_isLoaded" scope="instance-prototype" type="Object"/>
      <property name="_isLoading" scope="instance-prototype" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_canEdit" scope="instance" type="Object"/>
      <property name="_hasIdentity" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="_lastScrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataSelection" superclass="dojox.grid.Selection">
    <methods>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection">
    <description>Manages row selection for grid. Owned by grid and used internally
	for selection. Override to implement custom selection.</description>
    <methods>
      <method name="setMode" scope="prototype">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="prototype"/>
      <method name="onChanged" scope="prototype"/>
      <method name="isSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="getSelectedCount" scope="prototype"/>
      <method name="_beginUpdate" scope="prototype"/>
      <method name="_endUpdate" scope="prototype"/>
      <method name="select" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="prototype">
        <parameters>
          <parameter name="inExcept" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inCtrlKey" type="Object" usage="required"/>
          <parameter name="inShiftKey" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
    </methods>
    <properties>
      <property name="mode" scope="instance-prototype" type="Object"/>
      <property name="selected" scope="instance-prototype" type="Object"/>
      <property name="updating" scope="instance-prototype" type="Object"/>
      <property name="selectedIndex" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager">
    <description>Controls grid cell editing process. Owned by grid and used internally for editing.</description>
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="cellFocus" scope="prototype">
        <description>Invoke editing when cell is focused</description>
        <parameters>
          <parameter name="inCell" type="cell" usage="required">
            <description>object
	Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="rowClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEditing" scope="prototype">
        <description>Indicates editing state of the grid.</description>
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditCell" scope="prototype">
        <description>Indicates if the given cell is being edited.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <description>Grid cell index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given cell is being edited</return-description>
      </method>
      <method name="isEditRow" scope="prototype">
        <description>Indicates if the given row is being edited.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given row is being edited</return-description>
      </method>
      <method name="setEditCell" scope="prototype">
        <description>Set the given cell to be edited</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEditor" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusEditor" scope="prototype"/>
      <method name="_shouldCatchBoomerang" scope="prototype"/>
      <method name="_boomerangFocus" scope="prototype"/>
      <method name="_doCatchBoomerang" scope="prototype"/>
      <method name="start" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inEditing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editorApply" scope="prototype"/>
      <method name="editorCancel" scope="prototype"/>
      <method name="applyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyRowEdit" scope="prototype"/>
      <method name="apply" scope="prototype">
        <description>Apply a grid edit</description>
      </method>
      <method name="cancel" scope="prototype">
        <description>Cancel a grid edit</description>
      </method>
      <method name="save" scope="prototype">
        <description>Save the grid editing state</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <description>Restores the grid editing state</description>
        <parameters>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_boomerangWindow" scope="prototype" type="Object"/>
      <property name="_catchBoomerang" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="connections" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager.info">
    <properties>
      <property name="rowIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events">
    <description>_Grid mixin that provides default implementations for grid events.</description>
    <methods>
      <method name="onKeyEvent" scope="prototype">
        <description>top level handler for Key Events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onContentEvent" scope="prototype">
        <description>Top level handler for Content events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="prototype">
        <description>Top level handler for header events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <description>Perform row styling on a given row. Called whenever row styling is updated.</description>
        <example>onStyleRow({ selected: true, over:true, odd:false })</example>
        <parameters>
          <parameter name="inRow" type="Object" usage="required">
            <description>containing row state information: selected, true if the row is selcted; over:
	true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
	customStyles to control row css classes and styles; both properties are strings.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <description>Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
	tab, shift-tab, and arrow keys move grid cell focus.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <description>Event fired when mouse is over the grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <description>Event fired when mouse moves out of the grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>Event fired when mouse is down inside grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="prototype">
        <description>Event fired when mouse is over any row (data or header).</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="prototype">
        <description>Event fired when mouse moves out of any row (data or header).</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="prototype">
        <description>Event fired when mouse is down inside grid row</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="prototype">
        <description>Event fired when mouse is over a cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="prototype">
        <description>Event fired when mouse moves out of a cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="prototype">
        <description>Event fired when mouse is down in a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="prototype">
        <description>Event fired when a cell is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="prototype">
        <description>Event fired when a cell is double-clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="prototype">
        <description>Event fired when a cell context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellFocus" scope="prototype">
        <description>Event fired when a cell receives focus.</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowClick" scope="prototype">
        <description>Event fired when a row is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="prototype">
        <description>Event fired when a row is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="prototype">
        <description>Event fired when mouse moves over a data row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="prototype">
        <description>Event fired when mouse moves out of a data row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="prototype">
        <description>Event fired when mouse is down in a row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="prototype">
        <description>Event fired when a row context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="prototype">
        <description>Event fired when mouse moves over the grid header.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="prototype">
        <description>Event fired when mouse moves out of the grid header.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="prototype">
        <description>Event fired when mouse moves over a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="prototype">
        <description>Event fired when mouse moves out of a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="prototype">
        <description>Event fired when mouse is down in a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="prototype">
        <description>Event fired when the grid header is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="prototype">
        <description>Event fired when a header cell is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="prototype">
        <description>Event fired when the grid header is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="prototype">
        <description>Event fired when a header cell is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="prototype">
        <description>Event fired when a header cell context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="prototype">
        <description>Event fired when the grid header context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onStartEdit" scope="prototype">
        <description>Event fired when editing is started for a given grid cell</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="prototype">
        <description>Event fired when editing is applied for a given grid cell</description>
        <parameters>
          <parameter name="inValue" type="String" usage="required">
            <description>Value from cell editor</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
          <parameter name="inFieldIndex" type="Integer" usage="required">
            <description>Index in the grid's data store</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="prototype">
        <description>Event fired when editing is cancelled for a given grid cell</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyEdit" scope="prototype">
        <description>Event fired when editing is applied for a given grid row</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCanSelect" scope="prototype">
        <description>Event to determine if a grid row may be selected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be selected</return-description>
      </method>
      <method name="onCanDeselect" scope="prototype">
        <description>Event to determine if a grid row may be deselected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be deselected</return-description>
      </method>
      <method name="onSelected" scope="prototype">
        <description>Event fired when a grid row is selected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <description>Event fired when a grid row is deselected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="prototype"/>
    </methods>
    <properties>
      <property name="cellOverClass" scope="prototype" type="String">
        <description>css class to apply to grid cells over which the cursor is placed.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager">
    <description>Controls grid cell focus. Owned by grid and used internally for focusing.
	Note: grid cell actually receives keyboard input only when cell is being edited.</description>
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="initFocusView" scope="prototype"/>
      <method name="isFocusCell" scope="prototype">
        <description>states if the given cell is focused</description>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>true of the given grid cell is focused</return-description>
      </method>
      <method name="isLastFocusCell" scope="prototype"/>
      <method name="isFirstFocusCell" scope="prototype"/>
      <method name="isNoFocusCell" scope="prototype"/>
      <method name="isNavHeader" scope="prototype">
        <description>states whether currently navigating among column headers.</description>
        <return-description>true if focus is on a column header; false otherwise.</return-description>
      </method>
      <method name="getHeaderIndex" scope="prototype">
        <description>if one of the column headers currently has focus, return its index.</description>
        <return-description>index of the focused column header, or -1 if none have focus.</return-description>
      </method>
      <method name="_focusifyCellNode" scope="prototype">
        <parameters>
          <parameter name="inBork" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initColumnHeaders" scope="prototype"/>
      <method name="_findHeaderCells" scope="prototype"/>
      <method name="scrollIntoView" scope="prototype"/>
      <method name="_scrollInfo" scope="prototype">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollHeader" scope="prototype">
        <parameters>
          <parameter name="currentIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="prototype">
        <description>focuses the given grid cell</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="int" usage="required">
            <description>grid cell index</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFocusCell" scope="prototype">
        <description>focuses the given grid cell</description>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="next" scope="prototype">
        <description>focus next grid cell</description>
      </method>
      <method name="previous" scope="prototype">
        <description>focus previous grid cell</description>
      </method>
      <method name="move" scope="prototype">
        <description>focus grid cell or column header based on position relative to current focus</description>
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required">
            <description>vertical distance from current focus</description>
          </parameter>
          <parameter name="inColDelta" type="int" usage="required">
            <description>horizontal distance from current focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="previousKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tabOut" scope="prototype">
        <parameters>
          <parameter name="inFocusNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusGridView" scope="prototype"/>
      <method name="focusGrid" scope="prototype">
        <parameters>
          <parameter name="inSkipFocusCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusHeader" scope="prototype"/>
      <method name="doFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doBlurHeader" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_colHeadNode" scope="instance-prototype" type="Object"/>
      <property name="tabbingOut" scope="instance-prototype" type="Object"/>
      <property name="focusClass" scope="prototype" type="Object"/>
      <property name="focusView" scope="instance-prototype" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="rowIndex" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell.view.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid" superclass="dijit._Widget">
    <description>A grid widget with virtual scrolling, cell editing, complex rows,
	sorting, fixed columns, sizeable columns, etc.</description>
    <example>A quick sample:
	define a get function
		function get(inRowIndex){ // called in cell context
			return [this.index, inRowIndex].join(', ');
		}
	define the grid structure:
		var structure = [ // array of view objects
			{ cells: [// array of rows, a row is an array of cells
				[
					{ name: "Alpha", width: 6 },
					{ name: "Beta" },
					{ name: "Gamma", get: get }]
			]}
		];
		&lt;div id="grid"
			rowCount="100" get="get"
			structure="structure"
			dojoType="dojox.grid._Grid"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="get" scope="instance-prototype">
        <description>Default data getter.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Row for which to provide data</description>
          </parameter>
        </parameters>
        <return-description>Data to display for a given grid cell.</return-description>
      </method>
      <method name="buildRendering" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_setAutoHeightAttr" scope="prototype">
        <parameters>
          <parameter name="ah" type="Object" usage="required"/>
          <parameter name="skipRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleChanged" scope="instance-prototype"/>
      <method name="_styleChanged" scope="prototype"/>
      <method name="textSizeChanged" scope="prototype"/>
      <method name="_textSizeChanged" scope="prototype"/>
      <method name="sizeChange" scope="prototype"/>
      <method name="renderOnIdle" scope="prototype"/>
      <method name="createManagers" scope="prototype">
        <description>create grid managers for various tasks including rows, focus, selection, editing</description>
      </method>
      <method name="createSelection" scope="prototype"/>
      <method name="createScroller" scope="prototype">
        <description>Creates a new virtual scroller</description>
      </method>
      <method name="createLayout" scope="prototype">
        <description>Creates a new Grid layout</description>
      </method>
      <method name="onMoveColumn" scope="prototype"/>
      <method name="createViews" scope="prototype"/>
      <method name="createView" scope="prototype">
        <parameters>
          <parameter name="inClass" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildViews" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <description>Install a new structure and rebuild the grid.</description>
        <parameters>
          <parameter name="inStructure" type="Object" usage="required">
            <description>Structure object defines the grid layout and provides various
	options for grid views and columns</description>
          </parameter>
        </parameters>
      </method>
      <method name="getColumnTogglingItems" scope="prototype"/>
      <method name="setHeaderMenu" scope="prototype">
        <parameters>
          <parameter name="menu" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setupHeaderMenu" scope="prototype"/>
      <method name="_fetch" scope="prototype">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_structureChanged" scope="prototype"/>
      <method name="hasLayout" scope="prototype"/>
      <method name="resize" scope="prototype">
        <description>Update the grid's rendering dimensions and resize it
	sizeBox: Object?
	{w: int, h: int, l: int, t: int}</description>
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorder" scope="prototype"/>
      <method name="_getHeaderHeight" scope="prototype"/>
      <method name="_resize" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="adaptHeight" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="render" scope="prototype">
        <description>Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
	scrolling states, see Update.</description>
      </method>
      <method name="_render" scope="prototype"/>
      <method name="prerender" scope="prototype"/>
      <method name="postrender" scope="prototype"/>
      <method name="postresize" scope="prototype"/>
      <method name="renderRow" scope="prototype">
        <description>private, used internally to render rows</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <description>private, used internally to remove rows</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginUpdate" scope="prototype">
        <description>Use to make multiple changes to rows while queueing row updating.
	NOTE: not currently supporting nested begin/endUpdate calls</description>
      </method>
      <method name="endUpdate" scope="prototype">
        <description>Use after calling beginUpdate to render any changes made to rows.</description>
      </method>
      <method name="defaultUpdate" scope="prototype"/>
      <method name="update" scope="instance-prototype">
        <description>Update the grid, retaining edit and scrolling states.</description>
      </method>
      <method name="updateRow" scope="prototype">
        <description>Render a single row.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the row to render</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRows" scope="prototype">
        <description>Render consecutive rows at once.</description>
        <parameters>
          <parameter name="startIndex" type="Integer" usage="required">
            <description>Index of the starting row to render</description>
          </parameter>
          <parameter name="howMany" type="Integer" usage="required">
            <description>How many rows to update.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowCount" scope="prototype">
        <description>Change the number of rows.</description>
        <parameters>
          <parameter name="inRowCount" type="int" usage="required">
            <description>Number of rows in the grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <description>Update the styles for a row after it's state has changed.</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <description>Update grid when the height of a row has changed. Row height is handled automatically as rows
	are rendered. Use this function only to update a row's height outside the normal rendering process.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>index of the row that has changed height</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollTo" scope="prototype">
        <description>Vertically scroll the grid to a given pixel position</description>
        <parameters>
          <parameter name="inTop" type="Integer" usage="required">
            <description>vertical position of the grid in pixels</description>
          </parameter>
        </parameters>
      </method>
      <method name="finishScrollJob" scope="prototype"/>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="prototype">
        <description>Scroll the grid to a specific row.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseOut" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCell" scope="prototype">
        <description>Retrieves the cell object for a given grid column.</description>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Grid column index of cell to retrieve</description>
          </parameter>
        </parameters>
        <return-description>a grid cell</return-description>
      </method>
      <method name="setCellWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inUnitWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <description>Returns the cell name of a passed cell</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="canSort" scope="prototype">
        <description>Determines if the grid can be sorted</description>
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <description>Sort information, 1-based index of column on which to sort, positive for an ascending sort
	and negative for a descending sort</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="getSortAsc" scope="prototype">
        <description>Returns true if grid is sorted in an ascending direction.</description>
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getSortIndex" scope="prototype">
        <description>Returns the index of the column on which the grid is sorted</description>
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setSortIndex" scope="prototype">
        <description>Sort the grid on a column in a specified direction</description>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Column index on which to sort.</description>
          </parameter>
          <parameter name="inAsc" type="Boolean" usage="required">
            <description>If true, sort the grid in ascending order, otherwise in descending order</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSortInfo" scope="prototype">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="prototype">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRow" scope="prototype">
        <description>Add a row to the grid.</description>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <description>Remove the selected rows from the grid.</description>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="for vendetta"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dojox.grid._Events" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dojox.grid._Events" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="classTag" scope="prototype" type="String">
        <description>CSS class applied to the grid's domNode</description>
      </property>
      <property name="rowCount" scope="instance-prototype" type="settings">
        <description>Integer
	Number of rows to display.</description>
      </property>
      <property name="keepRows" scope="instance-prototype" type="Integer">
        <description>Number of rows to keep in the rendering cache.</description>
      </property>
      <property name="rowsPerPage" scope="prototype" type="Integer">
        <description>Number of rows to render at a time.</description>
      </property>
      <property name="autoWidth" scope="prototype" type="Boolean">
        <description>If autoWidth is true, grid width is automatically set to fit the data.</description>
      </property>
      <property name="autoHeight" scope="instance-prototype" type="Boolean|Integer">
        <description>If autoHeight is true, grid height is automatically set to fit the data.
	If it is an integer, the height will be automatically set to fit the data
	if there are fewer than that many rows - and the height will be set to show
	that many rows if there are more</description>
      </property>
      <property name="autoRender" scope="prototype" type="Boolean">
        <description>If autoRender is true, grid will render itself after initialization.</description>
      </property>
      <property name="defaultHeight" scope="prototype" type="String">
        <description>default height of the grid, measured in any valid css unit.</description>
      </property>
      <property name="height" scope="instance-prototype" type="String">
        <description>explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
	if the height: css attribute exists on the source node.</description>
      </property>
      <property name="structure" scope="prototype" type="Object|String">
        <description>View layout defintion. Can be set to a layout object, or to the (string) name of a layout object.</description>
      </property>
      <property name="elasticView" scope="prototype" type="Integer">
        <description>Override defaults and make the indexed grid view elastic, thus filling available horizontal space.</description>
      </property>
      <property name="singleClickEdit" scope="prototype" type="boolean">
        <description>Single-click starts editing. Default is double-click</description>
      </property>
      <property name="selectionMode" scope="prototype" type="String">
        <description>Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
	or 'extended'.  Default is 'extended'.</description>
      </property>
      <property name="rowSelector" scope="prototype" type="Boolean|String">
        <description>If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
	a row selector of that width to this grid.</description>
      </property>
      <property name="columnReordering" scope="prototype" type="Boolean">
        <description>If set to true, will add drag and drop reordering to views with one row of columns.</description>
      </property>
      <property name="headerMenu" scope="instance-prototype" type="dijit.Menu">
        <description>If set to a dijit.Menu, will use this as a context menu for the grid headers.</description>
      </property>
      <property name="placeholderLabel" scope="prototype" type="String">
        <description>Label of placeholders to search for in the header menu to replace with column toggling
	menu items.</description>
      </property>
      <property name="_click" scope="instance-prototype" type="Object"/>
      <property name="loadingMessage" scope="instance-prototype" type="String">
        <description>Message that shows while the grid is loading</description>
      </property>
      <property name="errorMessage" scope="instance-prototype" type="String">
        <description>Message that shows when the grid encounters an error loading</description>
      </property>
      <property name="noDataMessage" scope="prototype" type="String">
        <description>Message that shows if the grid has no data - wrap it in a
	span with class 'dojoxGridNoData' if you want it to be
	styled similar to the loading and error messages</description>
      </property>
      <property name="sortInfo" scope="instance-prototype" type="Object"/>
      <property name="themeable" scope="prototype" type="Object"/>
      <property name="_placeholders" scope="instance-prototype" type="Object"/>
      <property name="updating" scope="instance-prototype" type="Object"/>
      <property name="fastScroll" scope="prototype" type="Boolean">
        <description>flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
	scroll performance but more immediate scrolling feedback</description>
      </property>
      <property name="delayScroll" scope="instance-prototype" type="Object"/>
      <property name="scrollRedrawThreshold" scope="prototype" type="int">
        <description>pixel distance a user must scroll vertically to trigger grid scrolling.</description>
      </property>
      <property name="_autoHeight" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
      <property name="_sizeBox" scope="instance" type="Object"/>
      <property name="_padBorder" scope="instance" type="Object"/>
      <property name="fitTo" scope="instance" type="Object"/>
      <property name="lastScrollTop" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode">
    <properties>
      <property name="tabIndex" scope="instance" type="Object"/>
      <property name="onReveal" scope="instance" type="Object"/>
      <property name="onSizeChange" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.scroller">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_pageIdPrefix" scope="instance" type="Object"/>
      <property name="renderRow" scope="instance" type="Object"/>
      <property name="removeRow" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.views">
    <properties>
      <property name="createView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsHeaderNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.invalidated">
    <properties>
      <property name="all" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout">
    <description>Controls grid cell layout. Owned by grid and used internally.</description>
    <methods>
      <method name="moveColumn" scope="prototype">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnVisibility" scope="prototype">
        <parameters>
          <parameter name="columnIndex" type="Object" usage="required"/>
          <parameter name="visible" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance-prototype" type="Object"/>
      <property name="structure" scope="instance-prototype" type="Object"/>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="_defaultCellProps" scope="instance" type="Object"/>
      <property name="fieldIndex" scope="instance" type="Object"/>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout.grid">
    <properties>
      <property name="sortInfo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowManager">
    <methods>
      <method name="prepareStylingRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="linesToEms" scope="prototype" type="Object"/>
      <property name="overRow" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector" superclass="dojox.grid._View">
    <description>Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.</description>
    <methods>
      <method name="buildRendering" scope="prototype"/>
      <method name="getWidth" scope="prototype"/>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="noscroll" scope="prototype" type="Object"/>
      <property name="padBorderWidth" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller">
    <methods>
      <method name="init" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
          <parameter name="inKeepRows" type="Object" usage="required"/>
          <parameter name="inRowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageCount" scope="prototype">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
          <parameter name="rowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="setKeepInfo" scope="prototype">
        <parameters>
          <parameter name="inKeepRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContentNodes" scope="prototype">
        <parameters>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="prototype"/>
      <method name="invalidate" scope="prototype"/>
      <method name="updateRowCount" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="prototype">
        <parameters>
          <parameter name="inShouldPacify" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPacifying" scope="prototype">
        <parameters>
          <parameter name="inPacifying" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="prototype"/>
      <method name="doPacify" scope="prototype"/>
      <method name="endPacify" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="calcLastPageHeight" scope="prototype"/>
      <method name="updateContentHeight" scope="prototype">
        <parameters>
          <parameter name="inDh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="prototype"/>
      <method name="createPageNode" scope="prototype"/>
      <method name="getPageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="prototype"/>
      <method name="findPage" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="prototype"/>
      <method name="scroll" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultPageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRow" scope="prototype">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowCount" scope="instance-prototype" type="Object"/>
      <property name="defaultRowHeight" scope="prototype" type="Object"/>
      <property name="keepRows" scope="instance-prototype" type="Object"/>
      <property name="contentNode" scope="prototype" type="Object"/>
      <property name="defaultPageHeight" scope="instance-prototype" type="Object"/>
      <property name="keepPages" scope="instance-prototype" type="Object"/>
      <property name="pageCount" scope="instance-prototype" type="Object"/>
      <property name="windowHeight" scope="instance-prototype" type="Object"/>
      <property name="firstVisibleRow" scope="instance-prototype" type="Object"/>
      <property name="lastVisibleRow" scope="instance-prototype" type="Object"/>
      <property name="averageRowHeight" scope="instance-prototype" type="Object"/>
      <property name="page" scope="instance-prototype" type="Object"/>
      <property name="pageTop" scope="instance-prototype" type="Object"/>
      <property name="pacifying" scope="instance-prototype" type="Object"/>
      <property name="pacifyTicks" scope="prototype" type="Object"/>
      <property name="dummy" scope="prototype" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="contentNodes" scope="instance" type="Object"/>
      <property name="colCount" scope="instance" type="Object"/>
      <property name="pageNodes" scope="instance" type="Object"/>
      <property name="pageHeights" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="startPacifyTicks" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.scrollboxNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
      <property name="onscroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View" superclass="dijit._Widget">
    <description>A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
	Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views directly.</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="focus" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="testFlexCells" scope="prototype"/>
      <method name="updateStructure" scope="prototype"/>
      <method name="getScrollbarWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setColumnsWidth" scope="prototype">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getContentWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="render" scope="prototype"/>
      <method name="_onDndDropBefore" scope="prototype">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDrop" scope="prototype">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="prototype"/>
      <method name="_getHeaderContent" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="hasHScrollbar" scope="prototype">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasVScrollbar" scope="prototype">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="convertColPctToFixed" scope="prototype"/>
      <method name="adaptHeight" scope="prototype">
        <parameters>
          <parameter name="minusScroll" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="prototype"/>
      <method name="setSize" scope="prototype">
        <parameters>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderCellNode" scope="prototype">
        <parameters>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doscroll" scope="prototype">
        <parameters>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="prototype" type="String">
        <description>Default width of the view</description>
      </property>
      <property name="viewWidth" scope="instance-prototype" type="String">
        <description>Width for the view, in valid css unit</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="themeable" scope="prototype" type="Object"/>
      <property name="classTag" scope="prototype" type="Object"/>
      <property name="marginBottom" scope="prototype" type="Object"/>
      <property name="rowPad" scope="prototype" type="Object"/>
      <property name="_togglingColumn" scope="instance-prototype" type="int">
        <description>Width of the column being toggled (-1 for none)</description>
      </property>
      <property name="rowRemoved" scope="prototype" type="Object"/>
      <property name="lastTop" scope="instance-prototype" type="Object"/>
      <property name="firstScroll" scope="instance-prototype" type="Object"/>
      <property name="rowNodes" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="structure" scope="instance" type="Object"/>
      <property name="onBeforeRow" scope="instance" type="Object"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="simpleStructure" scope="instance" type="Object"/>
      <property name="flexCells" scope="instance" type="Object"/>
      <property name="_source_conn" scope="instance" type="Object"/>
      <property name="_source_sub" scope="instance" type="Object"/>
      <property name="_removingColumn" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
      <property name="_hasHScroll" scope="instance" type="Object"/>
      <property name="_hasVScroll" scope="instance" type="Object"/>
      <property name="_pendingUpdate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.source">
    <properties>
      <property name="_targetNode" scope="instance" type="Object"/>
      <property name="_beforeTarget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="construct" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="oldOffsetY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ContentBuilder">
    <properties>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="HeaderBuilder">
    <properties>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager">
    <description>A collection of grid views. Owned by grid and used internally for managing grid views.</description>
    <methods>
      <method name="resize" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="addView" scope="prototype">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="prototype"/>
      <method name="getContentNodes" scope="prototype"/>
      <method name="forEach" scope="prototype">
        <parameters>
          <parameter name="inCallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEach" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="prototype"/>
      <method name="normalizeRowNodeHeights" scope="prototype">
        <parameters>
          <parameter name="inRowNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resetHeaderNodeHeight" scope="prototype"/>
      <method name="renormalizeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getViewWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measureHeader" scope="prototype"/>
      <method name="measureContent" scope="prototype"/>
      <method name="findClient" scope="prototype">
        <parameters>
          <parameter name="inAutoWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="prototype">
        <parameters>
          <parameter name="l" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="prototype">
        <description>Returns the first grid view with a scroll bar</description>
      </method>
    </methods>
    <properties>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="views" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base">
    <description>Respresents a grid cell and contains information about column options and methods
	for retrieving cell related information.
	Each column in a grid layout has a cell object and most events and many methods
	provide access to these objects.</description>
    <methods>
      <method name="format" scope="prototype">
        <description>provides the html for a given grid cell.</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>html for a given grid cell</return-description>
      </method>
      <method name="formatEditing" scope="prototype">
        <description>formats the cell for editing</description>
        <parameters>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>string of html to place in grid cell</return-description>
      </method>
      <method name="getNode" scope="prototype">
        <description>gets the dom node for a given grid cell.</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>dom node for a given grid cell</return-description>
      </method>
      <method name="getHeaderNode" scope="prototype"/>
      <method name="getEditNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canResize" scope="prototype"/>
      <method name="isFlex" scope="prototype"/>
      <method name="applyEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needFormatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="prototype"/>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <description>format the editing dom node. Use when editor is a widget.</description>
        <parameters>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	dom node for the editor</description>
          </parameter>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>returns value entered into editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>value of editor</return-description>
      </method>
      <method name="setValue" scope="prototype">
        <description>set the value of the grid editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inValue" type="anything" usage="required">
            <description>value of editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <description>focus the grid editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	editor node</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <description>save editor state</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <description>restore editor state</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <description>called when editing is completed to clean up editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="apply" scope="prototype">
        <description>apply edit from cell editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" scope="prototype">
        <description>cancel cell edit</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="styles" scope="prototype" type="Object"/>
      <property name="classes" scope="prototype" type="Object"/>
      <property name="editable" scope="prototype" type="Object"/>
      <property name="alwaysEditing" scope="prototype" type="Object"/>
      <property name="formatter" scope="prototype" type="Object"/>
      <property name="defaultValue" scope="prototype" type="Object"/>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="hidden" scope="prototype" type="Object"/>
      <property name="_valueProp" scope="prototype" type="Object"/>
      <property name="_formatPending" scope="instance-prototype" type="Object"/>
      <property name="_props" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Cell" superclass="dgc._Base">
    <methods>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="keyFilter" scope="instance-prototype" type="RegExp">
        <description>optional regex for disallowing keypresses</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowIndex" superclass="dgc.Cell">
    <methods>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="name" scope="prototype" type="Object"/>
      <property name="editable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Select" superclass="dgc.Cell">
    <description>grid cell that provides a standard select for editing</description>
    <methods>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="options" scope="prototype" type="Object"/>
      <property name="values" scope="instance-prototype" type="Array">
        <description>value for each item</description>
      </property>
      <property name="returnIndex" scope="prototype" type="Integer">
        <description>editor returns only the index of the selected option and not the value</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit" superclass="dgc.Cell">
    <description>grid cell that is always in an editable state, regardless of grid editing state</description>
    <methods>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStaticValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="alwaysEditing" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Bool" superclass="dgc.AlwaysEdit">
    <description>grid cell that provides a standard checkbox that is always on for editing</description>
    <methods>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_valueProp" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Widget" superclass="dgc._Base">
    <methods>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetClass" scope="instance-prototype" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.ComboBox" superclass="dgc._Widget">
    <methods>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.DateTextBox" superclass="dgc._Widget">
    <methods>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.CheckBox" superclass="dgc._Widget">
    <methods>
      <method name="getValue" scope="prototype"/>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Editor" superclass="dgc._Widget">
    <methods>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="populateEditor" scope="prototype"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetClass" scope="prototype" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.Grid" superclass="dojox.VirtualGrid">
    <description>A grid widget with virtual scrolling, cell editing, complex rows,
	sorting, fixed columns, sizeable columns, etc.</description>
    <example>define the grid structure:
		var structure = [ // array of view objects
			{ cells: [// array of rows, a row is an array of cells
				[	{ name: "Alpha", width: 6 },
					{ name: "Beta" },
					{ name: "Gamma", get: formatFunction }
				]
			]}
		];
	define a grid data model
		var model = new dojox.grid.data.table(null, data);
		&lt;div id="grid" model="model" structure="structure"
			dojoType="dojox.VirtualGrid"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_structureChanged" scope="prototype"/>
      <method name="_setModel" scope="prototype">
        <parameters>
          <parameter name="inModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setModel" scope="prototype">
        <description>Set the grid's data model</description>
        <parameters>
          <parameter name="inModel" type="Object" usage="required">
            <description>Model object, usually an instance of a dojox.grid.data.Model
	subclass</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <description>data socket (called in cell's context)</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modelAllChange" scope="prototype"/>
      <method name="modelBeginUpdate" scope="prototype"/>
      <method name="modelEndUpdate" scope="prototype"/>
      <method name="modelRowChange" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modelDatumChange" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modelFieldsChange" scope="prototype"/>
      <method name="modelInsertion" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modelRemoval" scope="prototype">
        <parameters>
          <parameter name="inKeys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="indexCellFields" scope="prototype"/>
      <method name="refresh" scope="prototype">
        <description>Re-render the grid, getting new data from the model</description>
      </method>
      <method name="canSort" scope="prototype">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSortField" scope="prototype">
        <description>Retrieves the model field on which to sort data.</description>
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <description>1-based grid column index; positive if sort is ascending, otherwise negative</description>
          </parameter>
        </parameters>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="addRow" scope="prototype">
        <parameters>
          <parameter name="inRowData" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="prototype"/>
      <method name="canEdit" scope="prototype">
        <description>Determines if a given cell may be edited</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>A grid cell</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given cell may be edited</return-description>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowState" scope="prototype">
        <description>Perform row styling</description>
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="for vendetta"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="model" scope="instance-prototype" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.compat">
    <properties>
      <property name="Grid" scope="instance" type="Object"/>
      <property name="VirtualGrid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid" superclass="dijit._Widget">
    <description>A grid widget with virtual scrolling, cell editing, complex rows,
	sorting, fixed columns, sizeable columns, etc.</description>
    <example>A quick sample:
	define a get function
		function get(inRowIndex){ // called in cell context
			return [this.index, inRowIndex].join(', ');
		}
	define the grid structure:
		var structure = [ // array of view objects
			{ cells: [// array of rows, a row is an array of cells
				[
					{ name: "Alpha", width: 6 },
					{ name: "Beta" },
					{ name: "Gamma", get: get }]
			]}
		];
		&lt;div id="grid"
			rowCount="100" get="get"
			structure="structure"
			dojoType="dojox.VirtualGrid"&gt;&lt;/div&gt;</example>
    <methods>
      <method name="get" scope="instance-prototype">
        <description>Default data getter.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Row for which to provide data</description>
          </parameter>
        </parameters>
        <return-description>Data to display for a given grid cell.</return-description>
      </method>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="styleChanged" scope="instance-prototype"/>
      <method name="_styleChanged" scope="prototype"/>
      <method name="textSizeChanged" scope="prototype"/>
      <method name="_textSizeChanged" scope="prototype"/>
      <method name="sizeChange" scope="prototype"/>
      <method name="renderOnIdle" scope="prototype"/>
      <method name="createManagers" scope="prototype">
        <description>create grid managers for various tasks including rows, focus, selection, editing
	row manager</description>
      </method>
      <method name="createScroller" scope="prototype">
        <description>Creates a new virtual scroller</description>
      </method>
      <method name="createLayout" scope="prototype">
        <description>Creates a new Grid layout</description>
      </method>
      <method name="createViews" scope="prototype"/>
      <method name="createView" scope="prototype">
        <parameters>
          <parameter name="inClass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildViews" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <description>Install a new structure and rebuild the grid.</description>
        <parameters>
          <parameter name="inStructure" type="Object" usage="required">
            <description>Structure object defines the grid layout and provides various
	options for grid views and columns</description>
          </parameter>
        </parameters>
      </method>
      <method name="_structureChanged" scope="prototype"/>
      <method name="hasLayout" scope="prototype"/>
      <method name="resize" scope="prototype">
        <description>Update the grid's rendering dimensions and resize it</description>
        <parameters>
          <parameter name="sizeBox" type="Object" usage="optional">
            <description>{w: int, h: int, l: int, t: int}
	FIXME: If grid is not sized explicitly, sometimes bogus scrollbars
	can appear in our container, which may require an extra call to 'resize'
	to sort out.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPadBorder" scope="prototype"/>
      <method name="_resize" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="adaptHeight" scope="prototype"/>
      <method name="render" scope="prototype">
        <description>Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
	scrolling states, see Update.</description>
      </method>
      <method name="prerender" scope="prototype"/>
      <method name="postrender" scope="prototype"/>
      <method name="postresize" scope="prototype"/>
      <method name="renderRow" scope="prototype">
        <description>private, used internally to render rows</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <description>private, used internally to remove rows</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginUpdate" scope="prototype">
        <description>Use to make multiple changes to rows while queueing row updating.</description>
      </method>
      <method name="endUpdate" scope="prototype">
        <description>Use after calling beginUpdate to render any changes made to rows.</description>
      </method>
      <method name="defaultUpdate" scope="prototype"/>
      <method name="update" scope="instance-prototype">
        <description>Update the grid, retaining edit and scrolling states.</description>
      </method>
      <method name="updateRow" scope="prototype">
        <description>Render a single row.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the row to render</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowCount" scope="prototype">
        <description>Change the number of rows.</description>
        <parameters>
          <parameter name="inRowCount" type="int" usage="required">
            <description>Number of rows in the grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <description>Update the styles for a row after it's state has changed.</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <description>Update grid when the height of a row has changed. Row height is handled automatically as rows
	are rendered. Use this function only to update a row's height outside the normal rendering process.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>index of the row that has changed height</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollTo" scope="prototype">
        <description>Vertically scroll the grid to a given pixel position</description>
        <parameters>
          <parameter name="inTop" type="Integer" usage="required">
            <description>vertical position of the grid in pixels</description>
          </parameter>
        </parameters>
      </method>
      <method name="finishScrollJob" scope="prototype"/>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="prototype">
        <description>Scroll the grid to a specific row.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCell" scope="prototype">
        <description>Retrieves the cell object for a given grid column.</description>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Grid column index of cell to retrieve</description>
          </parameter>
        </parameters>
        <return-description>a grid cell</return-description>
      </method>
      <method name="setCellWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inUnitWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <description>Returns the cell name of a passed cell</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="canSort" scope="prototype">
        <description>Determines if the grid can be sorted</description>
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <description>Sort information, 1-based index of column on which to sort, positive for an ascending sort
	and negative for a descending sort</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="getSortAsc" scope="prototype">
        <description>Returns true if grid is sorted in an ascending direction.</description>
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getSortIndex" scope="prototype">
        <description>Returns the index of the column on which the grid is sorted</description>
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setSortIndex" scope="prototype">
        <description>Sort the grid on a column in a specified direction</description>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Column index on which to sort.</description>
          </parameter>
          <parameter name="inAsc" type="Boolean" usage="required">
            <description>If true, sort the grid in ascending order, otherwise in descending order</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSortInfo" scope="prototype">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="prototype">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRow" scope="prototype">
        <description>Add a row to the grid.</description>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <description>Remove the selected rows from the grid.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <mixins scope="normal">
      <mixin type="dojox.grid.publicEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="classTag" scope="prototype" type="String">
        <description>CSS class applied to the grid's domNode</description>
      </property>
      <property name="rowCount" scope="instance-prototype" type="settings">
        <description>Integer
	Number of rows to display.</description>
      </property>
      <property name="keepRows" scope="instance-prototype" type="Integer">
        <description>Number of rows to keep in the rendering cache.</description>
      </property>
      <property name="rowsPerPage" scope="prototype" type="Integer">
        <description>Number of rows to render at a time.</description>
      </property>
      <property name="autoWidth" scope="prototype" type="Boolean">
        <description>If autoWidth is true, grid width is automatically set to fit the data.</description>
      </property>
      <property name="autoHeight" scope="prototype" type="Boolean">
        <description>If autoHeight is true, grid height is automatically set to fit the data.</description>
      </property>
      <property name="autoRender" scope="prototype" type="Boolean">
        <description>If autoRender is true, grid will render itself after initialization.</description>
      </property>
      <property name="defaultHeight" scope="prototype" type="String">
        <description>default height of the grid, measured in any valid css unit.</description>
      </property>
      <property name="structure" scope="instance-prototype" type="Object|String">
        <description>View layout defintion. Can be set to a layout object, or to the (string) name of a layout object.</description>
      </property>
      <property name="elasticView" scope="prototype" type="Integer">
        <description>Override defaults and make the indexed grid view elastic, thus filling available horizontal space.</description>
      </property>
      <property name="singleClickEdit" scope="prototype" type="boolean">
        <description>Single-click starts editing. Default is double-click</description>
      </property>
      <property name="_click" scope="instance-prototype" type="Object"/>
      <property name="sortInfo" scope="instance-prototype" type="Object"/>
      <property name="themeable" scope="prototype" type="Object"/>
      <property name="updating" scope="instance-prototype" type="Object"/>
      <property name="fastScroll" scope="prototype" type="Boolean">
        <description>flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
	scroll performance but more immediate scrolling feedback</description>
      </property>
      <property name="delayScroll" scope="instance-prototype" type="Object"/>
      <property name="scrollRedrawThreshold" scope="prototype" type="int">
        <description>pixel distance a user must scroll vertically to trigger grid scrolling.</description>
      </property>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
      <property name="_sizeBox" scope="instance" type="Object"/>
      <property name="_padBorder" scope="instance" type="Object"/>
      <property name="fitTo" scope="instance" type="Object"/>
      <property name="lastScrollTop" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.domNode">
    <properties>
      <property name="tabIndex" scope="instance" type="Object"/>
      <property name="onReveal" scope="instance" type="Object"/>
      <property name="onSizeChange" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.scroller">
    <properties>
      <property name="_pageIdPrefix" scope="instance" type="Object"/>
      <property name="renderRow" scope="instance" type="Object"/>
      <property name="removeRow" scope="instance" type="Object"/>
      <property name="defaultRowHeight" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.views">
    <properties>
      <property name="createView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.domNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.viewsHeaderNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.VirtualGrid.invalidated">
    <properties>
      <property name="rows" scope="instance" type="Object"/>
      <property name="all" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors">
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="input" scope="instance" type="Object"/>
      <property name="select" scope="instance" type="Object"/>
      <property name="alwaysOn" scope="instance" type="Object"/>
      <property name="bool" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.Dijit" superclass="dojox.grid.editors.base">
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEditorProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createEditor" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachEditor" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeEditor" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editorClass" scope="instance-prototype" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.ComboBox" superclass="dojox.grid.editors.Dijit">
    <methods>
      <method name="getEditorProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype"/>
    </methods>
    <properties>
      <property name="editorClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.DateTextBox" superclass="dojox.grid.editors.Dijit">
    <methods>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEditorProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editorClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.CheckBox" superclass="dojox.grid.editors.Dijit">
    <methods>
      <method name="getValue" scope="prototype"/>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeEditor" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editorClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.Editor" superclass="dojox.grid.editors.Dijit">
    <methods>
      <method name="getEditorProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createEditor" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="populateEditor" scope="prototype"/>
    </methods>
    <properties>
      <property name="editorClass" scope="prototype" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.compat._data">
    <properties>
      <property name="dijitEditors" scope="instance" type="Object"/>
      <property name="editors" scope="instance" type="Object"/>
      <property name="fields" scope="instance" type="Object"/>
      <property name="model" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.Base">
    <description>base grid editor class. Other grid editors should inherited from this class.</description>
    <methods>
      <method name="format" scope="prototype">
        <description>formats the cell for editing</description>
        <parameters>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>string of html to place in grid cell</return-description>
      </method>
      <method name="needFormatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="prototype"/>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <description>format the editing dom node. Use when editor is a widget.</description>
        <parameters>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	dom node for the editor</description>
          </parameter>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <description>returns value entered into editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>value of editor</return-description>
      </method>
      <method name="setValue" scope="prototype">
        <description>set the value of the grid editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inValue" type="anything" usage="required">
            <description>value of editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <description>focus the grid editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	editor node</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <description>save editor state</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <description>restore editor state</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <description>called when editing is completed to clean up editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="apply" scope="prototype">
        <description>apply edit from cell editor</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" scope="prototype">
        <description>cancel cell edit</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_valueProp" scope="prototype" type="Object"/>
      <property name="_formatPending" scope="instance-prototype" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.Input" superclass="dojox.grid.editors.Base">
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="keyFilter" scope="instance-prototype" type="object">
        <description>optional regex for disallowing keypresses</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.editors.Select" superclass="dojox.grid.editors.Input">
    <description>grid cell editor that provides a standard select
	options: text of each item
	values: value for each item
	returnIndex: editor returns only the index of the selected option and not the value</description>
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="options" scope="instance" type="Object"/>
      <property name="values" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.editors.AlwaysOn" superclass="dojox.grid.editors.Input">
    <description>grid cell editor that is always on, regardless of grid editing state</description>
    <methods>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStaticValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="alwaysOn" scope="prototype" type="boolean">
        <description>flag to use editor to format grid cell regardless of editing state.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.editors.Bool" superclass="dojox.grid.editors.AlwaysOn">
    <description>grid cell editor that provides a standard checkbox that is always on</description>
    <methods>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_valueProp" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data">
    <methods>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="table" scope="instance" type="Object"/>
      <property name="dynamic" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Mixer">
    <description>basic collection class that provides a default value for items</description>
    <methods>
      <method name="count" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="build" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefault" scope="prototype"/>
      <method name="setDefault" scope="prototype">
        <parameters>
          <parameter name="inField" type="[, inField2, ... inFiel" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inField" type="[, inField2, ... inFiel" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="set" scope="prototype"/>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inProps" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="swap" scope="prototype">
        <parameters>
          <parameter name="inIndexA" type="Object" usage="required"/>
          <parameter name="inIndexB" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="prototype">
        <parameters>
          <parameter name="inFromIndex" type="Object" usage="required"/>
          <parameter name="inToIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="values" scope="instance" type="Object"/>
      <property name="defaultValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Field">
    <properties>
      <property name="na" scope="prototype" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="compare" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Fields" superclass="dojox.grid.data.Mixer">
    <methods>
      <method name="indexOf" scope="prototype">
        <parameters>
          <parameter name="inKey" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="defaultValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Model">
    <description>Base abstract grid data model.
	Makes no assumptions about the structure of grid data.</description>
    <methods>
      <method name="observer" scope="prototype">
        <parameters>
          <parameter name="inObserver" type="Object" usage="required"/>
          <parameter name="inPrefix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="notObserver" scope="prototype">
        <parameters>
          <parameter name="inObserver" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="notify" scope="prototype">
        <parameters>
          <parameter name="inMsg" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="beginUpdate" scope="prototype"/>
      <method name="endUpdate" scope="prototype"/>
      <method name="clearData" scope="prototype"/>
      <method name="change" scope="prototype"/>
      <method name="insertion" scope="prototype"/>
      <method name="removal" scope="prototype"/>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="inData" type=", index" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inData" type=", index" usage="required"/>
        </parameters>
      </method>
      <method name="canSort" scope="prototype"/>
      <method name="generateComparator" scope="prototype">
        <parameters>
          <parameter name="inCompare" type="Object" usage="required"/>
          <parameter name="inField" type="Object" usage="required"/>
          <parameter name="inTrueForAscend" type="Object" usage="required"/>
          <parameter name="inSubCompare" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="prototype">
        <parameters>
          <parameter name="inIndices" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="prototype" type="Object"/>
      <property name="updating" scope="prototype" type="Object"/>
      <property name="sort" scope="prototype" type="Object"/>
      <property name="dummy" scope="prototype" type="Object"/>
      <property name="observers" scope="instance" type="Object"/>
      <property name="fields" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Rows" superclass="dojox.grid.data.Model">
    <methods>
      <method name="allChange" scope="prototype"/>
      <method name="rowChange" scope="prototype"/>
      <method name="datumChange" scope="prototype"/>
      <method name="beginModifyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endModifyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelModifyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.data.Table" superclass="dojox.grid.data.Rows">
    <description>Basic grid data model for static data in the form of an array of rows
	that are arrays of cell data</description>
    <methods>
      <method name="measure" scope="prototype"/>
      <method name="getRowCount" scope="prototype"/>
      <method name="getColCount" scope="prototype"/>
      <method name="badIndex" scope="prototype">
        <parameters>
          <parameter name="inCaller" type="Object" usage="required"/>
          <parameter name="inDescriptor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isGoodIndex" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="copyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDatum" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype"/>
      <method name="setData" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRow" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDatum" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="prototype"/>
      <method name="setRows" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype">
        <parameters>
          <parameter name="inOldData" type="Object" usage="required"/>
          <parameter name="inNewData" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insert" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="prototype">
        <parameters>
          <parameter name="inKeys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="swap" scope="prototype">
        <parameters>
          <parameter name="inIndexA" type="Object" usage="required"/>
          <parameter name="inIndexB" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="colCount" scope="instance-prototype" type="Object"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance-prototype" type="Object"/>
      <property name="dummy" scope="prototype" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Objects" superclass="dojox.grid.data.Table">
    <methods>
      <method name="allChange" scope="prototype"/>
      <method name="autoAssignFields" scope="prototype"/>
      <method name="setData" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDatum" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.Dynamic" superclass="dojox.grid.data.Table">
    <description>Grid data model for dynamic data such as data retrieved from a server.
	Retrieves data automatically when requested and provides notification when data is received</description>
    <methods>
      <method name="clearData" scope="prototype"/>
      <method name="getRowCount" scope="prototype"/>
      <method name="getColCount" scope="prototype"/>
      <method name="setRowCount" scope="prototype">
        <parameters>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requestsPending" scope="prototype">
        <parameters>
          <parameter name="inBoolean" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowToPage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageToRow" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requestRows" scope="prototype">
        <description>stub. Fill in to perform actual data row fetching logic. The
	returning logic must provide the data back to the system via
	setRow</description>
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowsProvided" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requestPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isRowLoaded" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePages" scope="prototype">
        <parameters>
          <parameter name="inRowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inRowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDatum" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDatum" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canSort" scope="prototype"/>
    </methods>
    <properties>
      <property name="page" scope="instance-prototype" type="Object"/>
      <property name="pages" scope="instance-prototype" type="Object"/>
      <property name="rowsPerPage" scope="prototype" type="Object"/>
      <property name="requests" scope="instance-prototype" type="Object"/>
      <property name="bop" scope="instance-prototype" type="Object"/>
      <property name="eop" scope="instance-prototype" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.DojoData" superclass="dojox.grid.data.Dynamic">
    <description>A grid data model for dynamic data retreived from a store which
	implements the dojo.data API set. Retrieves data automatically when
	requested and provides notification when data is received</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setData" scope="prototype">
        <parameters>
          <parameter name="inData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRowCount" scope="prototype">
        <parameters>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginReturn" scope="prototype">
        <parameters>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupFields" scope="prototype">
        <parameters>
          <parameter name="dataItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowFromItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRow" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processRows" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requestRows" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDatum" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDatum" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inColIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="copyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_attrCompare" scope="prototype">
        <parameters>
          <parameter name="cache" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endModifyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelModifyRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRowId" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowId" scope="prototype">
        <description>Function determine the row index for a particular item</description>
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>store item to examine to determine row index.</description>
          </parameter>
          <parameter name="isNotItem" type="Boolean" usage="required">
            <description>flag to indicate if the item passed is a store item or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_storeDatumChange" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="oldVal" type="Object" usage="required"/>
          <parameter name="newVal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_storeDatumDelete" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_storeDatumNew" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insertItem" scope="prototype">
        <parameters>
          <parameter name="storeItem" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="datumChange" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertion" scope="prototype"/>
      <method name="removal" scope="prototype"/>
      <method name="remove" scope="prototype">
        <description>Function to remove a set of items from the store based on the row index.</description>
        <parameters>
          <parameter name="inRowIndexes" type="An" usage="required">
            <description>array of row indexes from the grid to remove from the store.
	Call delete on the store</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItems" scope="prototype">
        <description>Function to remove a set of items from the store based on the row index.</description>
        <parameters>
          <parameter name="inRowIndexes" type="array" usage="required">
            <description>An array of row indexes from the grid to remove from the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="canSort" scope="prototype"/>
      <method name="sort" scope="prototype">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="prototype">
        <description>Function to cause the model to re-query the store and rebuild the current viewport.</description>
      </method>
      <method name="clearData" scope="prototype">
        <parameters>
          <parameter name="keepStore" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="processError" scope="prototype">
        <description>Hook function to trap error messages from the store and emit them.
	Intended for connecting to and handling the error object or at least reporting it.</description>
        <parameters>
          <parameter name="error" type="The" usage="required">
            <description>error object returned by the store when a problem occurred.</description>
          </parameter>
          <parameter name="request" type="The" usage="required">
            <description>request object that caused the error.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="_currentlyProcessing" scope="instance-prototype" type="Object"/>
      <property name="_canNotify" scope="instance-prototype" type="Object"/>
      <property name="_canWrite" scope="instance-prototype" type="Object"/>
      <property name="_canIdentify" scope="instance-prototype" type="Object"/>
      <property name="_rowIdentities" scope="instance-prototype" type="Object"/>
      <property name="clientSort" scope="prototype" type="Object"/>
      <property name="sortFields" scope="instance-prototype" type="Object"/>
      <property name="queryOptions" scope="prototype" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="_disableNew" scope="instance" type="Object"/>
      <property name="pages" scope="instance" type="Object"/>
      <property name="bop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.DojoData.query">
    <properties>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.data.DojoData.fields">
    <properties>
      <property name="_nameMaps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.Builder">
    <description>Base class to produce html for grid content.
	Also provide event decoration, providing grid related information inside the event object
	passed to grid events.</description>
    <methods>
      <method name="generateCellMarkup" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inMoreStyles" type="Object" usage="required"/>
          <parameter name="inMoreClasses" type="Object" usage="required"/>
          <parameter name="isHeader" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isCellNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNodeIndex" scope="prototype">
        <parameters>
          <parameter name="inCellNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findCellTarget" scope="prototype">
        <parameters>
          <parameter name="inSourceNode" type="Object" usage="required"/>
          <parameter name="inTopNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="baseDecorateEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTarget" scope="prototype">
        <parameters>
          <parameter name="inSource" type="Object" usage="required"/>
          <parameter name="inTag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findRowTarget" scope="prototype">
        <parameters>
          <parameter name="inSource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isIntraNodeEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isIntraRowEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="view" scope="instance-prototype" type="Object"/>
      <property name="_table" scope="prototype" type="Object"/>
      <property name="lastOverCellNode" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.contentBuilder" superclass="dojox.grid.Builder">
    <description>Produces html for grid data content. Owned by grid and used internally
	for rendering data. Override to implement custom rendering.</description>
    <methods>
      <method name="update" scope="prototype"/>
      <method name="prepareHtml" scope="prototype"/>
      <method name="generateHtml" scope="prototype">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decorateEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.headerBuilder" superclass="dojox.grid.Builder">
    <description>Produces html for grid header content. Owned by grid and used internally
	for rendering data. Override to implement custom rendering.</description>
    <methods>
      <method name="update" scope="prototype"/>
      <method name="generateHtml" scope="prototype">
        <parameters>
          <parameter name="inGetValue" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellX" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="prepareResize" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="mod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canResize" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="overLeftResizeArea" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="overRightResizeArea" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousemove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginColumnResize" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doResizeColumn" scope="prototype">
        <parameters>
          <parameter name="inDrag" type="Object" usage="required"/>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endResizeColumn" scope="prototype">
        <parameters>
          <parameter name="inDrag" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="bogusClickTime" scope="instance-prototype" type="Object"/>
      <property name="overResizeWidth" scope="prototype" type="Object"/>
      <property name="minColWidth" scope="prototype" type="Object"/>
      <property name="_table" scope="prototype" type="Object"/>
      <property name="tableMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.tableMap">
    <description>Maps an html table into a structure parsable for information about cell row and col spanning.
	Used by headerBuilder</description>
    <methods>
      <method name="mapRows" scope="prototype">
        <description>Map table topography</description>
        <parameters>
          <parameter name="inRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dumpMap" scope="prototype"/>
      <method name="getMapCoords" scope="prototype">
        <description>Find node's map coords by it's structure coords</description>
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
          <parameter name="inCol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="prototype">
        <description>Find a node in inNode's table with the given structure coords</description>
        <parameters>
          <parameter name="inTable" type="Object" usage="required"/>
          <parameter name="inRow" type="Object" usage="required"/>
          <parameter name="inCol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_findOverlappingNodes" scope="prototype">
        <parameters>
          <parameter name="inTable" type="Object" usage="required"/>
          <parameter name="inRow" type="Object" usage="required"/>
          <parameter name="inCol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findOverlappingNodes" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="map" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.compat._grid">
    <properties>
      <property name="builder" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="drag" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
      <property name="lib" scope="instance" type="Object"/>
      <property name="publicEvents" scope="instance" type="Object"/>
      <property name="rowbar" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="view" scope="instance" type="Object"/>
      <property name="views" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cell">
    <description>Respresents a grid cell and contains information about column options and methods
	for retrieving cell related information.
	Each column in a grid layout has a cell object and most events and many methods
	provide access to these objects.</description>
    <methods>
      <method name="format" scope="prototype">
        <description>provides the html for a given grid cell.</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>html for a given grid cell</return-description>
      </method>
      <method name="getNode" scope="prototype">
        <description>gets the dom node for a given grid cell.</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>dom node for a given grid cell</return-description>
      </method>
      <method name="isFlex" scope="prototype"/>
      <method name="applyEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="styles" scope="prototype" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dgdrag">
    <properties>
      <property name="dragging" scope="instance" type="Object"/>
      <property name="hysteresis" scope="instance" type="Object"/>
      <property name="capture" scope="instance" type="Object"/>
      <property name="release" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="calcDelta" scope="instance" type="Object"/>
      <property name="hasMoved" scope="instance" type="Object"/>
      <property name="mousemove" scope="instance" type="Object"/>
      <property name="mouseup" scope="instance" type="Object"/>
      <property name="click" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.edit">
    <description>Controls grid cell editing process. Owned by grid and used internally for editing.</description>
    <methods>
      <method name="destroy" scope="prototype"/>
      <method name="cellFocus" scope="prototype">
        <description>Invoke editing when cell is focused</description>
        <parameters>
          <parameter name="inCell" type="cell" usage="required">
            <description>object
	Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="rowClick" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEditing" scope="prototype">
        <description>Indicates editing state of the grid.</description>
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditCell" scope="prototype">
        <description>Indicates if the given cell is being edited.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <description>Grid cell index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given cell is being edited</return-description>
      </method>
      <method name="isEditRow" scope="prototype">
        <description>Indicates if the given row is being edited.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given row is being edited</return-description>
      </method>
      <method name="setEditCell" scope="prototype">
        <description>Set the given cell to be edited</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEditor" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusEditor" scope="prototype"/>
      <method name="_shouldCatchBoomerang" scope="prototype"/>
      <method name="_boomerangFocus" scope="prototype"/>
      <method name="_doCatchBoomerang" scope="prototype"/>
      <method name="start" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inEditing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editorApply" scope="prototype"/>
      <method name="editorCancel" scope="prototype"/>
      <method name="applyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyRowEdit" scope="prototype"/>
      <method name="apply" scope="prototype">
        <description>Apply a grid edit</description>
      </method>
      <method name="cancel" scope="prototype">
        <description>Cancel a grid edit</description>
      </method>
      <method name="save" scope="prototype">
        <description>Save the grid editing state</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <description>Restores the grid editing state</description>
        <parameters>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_boomerangWindow" scope="prototype" type="Object"/>
      <property name="_catchBoomerang" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="connections" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.edit.info">
    <properties>
      <property name="rowIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.focus">
    <description>Controls grid cell focus. Owned by grid and used internally for focusing.
	Note: grid cell actually receives keyboard input only when cell is being edited.</description>
    <methods>
      <method name="initFocusView" scope="prototype"/>
      <method name="isFocusCell" scope="prototype">
        <description>states if the given cell is focused</description>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>true of the given grid cell is focused</return-description>
      </method>
      <method name="isLastFocusCell" scope="prototype"/>
      <method name="isFirstFocusCell" scope="prototype"/>
      <method name="isNoFocusCell" scope="prototype"/>
      <method name="_focusifyCellNode" scope="prototype">
        <parameters>
          <parameter name="inBork" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="prototype"/>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="prototype">
        <description>focuses the given grid cell</description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="int" usage="required">
            <description>grid cell index</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFocusCell" scope="prototype">
        <description>focuses the given grid cell</description>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="next" scope="prototype">
        <description>focus next grid cell</description>
      </method>
      <method name="previous" scope="prototype">
        <description>focus previous grid cell</description>
      </method>
      <method name="move" scope="prototype">
        <description>focus grid cell based on position relative to current focus</description>
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required">
            <description>vertical distance from current focus</description>
          </parameter>
          <parameter name="inColDelta" type="int" usage="required">
            <description>horizontal distance from current focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="previousKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tabOut" scope="prototype">
        <parameters>
          <parameter name="inFocusNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusGridView" scope="prototype"/>
      <method name="focusGrid" scope="prototype">
        <parameters>
          <parameter name="inSkipFocusCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tabbingOut" scope="instance-prototype" type="Object"/>
      <property name="focusClass" scope="prototype" type="Object"/>
      <property name="focusView" scope="instance-prototype" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="rowIndex" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.layout">
    <description>Controls grid cell layout. Owned by grid and used internally.</description>
    <methods>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance-prototype" type="Object"/>
      <property name="structure" scope="instance-prototype" type="Object"/>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="fieldIndex" scope="instance" type="Object"/>
      <property name="cellCount" scope="instance" type="Object"/>
      <property name="_defaultCellProps" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.jobs">
    <methods>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="inHandle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="job" scope="instance">
        <parameters>
          <parameter name="inName" type="Object" usage="required"/>
          <parameter name="inDelay" type="Object" usage="required"/>
          <parameter name="inJob" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelJob" scope="instance">
        <parameters>
          <parameter name="inName" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="jobs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.publicEvents">
    <description>VirtualGrid mixin that provides default implementations for grid events.</description>
    <methods>
      <method name="onKeyEvent" scope="instance">
        <description>top level handler for Key Events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onContentEvent" scope="instance">
        <description>Top level handler for Content events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="instance">
        <description>Top level handler for header events</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <description>Perform row styling on a given row. Called whenever row styling is updated.</description>
        <example>onStyleRow({ selected: true, over:true, odd:false })</example>
        <parameters>
          <parameter name="inRow" type="Object" usage="required">
            <description>containing row state information: selected, true if the row is selcted; over:
	true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
	customStyles to control row css classes and styles; both properties are strings.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <description>Grid key event handler. By default enter begins editing and applies edits, escape cancels and edit,
	tab, shift-tab, and arrow keys move grid cell focus.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <description>Event fired when mouse is over the grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <description>Event fired when mouse moves out of the grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <description>Event fired when mouse is down inside grid.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="instance">
        <description>Event fired when mouse is over any row (data or header).</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="instance">
        <description>Event fired when mouse moves out of any row (data or header).</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="instance">
        <description>Event fired when mouse is down inside grid row</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="instance">
        <description>Event fired when mouse is over a cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="instance">
        <description>Event fired when mouse moves out of a cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <description>Event fired when mouse is down in a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <description>Event fired when a cell is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <description>Event fired when a cell is double-clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="instance">
        <description>Event fired when a cell context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellFocus" scope="instance">
        <description>Event fired when a cell receives focus.</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <description>Event fired when a row is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="instance">
        <description>Event fired when a row is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="instance">
        <description>Event fired when mouse moves over a data row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="instance">
        <description>Event fired when mouse moves out of a data row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="instance">
        <description>Event fired when mouse is down in a row.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <description>Event fired when a row context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="instance">
        <description>Event fired when mouse moves over the grid header.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="instance">
        <description>Event fired when mouse moves out of the grid header.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="instance">
        <description>Event fired when mouse moves over a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <description>Event fired when mouse moves out of a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <description>Event fired when mouse is down in a header cell.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <description>Event fired when the grid header is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <description>Event fired when a header cell is clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="instance">
        <description>Event fired when the grid header is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="instance">
        <description>Event fired when a header cell is double clicked.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="instance">
        <description>Event fired when a header cell context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="instance">
        <description>Event fired when the grid header context menu is accessed via mouse right click.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onStartEdit" scope="instance">
        <description>Event fired when editing is started for a given grid cell</description>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="instance">
        <description>Event fired when editing is applied for a given grid cell</description>
        <parameters>
          <parameter name="inValue" type="String" usage="required">
            <description>Value from cell editor</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
          <parameter name="inFieldIndex" type="Integer" usage="required">
            <description>Index in the grid's data model</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="instance">
        <description>Event fired when editing is cancelled for a given grid cell</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyEdit" scope="instance">
        <description>Event fired when editing is applied for a given grid row</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <description>Event to determine if a grid row may be selected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be selected</return-description>
      </method>
      <method name="onCanDeselect" scope="instance">
        <description>Event to determine if a grid row may be deselected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be deselected</return-description>
      </method>
      <method name="onSelected" scope="instance">
        <description>Event fired when a grid row is selected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <description>Event fired when a grid row is deselected</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
    </methods>
    <properties>
      <property name="cellOverClass" scope="instance" type="String">
        <description>css class to apply to grid cells over which the cursor is placed.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.GridRowView" superclass="dojox.GridView">
    <description>Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.</description>
    <methods>
      <method name="buildRendering" scope="prototype"/>
      <method name="getWidth" scope="prototype"/>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="noscroll" scope="prototype" type="Object"/>
      <property name="padBorderWidth" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridRowView.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridRowView.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.rows">
    <methods>
      <method name="getHeight" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultHeightPx" scope="prototype">
        <return-description>summmary:
	retrieves the default row height
	int, default row height</return-description>
      </method>
      <method name="prepareStylingRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="linesToEms" scope="prototype" type="Object"/>
      <property name="defaultRowHeight" scope="prototype" type="Object"/>
      <property name="overRow" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.scroller" superclass="dojox.grid.scroller.base">
    <description>virtual scroller class, makes no assumption about shape of items being scrolled</description>
    <methods>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="prototype"/>
      <method name="getDefaultPageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="prototype">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPageNodes" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReusePageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRowNodes" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRowNodes" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRowForNodes" scope="prototype">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTopForNodes" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRow" scope="prototype">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="prototype">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dummy" scope="prototype" type="Object"/>
      <property name="_defaultRowHeight" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="pageTop" scope="instance" type="Object"/>
      <property name="pageNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.scroller.base">
    <description>virtual scrollbox, abstract class
	Content must in /rows/
	Rows are managed in contiguous sets called /pages/
	There are a fixed # of rows per page
	The minimum rendered unit is a page</description>
    <methods>
      <method name="init" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
          <parameter name="inKeepRows" type="Object" usage="required"/>
          <parameter name="inRowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setKeepInfo" scope="prototype">
        <parameters>
          <parameter name="inKeepRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="updateRowCount" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="prototype">
        <parameters>
          <parameter name="inShouldPacify" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPacifying" scope="prototype">
        <parameters>
          <parameter name="inPacifying" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="prototype"/>
      <method name="doPacify" scope="prototype"/>
      <method name="endPacify" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="calcLastPageHeight" scope="prototype"/>
      <method name="updateContentHeight" scope="prototype">
        <parameters>
          <parameter name="inDh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="prototype"/>
      <method name="createPageNode" scope="prototype"/>
      <method name="getPageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="prototype"/>
      <method name="findPage" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="prototype"/>
      <method name="scroll" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowCount" scope="instance-prototype" type="Object"/>
      <property name="defaultRowHeight" scope="prototype" type="Object"/>
      <property name="keepRows" scope="instance-prototype" type="Object"/>
      <property name="contentNode" scope="prototype" type="Object"/>
      <property name="defaultPageHeight" scope="instance-prototype" type="Object"/>
      <property name="keepPages" scope="instance-prototype" type="Object"/>
      <property name="pageCount" scope="instance-prototype" type="Object"/>
      <property name="windowHeight" scope="instance-prototype" type="Object"/>
      <property name="firstVisibleRow" scope="instance-prototype" type="Object"/>
      <property name="lastVisibleRow" scope="instance-prototype" type="Object"/>
      <property name="page" scope="instance-prototype" type="Object"/>
      <property name="pageTop" scope="instance-prototype" type="Object"/>
      <property name="pacifying" scope="instance-prototype" type="Object"/>
      <property name="pacifyTicks" scope="prototype" type="Object"/>
      <property name="dummy" scope="prototype" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="pageHeights" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="startPacifyTicks" scope="instance" type="Object"/>
      <property name="stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.scroller.base.scrollboxNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
      <property name="onscroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.scroller.columns" superclass="dojox.grid.scroller">
    <description>Virtual scroller class that scrolls list of columns. Owned by grid and used internally
	for virtual scrolling.</description>
    <methods>
      <method name="setContentNodes" scope="prototype">
        <parameters>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="prototype"/>
      <method name="scroll" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="positionPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="contentNodes" scope="instance" type="Object"/>
      <property name="colCount" scope="instance" type="Object"/>
      <property name="pageNodes" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.selection">
    <description>Manages row selection for grid. Owned by grid and used internally
	for selection. Override to implement custom selection.</description>
    <methods>
      <method name="onCanSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="prototype"/>
      <method name="onChanged" scope="prototype"/>
      <method name="isSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="getSelectedCount" scope="prototype"/>
      <method name="beginUpdate" scope="prototype"/>
      <method name="endUpdate" scope="prototype"/>
      <method name="select" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unselectAll" scope="prototype">
        <parameters>
          <parameter name="inExcept" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftSelect" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inCtrlKey" type="Object" usage="required"/>
          <parameter name="inShiftKey" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
    </methods>
    <properties>
      <property name="multiSelect" scope="prototype" type="Object"/>
      <property name="selected" scope="instance-prototype" type="Object"/>
      <property name="updating" scope="instance-prototype" type="Object"/>
      <property name="selectedIndex" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView" superclass="dijit._Widget">
    <description>A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
	Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views directly.</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="focus" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="testFlexCells" scope="prototype"/>
      <method name="updateStructure" scope="prototype"/>
      <method name="getScrollbarWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getContentWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="render" scope="prototype"/>
      <method name="renderHeader" scope="prototype"/>
      <method name="_getHeaderContent" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="hasScrollbar" scope="prototype">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="adaptHeight" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="setSize" scope="prototype">
        <parameters>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inHeightPx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inHeightPx" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doscroll" scope="prototype">
        <parameters>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="prototype" type="String">
        <description>Default widget of the view</description>
      </property>
      <property name="viewWidth" scope="instance-prototype" type="String">
        <description>Width for the view, in valid css unit</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="themeable" scope="prototype" type="Object"/>
      <property name="classTag" scope="prototype" type="Object"/>
      <property name="marginBottom" scope="prototype" type="Object"/>
      <property name="rowPad" scope="prototype" type="Object"/>
      <property name="rowRemoved" scope="prototype" type="Object"/>
      <property name="lastTop" scope="instance-prototype" type="Object"/>
      <property name="firstScroll" scope="instance-prototype" type="Object"/>
      <property name="rowNodes" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="structure" scope="instance" type="Object"/>
      <property name="onBeforeRow" scope="instance" type="Object"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="flexCells" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.headerContentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.headerContentNode.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.GridView.headerNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.views">
    <description>A collection of grid views. Owned by grid and used internally for managing grid views.</description>
    <methods>
      <method name="resize" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="addView" scope="prototype">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="prototype"/>
      <method name="getContentNodes" scope="prototype"/>
      <method name="forEach" scope="prototype">
        <parameters>
          <parameter name="inCallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEach" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="prototype"/>
      <method name="normalizeRowNodeHeights" scope="prototype">
        <parameters>
          <parameter name="inRowNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resetHeaderNodeHeight" scope="prototype"/>
      <method name="renormalizeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getViewWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measureHeader" scope="prototype"/>
      <method name="measureContent" scope="prototype"/>
      <method name="findClient" scope="prototype">
        <parameters>
          <parameter name="inAutoWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="prototype">
        <parameters>
          <parameter name="l" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="prototype">
        <description>Returns the first grid view with a scroll bar</description>
      </method>
    </methods>
    <properties>
      <property name="defaultWidth" scope="prototype" type="Object"/>
      <property name="views" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.util">
    <methods>
      <method name="fire" scope="instance">
        <parameters>
          <parameter name="ob" type="Object" usage="required"/>
          <parameter name="ev" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleHeightPx" scope="instance">
        <parameters>
          <parameter name="inElement" type="Object" usage="required"/>
          <parameter name="inHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="funnelEvents" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inObject" type="Object" usage="required"/>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inEvents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayCompare" scope="instance">
        <parameters>
          <parameter name="inA" type="Object" usage="required"/>
          <parameter name="inB" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayInsert" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayRemove" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arraySwap" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inI" type="Object" usage="required"/>
          <parameter name="inJ" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="na" scope="instance" type="Object"/>
      <property name="mouseEvents" scope="instance" type="Object"/>
      <property name="keyEvents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help">
    <description>Adds the help function to all variables.</description>
    <methods>
      <method name="locate" scope="instance">
        <description>Search for dojo functionality that has something to do with the given string.</description>
        <parameters>
          <parameter name="searchFor" type="String" usage="required"/>
          <parameter name="searchIn" type="String|Object|String[]|Object[]" usage="required">
            <description>The namespaces to search in. Defaults to dojox.help._namespaces</description>
          </parameter>
          <parameter name="maxResults" type="Number" usage="required">
            <description>The maximum number of results.</description>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <description>Useful if you reset some values, and want to restore their
	help function</description>
        <parameters>
          <parameter name="namespace" type="String" usage="optional">
            <description>The string-representation of a namespace.</description>
          </parameter>
          <parameter name="recursive" type="Boolean" usage="optional">
            <description>Whether to recurse through the namespace.</description>
          </parameter>
        </parameters>
      </method>
      <method name="noConflict" scope="instance">
        <description>Use this function when you want to resolve the problems
	created by including a dojox.help package.</description>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>If you pass an item, only that item will be cleaned</description>
          </parameter>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <description>Should be called by one of the implementations. Runs startup code</description>
        <parameters>
          <parameter name="namespaces" type="String[]" usage="required">
            <description>Any namespaces to add to the default (dojox.help._namespaces)</description>
          </parameter>
          <parameter name="noConflict" type="Boolen" usage="optional">
            <description>Whether to start in noConflict mode</description>
          </parameter>
        </parameters>
      </method>
      <method name="_noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance">
        <parameters>
          <parameter name="self" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayLocated" scope="instance">
        <description>Stub function to be overridden in one of the dojox.help packages</description>
        <parameters>
          <parameter name="located" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayHelp" scope="instance">
        <description>Stub function to be overridden in one of the dojox.help packages</description>
        <parameters>
          <parameter name="loading" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addVersion" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripPrototype" scope="instance">
        <parameters>
          <parameter name="original" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_help" scope="instance"/>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toString" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__toString" scope="instance"/>
      <method name="_recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="__recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_plainText" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_namespaces" scope="instance" type="Object"/>
      <property name="_rpc" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance" type="Object"/>
      <property name="_toStrings" scope="instance" type="Object"/>
      <property name="_overrides" scope="instance" type="Object"/>
      <property name="_recursions" scope="instance" type="Object"/>
      <property name="_names" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="console" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dh">
    <properties>
      <property name="constants" scope="instance" type="Object"/>
      <property name="processString" scope="instance" type="Object"/>
      <property name="init" scope="instance" type="Object"/>
      <property name="Code" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="mode">
    <properties>
      <property name="keywordGroups" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="container">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="node">
    <properties>
      <property name="className" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="advice" scope="instance" type="Object"/>
      <property name="dynamic" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight">
    <description>A client-side syntax highlighting engine.</description>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages">
    <properties>
      <property name="_all" scope="instance" type="Object"/>
      <property name="_dynamic" scope="instance" type="Object"/>
      <property name="_static" scope="instance" type="Object"/>
      <property name="_www" scope="instance" type="Object"/>
      <property name="cpp" scope="instance" type="Object"/>
      <property name="css" scope="instance" type="Object"/>
      <property name="delphi" scope="instance" type="Object"/>
      <property name="django" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
      <property name="python" scope="instance" type="Object"/>
      <property name="sql" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dh.languages">
    <properties>
      <property name="cpp" scope="instance" type="Object"/>
      <property name="delphi" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
      <property name="python" scope="instance" type="Object"/>
      <property name="sql" scope="instance" type="Object"/>
      <property name="xml" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dhl">
    <properties>
      <property name="css" scope="instance" type="Object"/>
      <property name="django" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments._html"/>
  <class type="dojox.highlight.languages.pygments._html.tags">
    <properties>
      <property name="code" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="th" scope="instance" type="Object"/>
      <property name="big" scope="instance" type="Object"/>
      <property name="isindex" scope="instance" type="Object"/>
      <property name="meta" scope="instance" type="Object"/>
      <property name="body" scope="instance" type="Object"/>
      <property name="strong" scope="instance" type="Object"/>
      <property name="col" scope="instance" type="Object"/>
      <property name="select" scope="instance" type="Object"/>
      <property name="cite" scope="instance" type="Object"/>
      <property name="var" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="samp" scope="instance" type="Object"/>
      <property name="textarea" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments">
    <properties>
      <property name="_www" scope="instance" type="Object"/>
      <property name="css" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments.xml">
    <properties>
      <property name="a" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml">
    <properties>
      <property name="modes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html">
    <methods>
      <method name="_adjustCssPaths" scope="instance">
        <description>adjusts relative paths in cssText to be relative to cssUrl
	a path is considered relative if it doesn't start with '/' and not contains ':'</description>
        <parameters>
          <parameter name="cssUrl" type="Object" usage="required"/>
          <parameter name="cssText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustHtmlPaths" scope="instance">
        <parameters>
          <parameter name="htmlUrl" type="Object" usage="required"/>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfStyles" scope="instance">
        <parameters>
          <parameter name="cssUrl" type="String" usage="required"/>
          <parameter name="cont" type="String" usage="required"/>
          <parameter name="styles" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="squelsh the &lt;style&gt; or &lt;link&gt;"/>
        </return-types>
      </method>
      <method name="_snarfScripts" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
          <parameter name="byRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="evalInGlobal" scope="instance">
        <parameters>
          <parameter name="code" type="Object" usage="required"/>
          <parameter name="appendNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>TODO: add all the other options
	inserts (replaces) the given content into the given node</description>
        <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element that will receive the content</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <description>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
      </method>
      <method name="insertCssRule" scope="instance">
        <parameters>
          <parameter name="selector" type="summary" usage="required">
            <description>Creates a style and attaches it to a dynamically created stylesheet
	arguments:
	A fully qualified class name, as it would appear in
	a CSS dojo.doc. Start classes with periods, target
	nodes with '#'. Large selectors can also be created
	like:
	 &amp;quot;#myDiv.myClass span input&amp;quot;</description>
          </parameter>
          <parameter name="declaration" type="A" usage="required">
            <description>single string that would make up a style block, not
	including the curly braces. Include semi-colons between
	statements. Do not use JavaScript style declarations
	in camel case, use as you would in a CSS dojo.doc:
	 &amp;quot;color:#ffoooo;font-size:12px;margin-left:5px;&amp;quot;</description>
          </parameter>
          <parameter name="styleSheetName" type="optional" usage="required">
            <description>)
	Name of the dynamic style sheet this rule should be
	inserted into. If is not found by that name, it is
	created. If no name is passed, the name &amp;quot;default&amp;quot; is
	used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeCssRule" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="declaration" type="Object" usage="required"/>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDynamicStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activeStyleSheet" scope="instance">
        <parameters>
          <parameter name="title" type="optional" usage="required"/>
        </parameters>
      </method>
      <method name="getPreferredStyleSheet" scope="instance"/>
      <method name="getToggledStyleSheets" scope="instance">
        <return-description>summary
	Searches HTML for style sheets that are "toggle-able" -
	can be enabled and disabled. These would include sheets
	with the title attribute, as well as the REL attribute.
	An array of all toggle-able style sheets
	TODO: 	Sets of style sheets could be grouped according to
	an ID and used in sets, much like different
	groups of radio buttons. It would not however be
	according to W3C spec</return-description>
      </method>
      <method name="getStyleSheets" scope="instance">
        <return-description>summary
	Collects all the style sheets referenced in the HTML page,
	including any incuded via @import.
	An hash map of all the style sheets.
	TODO: 	Does not recursively search for @imports, so it will
	only go one level deep.</return-description>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="styles" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter" superclass="dojo.html._ContentSetter">
    <methods>
      <method name="_renderStyles" scope="prototype">
        <parameters>
          <parameter name="styles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="empty" scope="prototype"/>
      <method name="onBegin" scope="prototype"/>
      <method name="onEnd" scope="prototype"/>
      <method name="tearDown" scope="prototype"/>
    </methods>
    <properties>
      <property name="adjustPaths" scope="prototype" type="Boolean">
        <description>Adjust relative paths in html string content to point to this page
	Only useful if you grab content from a another folder than the current one</description>
      </property>
      <property name="referencePath" scope="prototype" type="Object"/>
      <property name="renderStyles" scope="prototype" type="Object"/>
      <property name="executeScripts" scope="prototype" type="Object"/>
      <property name="scriptHasHooks" scope="prototype" type="Object"/>
      <property name="scriptHookReplacement" scope="prototype" type="Object"/>
      <property name="_styleNodes" scope="instance" type="Object"/>
      <property name="_styles" scope="instance" type="Object"/>
      <property name="_code" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="params">
    <mixins scope="normal">
      <mixin type="this.required" scope="instance"/>
    </mixins>
    <properties>
      <property name="content" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.metrics">
    <methods>
      <method name="getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getScrollbar" scope="instance"/>
      <method name="initOnFontResize" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFontResize" scope="instance"/>
      <method name="_fontresize" scope="instance"/>
    </methods>
    <properties>
      <property name="_fontResizeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image">
    <description>A collection of image related widgets</description>
  </class>
  <class type="dojox.image.Badge" superclass="dijit._Widget">
    <description>A simple grid of Images that loops through thumbnails</description>
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="_init" scope="prototype">
        <description>Setup and layout the images</description>
      </method>
      <method name="_getCell" scope="prototype">
        <description>Return information about the position for a given node</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getImage" scope="prototype">
        <description>Returns the next image in the list, or the first one if not available</description>
      </method>
      <method name="_enbiggen" scope="prototype">
        <description>Show the passed node in the picker</description>
        <parameters>
          <parameter name="e" type="Event|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUnder" scope="prototype">
        <description>figure out which three images are being covered, and
	determine if they need loaded or not</description>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disenbiggen" scope="prototype">
        <description>Hide the passed node (info.n), passing along properties
	received.</description>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="prototype">
        <description>Select an un-viewed image from the list, and show it</description>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="children" scope="prototype" type="String">
        <description>A CSS3 Selector that determines the node to become a child</description>
      </property>
      <property name="rows" scope="prototype" type="Integer">
        <description>Number of Rows to display</description>
      </property>
      <property name="cols" scope="prototype" type="Integer">
        <description>Number of Columns to display</description>
      </property>
      <property name="cellSize" scope="prototype" type="Integer">
        <description>Size in PX of each thumbnail</description>
      </property>
      <property name="delay" scope="prototype" type="Integer">
        <description>Time (in ms) to show the image before sizing down again</description>
      </property>
      <property name="threads" scope="prototype" type="Integer">
        <description>how many cycles will be going &amp;quot;simultaneously&amp;quot; (&amp;gt;2 not reccommended)</description>
      </property>
      <property name="easing" scope="instance-prototype" type="Function|String">
        <description>An easing function to use when showing the node (does not apply to shrinking)</description>
      </property>
      <property name="_nl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="props">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.FlickrBadge" superclass="dojox.image.Badge">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
    </methods>
    <properties>
      <property name="children" scope="prototype" type="Object"/>
      <property name="userid" scope="instance-prototype" type="String">
        <description>If you know your Flickr userid, you can set it to prevent a call to fetch the id</description>
      </property>
      <property name="username" scope="prototype" type="String">
        <description>Your Flickr username</description>
      </property>
      <property name="setid" scope="prototype" type="String">
        <description>The id of the set to display</description>
      </property>
      <property name="tags" scope="prototype" type="String|Array">
        <description>A comma separated list of tags or an array of tags to grab from Flickr</description>
      </property>
      <property name="searchText" scope="prototype" type="String">
        <description>Free text search.  Photos who's title, description, or tags contain the text will be displayed</description>
      </property>
      <property name="target" scope="prototype" type="String">
        <description>Where to display the pictures when clicked on.  Valid values are the same as the target attribute
	of the A tag.</description>
      </property>
      <property name="apikey" scope="prototype" type="Object"/>
      <property name="_store" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Gallery" superclass="dijit._Widget">
    <description>Gallery widget that wraps a dojox.image.ThumbnailPicker and dojox.image.SlideShow widget</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initializes the widget, creates the ThumbnailPicker and SlideShow widgets</description>
      </method>
      <method name="setDataStore" scope="prototype">
        <description>Sets the data store and request objects to read data from.</description>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>Resets the widget to its initial state</description>
      </method>
      <method name="showNextImage" scope="prototype">
        <description>Changes the image being displayed in the SlideShow to the next
	image in the data store</description>
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggleSlideshow" scope="prototype">
        <description>Switches the slideshow mode on and off.</description>
      </method>
      <method name="showImage" scope="prototype">
        <description>Shows the image at index 'idx'.
	idx: Number
	The position of the image in the data store to display</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="optional" usage="required">
            <description>Function Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_centerChildren" scope="prototype">
        <description>Ensures that the ThumbnailPicker and the SlideShow widgets
	are centered.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="prototype" type="Number">
        <description>Maximum height of an image in the SlideShow widget</description>
      </property>
      <property name="imageWidth" scope="prototype" type="Number">
        <description>Maximum width of an image in the SlideShow widget</description>
      </property>
      <property name="pageSize" scope="prototype" type="Number">
        <description>The number of records to retrieve from the data store per request.</description>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean">
        <description>If true, images are loaded before the user views them. If false, an
	image is loaded when the user displays it.</description>
      </property>
      <property name="linkAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</description>
      </property>
      <property name="imageThumbAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the thumbnail image.</description>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</description>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</description>
      </property>
      <property name="slideshowInterval" scope="prototype" type="Integer">
        <description>time in seconds, between image changes in the slide show.</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="thumbPicker" scope="instance" type="Object"/>
      <property name="slideShow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Lightbox" superclass="dijit._Widget">
    <description>A dojo-based Lightbox implementation.</description>
    <example>
		&lt;a href="image1.jpg" dojoType="dojox.image.Lightbox"&gt;show lightbox&lt;/a&gt;</example>
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="_addSelf" scope="prototype">
        <description>Add this instance to the master LightBoxDialog</description>
      </method>
      <method name="_handleClick" scope="prototype">
        <description>Handle the click on the link</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <description>Show the Lightbox with this instance as the starting point</description>
      </method>
      <method name="disable" scope="prototype">
        <description>Disables event clobbering and dialog, and follows natural link</description>
      </method>
      <method name="enable" scope="prototype">
        <description>Enables the dialog (prevents default link)</description>
      </method>
    </methods>
    <properties>
      <property name="group" scope="prototype" type="String">
        <description>Grouping images in a page with similar tags will provide a 'slideshow' like grouping of images</description>
      </property>
      <property name="title" scope="prototype" type="String">
        <description>A string of text to be shown in the Lightbox beneath the image (empty if using a store)</description>
      </property>
      <property name="href" scope="prototype" type="Object"/>
      <property name="duration" scope="prototype" type="Integer">
        <description>Generic time in MS to adjust the feel of widget. could possibly add various
	durations for the various actions (dialog fadein, sizeing, img fadein ...)</description>
      </property>
      <property name="_allowPassthru" scope="instance-prototype" type="Boolean">
        <description>Privately set this to disable/enable natural link of anchor tags</description>
      </property>
      <property name="_attachedDialog" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog" superclass="dijit.Dialog">
    <description>The &amp;quot;dialog&amp;quot; shared  between any Lightbox instances on the page, publically available
	for programatic manipulation.</description>
    <example>
		// show a single image from a url
		var url = "http://dojotoolkit.org/logo.png";
		var dialog = new dojox.image.LightboxDialog().startup();
		dialog.show({ href: url, title:"My Remote Image"});</example>
    <methods>
      <method name="startup" scope="prototype">
        <description>Add some extra event handlers, and startup our superclass.</description>
      </method>
      <method name="show" scope="prototype">
        <description>Show the Master Dialog. Starts the chain of events to show
	an image in the dialog, including showing the dialog if it is
	not already visible</description>
        <parameters>
          <parameter name="groupData" type="Object" usage="required">
            <description>needs href and title attributes. the values for this image.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_nextImage" scope="prototype">
        <description>Load next image in group</description>
      </method>
      <method name="_prevImage" scope="prototype">
        <description>Load previous image in group</description>
      </method>
      <method name="_loadImage" scope="prototype">
        <description>Do the prep work before we can show another image</description>
      </method>
      <method name="_prepNodes" scope="prototype">
        <description>A localized hook to accompany _loadImage</description>
      </method>
      <method name="resizeTo" scope="prototype">
        <description>Resize our dialog container, and fire _showImage
	22 == current styled margins or paddings, can calculate programatically if needed</description>
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showImage" scope="prototype">
        <description>Fade in the image, and fire showNav</description>
      </method>
      <method name="_showNav" scope="prototype">
        <description>Fade in the footer, and setup our connections.</description>
      </method>
      <method name="hide" scope="prototype">
        <description>Hide the Master Lightbox</description>
      </method>
      <method name="addImage" scope="prototype">
        <description>Add an image to this Master Lightbox</description>
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <description>The image information to add.
	href: String - link to image (required)
	title: String - title to display</description>
          </parameter>
          <parameter name="group" type="String" usage="optional">
            <description>attach to group of similar tag or null for individual image instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <description>Handle keyboard navigation internally</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_scaleToFit" scope="prototype">
        <description>resize an image to fit within the bounds of the viewport</description>
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <description>The 'size' object passed around for this image</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_position" scope="prototype">
        <description>we want to know the viewport size any time it changes</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_makeAnims" scope="prototype">
        <description>make and cleanup animation and animation connections</description>
      </method>
    </methods>
    <properties>
      <property name="title" scope="prototype" type="String">
        <description>The current title, read from object passed to show()</description>
      </property>
      <property name="inGroup" scope="instance-prototype" type="Object"/>
      <property name="imgUrl" scope="prototype" type="String">
        <description>The src=&amp;quot;&amp;quot; attribute of our imageNode (can be null at statup)</description>
      </property>
      <property name="errorMessage" scope="prototype" type="String">
        <description>The text to display when an unreachable image is linked</description>
      </property>
      <property name="adjust" scope="prototype" type="Boolean">
        <description>If true, ensure the image always stays within the viewport
	more difficult than necessary to disable, but enabled by default
	seems sane in most use cases.</description>
      </property>
      <property name="errorImg" scope="prototype" type="Url">
        <description>Path to the image used when a 404 is encountered</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_animConnects" scope="instance" type="Object"/>
      <property name="_clone" scope="instance" type="Object"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="_positionIndex" scope="instance" type="Object"/>
      <property name="_imageReady" scope="instance" type="Object"/>
      <property name="_wasStyled" scope="instance" type="Object"/>
      <property name="_showImageAnim" scope="instance" type="Object"/>
      <property name="_loadingAnim" scope="instance" type="Object"/>
      <property name="_showNavAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog._groups">
    <properties>
      <property name="XnoGroupX" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog.imgNode">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Magnifier" superclass="dojox.image.MagnifierLite">
    <description>Adds magnification on a portion of an image element, using dojox.gfx</description>
    <methods>
      <method name="_createGlass" scope="prototype">
        <description>create the glassNode, and an img on a dojox.gfx surface</description>
      </method>
      <method name="_placeGlass" scope="prototype">
        <description>position the overlay centered under the cursor</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="prototype">
        <description>set the image's offset in the clipping window relative to the mouse position</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.MagnifierLite" superclass="dijit._Widget">
    <description>Adds magnification on a portion of an image element</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_createGlass" scope="prototype">
        <description>make img and glassNode elements as children of the body</description>
      </method>
      <method name="_adjustScale" scope="prototype">
        <description>update the calculations should this.scale change</description>
      </method>
      <method name="_showGlass" scope="prototype">
        <description>show the overlay</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideGlass" scope="prototype">
        <description>hide the overlay</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="prototype">
        <description>position the overlay centered under the cursor</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="prototype">
        <description>set the image's offset in the clipping window relative to the mouse position</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="finalize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="glassSize" scope="prototype" type="Int">
        <description>the width and height of the bounding box</description>
      </property>
      <property name="scale" scope="prototype" type="Decimal">
        <description>the multiplier of the Mangification.</description>
      </property>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="_imageSize" scope="instance" type="Object"/>
      <property name="_zoomSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow" superclass="dijit._Widget">
    <description>A Slideshow Widget</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initilizes the widget, sets up listeners and shows the first image</description>
      </method>
      <method name="setDataStore" scope="prototype">
        <description>Sets the data store and request objects to read data from.</description>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The three attributes allowed are 'linkAttr', 'imageLargeAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>Resets the widget to its initial state</description>
      </method>
      <method name="isImageLoaded" scope="prototype">
        <description>Returns true if image at the specified index is loaded, false otherwise.</description>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to check if it is loaded.</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveImageLoadingPointer" scope="prototype">
        <description>If 'autoload' is true, this tells the widget to start loading
	images from the specified pointer.</description>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to start loading images from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>Cleans up the widget when it is being destroyed</description>
      </method>
      <method name="showNextImage" scope="prototype">
        <description>Changes the image being displayed to the next image in the data store</description>
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
          <parameter name="forceLoop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSlideShow" scope="prototype">
        <description>Switches the slideshow mode on and off.</description>
      </method>
      <method name="getShowTopicName" scope="prototype">
        <description>Returns the topic id published to when an image is shown</description>
      </method>
      <method name="getLoadTopicName" scope="prototype">
        <description>Returns the topic id published to when an image finishes loading.</description>
      </method>
      <method name="showImage" scope="prototype">
        <description>Shows the image at index 'index'.</description>
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The position of the image in the data store to display</description>
          </parameter>
          <parameter name="callback" type="Function" usage="optional">
            <description>Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fitSize" scope="prototype">
        <description>Fits the widget size to the size of the image being shown,
	or centers the image, depending on the value of 'fixedHeight'</description>
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the widget is always resized, regardless of the value of 'fixedHeight'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTopPadding" scope="prototype">
        <description>Returns the padding to place at the top of the image to center it vertically.</description>
      </method>
      <method name="_loadNextImage" scope="prototype">
        <description>Load the next unloaded image.</description>
      </method>
      <method name="_stop" scope="prototype">
        <description>Stops a running slide show.</description>
      </method>
      <method name="_prev" scope="prototype">
        <description>Show the previous image.
	FIXME: either pull code from showNext/prev, or call it here</description>
      </method>
      <method name="_next" scope="prototype">
        <description>Show the next image</description>
      </method>
      <method name="_startTimer" scope="prototype">
        <description>Starts a timeout to show the next image when a slide show is active</description>
      </method>
      <method name="_calcNavDimensions" scope="prototype">
        <description>Calculates the dimensions of the navigation controls</description>
      </method>
      <method name="_setTitle" scope="prototype">
        <description>Sets the title to the image being displayed</description>
        <parameters>
          <parameter name="title" type="String" usage="required">
            <description>The String title of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fitImage" scope="prototype">
        <description>Ensures that the image width and height do not exceed the maximum.</description>
        <parameters>
          <parameter name="img" type="Node" usage="required">
            <description>The image DOM node to optionally resize</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleClick" scope="prototype">
        <description>Performs navigation on the images based on users mouse clicks</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>An Event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_showNav" scope="prototype">
        <description>Shows the navigation controls</description>
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the navigation controls are repositioned even if they are
	currently visible.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hideNav" scope="prototype">
        <description>Hides the navigation controls</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The DOM Event that triggered this function</description>
          </parameter>
        </parameters>
      </method>
      <method name="_overElement" scope="prototype">
        <description>Returns whether the mouse is over the passed element.
	Element must be display:block (ie, not a &amp;lt;span&amp;gt;)
	When the page is unloading, if this method runs it will throw an
	exception.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="prototype" type="Object"/>
      <property name="imageWidth" scope="prototype" type="Number">
        <description>The maximum width of an image.</description>
      </property>
      <property name="title" scope="prototype" type="String">
        <description>the initial title of the SlideShow</description>
      </property>
      <property name="titleTemplate" scope="prototype" type="String">
        <description>a way to customize the wording in the title. supported parameters to be populated are:
	${title} = the passed title of the image
	${current} = the current index of the image
	${total} = the total number of images in the SlideShow
	should add more?</description>
      </property>
      <property name="noLink" scope="prototype" type="Boolean">
        <description>Prevents the slideshow from putting an anchor link around the displayed image
	enables if true, though still will not link in absence of a url to link to</description>
      </property>
      <property name="loop" scope="prototype" type="Boolean">
        <description>true/false - make the slideshow loop</description>
      </property>
      <property name="hasNav" scope="prototype" type="Boolean">
        <description>toggle to enable/disable the visual navigation controls</description>
      </property>
      <property name="images" scope="instance-prototype" type="Array">
        <description>Contains the DOM nodes that individual images are stored in when loaded or loading.</description>
      </property>
      <property name="pageSize" scope="prototype" type="Number">
        <description>The number of images to request each time.</description>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean">
        <description>If true, then images are preloaded, before the user navigates to view them.
	If false, an image is not loaded until the user views it.</description>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <description>If true, the SlideShow begins playing immediately</description>
      </property>
      <property name="fixedHeight" scope="prototype" type="Boolean">
        <description>If true, the widget does not resize itself to fix the displayed image.</description>
      </property>
      <property name="imageStore" scope="instance-prototype" type="Object">
        <description>Implementation of the dojo.data.api.Read API, which provides data on the images
	to be displayed.</description>
      </property>
      <property name="linkAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</description>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</description>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</description>
      </property>
      <property name="slideshowInterval" scope="prototype" type="Number">
        <description>Time, in seconds, between image transitions during a slideshow.</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_imageCounter" scope="instance-prototype" type="Number">
        <description>A counter to keep track of which index image is to be loaded next</description>
      </property>
      <property name="_tmpImage" scope="instance-prototype" type="DomNode">
        <description>The temporary image to show when a picture is loading.</description>
      </property>
      <property name="isInitialized" scope="instance" type="Object"/>
      <property name="imageIndex" scope="instance" type="Object"/>
      <property name="_timerCancelled" scope="instance" type="Object"/>
      <property name="_slideId" scope="instance" type="Object"/>
      <property name="_navAnim" scope="instance" type="Object"/>
      <property name="_navShowing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow._loadImage">
    <description>Load image at specified index</description>
  </class>
  <class type="dojox.image.SlideShow.outerNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow._request">
    <description>Implementation of the dojo.data.api.Request API, which defines the query
	parameters for accessing the store.</description>
    <properties>
      <property name="onComplete" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow._loadImage._request">
    <methods>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.image.SlideShow.navPlay">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navPrev">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navNext">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="this._request">
    <properties>
      <property name="query" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker" superclass="dijit._Widget">
    <description>A scrolling Thumbnail Picker widget</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initializes styles and listeners</description>
      </method>
      <method name="init" scope="prototype">
        <description>Creates DOM nodes for thumbnail images and initializes their listeners</description>
      </method>
      <method name="getClickTopicName" scope="prototype">
        <description>Returns the name of the dojo topic that can be
	subscribed to in order to receive notifications on
	which thumbnail was selected.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getShowTopicName" scope="prototype">
        <description>Returns the name of the dojo topic that can be
	subscribed to in order to receive notifications on
	which thumbnail is now visible</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setDataStore" scope="prototype">
        <description>Sets the data store and request objects to read data from.</description>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <description>Resets the widget back to its original state.</description>
      </method>
      <method name="isVisible" scope="prototype">
        <description>Returns true if the image at the specified index is currently visible. False otherwise.</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_next" scope="prototype">
        <description>Displays the next page of images</description>
      </method>
      <method name="_prev" scope="prototype">
        <description>Displays the next page of images</description>
      </method>
      <method name="_checkLoad" scope="prototype">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showThumbs" scope="prototype">
        <description>Displays thumbnail images, starting at position 'index'</description>
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The index of the first thumbnail</description>
          </parameter>
        </parameters>
      </method>
      <method name="markImageLoaded" scope="prototype">
        <description>Changes a visual cue to show the image is loaded</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setThumbClass" scope="prototype">
        <description>Adds a CSS class to a thumbnail, only if 'autoLoad' is true</description>
        <parameters>
          <parameter name="thumb" type="DomNode" usage="required">
            <description>The thumbnail DOM node to set the class on</description>
          </parameter>
          <parameter name="className" type="String" usage="required">
            <description>The CSS class to add to the DOM node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_loadNextPage" scope="prototype">
        <description>Loads the next page of thumbnail images</description>
      </method>
      <method name="_loadImage" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateNavControls" scope="prototype">
        <description>Updates the navigation controls to hide/show them when at
	the first or last images.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageStore" scope="instance-prototype" type="Object">
        <description>A data store that implements the dojo.data Read API.</description>
      </property>
      <property name="size" scope="prototype" type="Number">
        <description>Width or height in pixels, depending if horizontal or vertical.</description>
      </property>
      <property name="thumbHeight" scope="prototype" type="Number">
        <description>Default height of a thumbnail image</description>
      </property>
      <property name="thumbWidth" scope="prototype" type="Number">
        <description>Default width of an image</description>
      </property>
      <property name="useLoadNotifier" scope="prototype" type="Boolean">
        <description>Setting useLoadNotifier to true makes a colored DIV appear under each
	thumbnail image, which is used to display the loading status of each
	image in the data store.</description>
      </property>
      <property name="useHyperlink" scope="prototype" type="boolean">
        <description>Setting useHyperlink to true causes a click on a thumbnail to open a link.</description>
      </property>
      <property name="hyperlinkTarget" scope="instance-prototype" type="String">
        <description>If hyperlinkTarget is set to &amp;quot;new&amp;quot;, clicking on a thumb will open a new window
	If it is set to anything else, clicking a thumbnail will open the url in the
	current window.</description>
      </property>
      <property name="isClickable" scope="prototype" type="Boolean">
        <description>When set to true, the cursor over a thumbnail changes.</description>
      </property>
      <property name="isScrollable" scope="prototype" type="Boolean">
        <description>When true, uses smoothScroll to move between pages</description>
      </property>
      <property name="isHorizontal" scope="prototype" type="Boolean">
        <description>If true, the thumbnails are displayed horizontally. Otherwise they are displayed
	vertically</description>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean"/>
      <property name="linkAttr" scope="prototype" type="String">
        <description>The attribute name for accessing the url from the data store</description>
      </property>
      <property name="imageThumbAttr" scope="prototype" type="String">
        <description>The attribute name for accessing the thumbnail image url from the data store</description>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <description>The attribute name for accessing the large image url from the data store</description>
      </property>
      <property name="pageSize" scope="instance-prototype" type="Number">
        <description>The number of images to request each time.</description>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <description>The attribute name for accessing the title from the data store</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_thumbs" scope="instance-prototype" type="Object"/>
      <property name="_thumbIndex" scope="instance-prototype" type="Number">
        <description>The index of the first thumbnail shown</description>
      </property>
      <property name="_maxPhotos" scope="instance-prototype" type="Number">
        <description>The total number of photos in the image store</description>
      </property>
      <property name="_loadedImages" scope="instance-prototype" type="Object">
        <description>Stores the indices of images that have been marked as loaded using the
	markImageLoaded function.</description>
      </property>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="_scrollerSize" scope="instance" type="Object"/>
      <property name="_sizeProperty" scope="instance" type="Object"/>
      <property name="_totalSize" scope="instance" type="Object"/>
      <property name="isInitialized" scope="instance" type="Object"/>
      <property name="_offsetAttr" scope="instance" type="Object"/>
      <property name="_sizeAttr" scope="instance" type="Object"/>
      <property name="_scrollAttr" scope="instance" type="Object"/>
      <property name="_noImages" scope="instance" type="Object"/>
      <property name="_loadingImages" scope="instance" type="Object"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.request">
    <description>A dojo.data Read API Request object.</description>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="onComplete" scope="instance" type="Object"/>
      <property name="onError" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.thumbScroller">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="this.request">
    <properties>
      <property name="query" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io">
    <description>Extensions to the Core dojo.io transports</description>
    <methods>
      <method name="httpParse" scope="instance">
        <description>Parses an HTTP stream for a message.</description>
        <parameters>
          <parameter name="httpStream" type="String" usage="required">
            <description>HTTP stream to parse</description>
          </parameter>
          <parameter name="topHeaders" type="String" usage="optional">
            <description>Extra header information to add to each HTTP request (kind of HTTP inheritance)</description>
          </parameter>
          <parameter name="partial" type="Boolean" usage="optional">
            <description>A true value indicates that the stream may not be finished, it may end arbitrarily in mid stream.
	The last XHR object will have a special property _lastIndex that indicates the how far along
	the httpStream could be successfully parsed into HTTP messages.
	return:
	Returns an array of XHR-like object for reading the headers for each message</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="the content is not finished"/>
        </return-types>
      </method>
      <method name="__xhrContentArgs" scope="instance"/>
      <method name="__xhrMultiArgs" scope="instance"/>
      <method name="xhrMultiPart" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.io.__xhrMultiArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhrWindowNamePlugin" scope="instance">
        <description>Adds the windowName transport as an XHR plugin for the given site. See
	dojox.io.windowName for more information on the transport.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>Url prefix of the site which can handle windowName requests.</description>
          </parameter>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <description>This allows for adapting HTTP requests that could not otherwise be
	sent with XDR, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
          <parameter name="trusted" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.proxy"/>
  <class type="dojox.io.proxy.xip">
    <description>Object that implements the iframe handling for XMLHttpRequest
	IFrame Proxying.</description>
    <methods>
      <method name="send" scope="instance">
        <description>starts the xdomain request using the provided facade.
	This method first does some init work, then delegates to _realSend.</description>
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_realSend" scope="instance">
        <description>starts the actual xdomain request using the provided facade.</description>
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
          <parameter name="urlEncodedData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="frameLoaded" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroyState" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createFacade" scope="instance"/>
      <method name="sendRequest" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="encodedData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestStart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestPart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceivedEvent" scope="instance">
        <description>HTML5 document messaging endpoint. Unpack the event to see
	if we want to use it.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceived" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unpackMessage" scope="instance">
        <parameters>
          <parameter name="encodedMessage" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="xipClientUrl" scope="instance" type="Object"/>
      <property name="urlLimit" scope="instance" type="Object"/>
      <property name="_callbackName" scope="instance" type="Object"/>
      <property name="_state" scope="instance" type="Object"/>
      <property name="_stateIdCounter" scope="instance" type="Object"/>
      <property name="_isWebKit" scope="instance" type="Object"/>
      <property name="_xhrObjOld" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade">
    <description>XMLHttpRequest facade object used by dojox.io.proxy.xip.</description>
    <methods>
      <method name="open" scope="prototype">
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setRequestHeader" scope="prototype">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="prototype">
        <parameters>
          <parameter name="stringData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="abort" scope="prototype"/>
      <method name="getAllResponseHeaders" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getResponseHeader" scope="prototype">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setResponseHeaders" scope="prototype">
        <parameters>
          <parameter name="allHeaders" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_requestHeaders" scope="instance" type="Object"/>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
      <property name="_responseHeaders" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="responseText" scope="instance" type="Object"/>
      <property name="responseXML" scope="instance" type="Object"/>
      <property name="status" scope="instance" type="Object"/>
      <property name="statusText" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Object"/>
      <property name="_ifpServerUrl" scope="instance" type="Object"/>
      <property name="_stateId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.script">
    <methods>
      <method name="_canAttach" scope="instance">
        <description>A method that can be overridden by other modules
	to control when the script attachment occurs.</description>
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__ioArgs" scope="instance">
        <description>All the properties described in the dojo.__ioArgs type, apply to this
	type as well, EXCEPT &amp;quot;handleAs&amp;quot;. It is not applicable to
	dojo.io.script.get() calls, since it is implied by the usage of
	&amp;quot;callbackParamName&amp;quot; (response will be a JSONP call returning JSON)
	or &amp;quot;checkString&amp;quot; (response is pure JavaScript defined in
	the body of the script that was attached).</description>
      </method>
      <method name="get" scope="instance">
        <description>sends a get request using a dynamically created script tag.</description>
        <parameters>
          <parameter name="args" type="dojo.io.script.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="attach" scope="instance">
        <description>creates a new &amp;lt;script&amp;gt; tag pointing to the specified URL and
	adds it to the document.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <description>removes the script element with the given id, from the given frameDocument.
	If no frameDocument is passed, the current document is used.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <description>sets up a Deferred object for an IO request.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="instance">
        <description>canceller function for dojo._ioSetArgs call.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <description>okHandler function for dojo._ioSetArgs call.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <description>errHandler function for dojo._ioSetArgs call.</description>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <description>sets up an entry in the deadScripts array.</description>
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <description>inflight check function to see if dfd is still valid.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <description>inflight check function to see if IO finished.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <description>inflight function to handle a completed response.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_deadScripts" scope="instance" type="Object"/>
      <property name="_counter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.scriptFrame">
    <methods>
      <method name="_getWaiters" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixAttachUrl" scope="instance">
        <description>fixes the URL so that</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_loaded" scope="instance">
        <description>callback used when waiting for a frame to load (related to the usage of
	the frameId argument to dojo.io.script.get().</description>
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_waiters" scope="instance" type="Object"/>
      <property name="_loadedIds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.windowName">
    <methods>
      <method name="send" scope="instance">
        <description>Provides secure cross-domain request capability.
	Sends a request using an iframe (POST or GET) and reads the response through the
	frame's window.name.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>The method to use to send the request, GET or POST</description>
          </parameter>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>See dojo.xhr
	args.authElement: DOMNode?
	By providing an authElement, this indicates that windowName should use the
	authorized window.name protocol, relying on
	the loaded XD resource to return to the provided return URL on completion
	of authorization/authentication. The provided authElement will be used to place
	the iframe in, so the user can interact with the server resource for authentication
	and/or authorization to access the resource.
	args.onAuthLoad: Function?
	When using authorized access to resources, this function will be called when the
	authorization page has been loaded. (When authorization is actually completed,
	the deferred callback function is called with the result). The primary use for this
	is to make the authElement visible to the user once the resource has loaded
	(this can be preferable to showing the iframe while the resource is loading
	since it may not require authorization, it may simply return the resource).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="dfd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="authTarget" type="Object" usage="required"/>
          <parameter name="onAuthLoad" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_frameNum" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="args">
    <mixins scope="normal">
      <mixin type="p[i]" scope="instance"/>
      <mixin type="this._options" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentType" scope="instance" type="Object"/>
      <property name="postData" scope="instance" type="Object"/>
      <property name="content || {}" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.xhrPlugins">
    <methods>
      <method name="register" scope="instance">
        <description>overrides the default xhr handler to implement a registry of
	xhr handlers</description>
        <return-types>
          <return-type type="or check to see if we have the same path"/>
        </return-types>
      </method>
      <method name="addProxy" scope="instance">
        <description>adds a server side proxy xhr handler for cross-site URLs</description>
        <example>Define a proxy:
		dojox.io.xhrPlugins.addProxy("/proxy?url=");
	And then when you call:
		dojo.xhr("GET",{url:"http://othersite.com/file"});
	It would result in the request (to your origin server):
		GET /proxy?url=http%3A%2F%2Fothersite.com%2Ffile HTTP/1.1</example>
        <parameters>
          <parameter name="proxyUrl" type="This" usage="required">
            <description>is URL to send the requests to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addCrossSiteXhr" scope="instance">
        <description>Adds W3C Cross site XHR or XDomainRequest handling for the given URL prefix</description>
        <parameters>
          <parameter name="url" type="Requests" usage="required">
            <description>that start with this URL will be considered for using
	cross-site XHR.</description>
          </parameter>
          <parameter name="httpAdapter" type="This" usage="required">
            <description>allows for adapting HTTP requests that could not otherwise be
	sent with XDR, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fullHttpAdapter" scope="instance">
        <description>Provides a HTTP adaption.</description>
        <example>dojox.io.xhrPlugins.addXdr("http://somesite.com", dojox.io.xhrPlugins.fullHttpAdapter);</example>
        <parameters>
          <parameter name="plainXhr" type="Object" usage="required"/>
          <parameter name="noRawBody" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.json">
    <methods>
      <method name="query" scope="instance">
        <description>Performs a JSONQuery on the provided object and returns the results.
	If no object is provided (just a query), it returns a &amp;quot;compiled&amp;quot; function that evaluates objects
	according to the provided query.</description>
        <example>
		dojox.json.query("foo",{foo:"bar"})
	This will return "bar".</example>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>Query string</description>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <description>Target of the JSONQuery</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="we mark all the inner brackets as skippable"/>
          <return-type type="leave .prop alone"/>
          <return-type type="FIXME: Should check to make sure the $obj token isn't followed by characters"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.json.schema">
    <methods>
      <method name="validate" scope="instance">
        <description>To use the validator call this with an instance object and an optional schema object.
	If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
	that schema will be used to validate and the schema parameter is not necessary (if both exist,
	both validations will occur).</description>
        <parameters>
          <parameter name="instance" type="Any" usage="required">
            <description>The instance value/object to validate</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkPropertyChange" scope="instance">
        <description>The checkPropertyChange method will check to see if an value can legally be in property with the given schema
	This is slightly different than the validate method in that it will fail if the schema is readonly and it will
	not check for self-validation, it is assumed that the passed in value is already internally valid.
	The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
	information.</description>
        <parameters>
          <parameter name="value" type="Any" usage="required">
            <description>The new instance value/object to check</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate
	return:
	see dojox.validate.jsonSchema.validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="_validate" scope="instance">
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="_changing" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.jsonPath">
    <description>A query system for JavaScript objects</description>
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="expr" type="String" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="if it is result based, there is no point to just return the same array"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.aspect">
    <methods>
      <method name="cflow" scope="instance">
        <description>Returns true if the context stack contains a context for a given
	instance that satisfies a given method name criteria.</description>
        <parameters>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance to be matched. If null, any context will be examined.
	Otherwise the context should belong to this instance.</description>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="optional">
            <description>An optional pattern to be matched against a method name. Can be a string,
	a RegExp object or an array of strings and RegExp objects.
	If it is omitted, any name will satisfy the criteria.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="counter" scope="instance">
        <description>Returns an object, which can be used to count calls to methods.</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizer" scope="instance">
        <description>Returns an object, which can be used to count calls to methods.</description>
        <parameters>
          <parameter name="keyMaker" type="Function" usage="optional">
            <description>the function, which takes method's arguments and returns a key,
	which can be used to index the result.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="tracer" scope="instance">
        <description>Returns an object, which can be used to trace calls with Firebug's console.
	Prints argument, a return value, or an exception.</description>
        <parameters>
          <parameter name="grouping" type="Boolean" usage="required">
            <description>The flag to group output. If true, indents embedded console messages.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="memoizerGuard" scope="instance" type="Object"/>
      <property name="profiler" scope="instance" type="Object"/>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang">
    <description>Language specific extensions</description>
    <methods>
      <method name="observable" scope="instance">
        <description>Creates a wrapper object, which can be observed. The wrapper object
	is a proxy to the wrapped object. If you will be making multiple wrapper
	objects with the same set of listeners, it is recommended that you
	use makeObservable, as it is more memory efficient.</description>
        <parameters>
          <parameter name="wrapped" type="Object" usage="required">
            <description>The object to be wrapped and monitored for property access and modification</description>
          </parameter>
          <parameter name="onRead" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onRead</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onWrite</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onInvoke</description>
          </parameter>
        </parameters>
      </method>
      <method name="makeObservable" scope="instance">
        <description>Creates and returns an observable creator function. All the objects that
	are created with the returned constructor will use the provided onRead and
	onWrite listeners.
	The created constructor should be called with a single argument,
	the object that will be wrapped to be observed. The constructor will
	return the wrapper object.</description>
        <example>The following could be used to create a wrapper that would
	prevent functions from being accessed on an object:
		function onRead(obj,prop){
			return typeof obj[prop] == 'function' ? null : obj[prop];
		}
		var observable = dojox.lang.makeObservable(onRead,onWrite);
		var obj = {foo:1,bar:function(){}};
		obj = observable(obj);
		obj.foo -&gt; 1
		obj.bar -&gt; null</example>
        <parameters>
          <parameter name="onRead" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is accessed. onRead
	will be called with two arguments, the first being the wrapped object,
	and the second is the name of property that is being accessed.
	The value that onRead returns will be used as the value returned
	by the property access</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is modified. onWrite
	will be called with three arguments, the first being the wrapped object,
	the second is the name of property that is being modified, and the
	third is the value that is being set on the property.</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>This is called when a method on the object is invoked. The first
	argument is the wrapper object, the second is the original wrapped object,
	the third is the method name, and the fourth is the arguments.</description>
          </parameter>
          <parameter name="hiddenFunctions" type="Object" usage="required">
            <description>allows you to define functions that should be delegated
	but may not be enumerable on the wrapped objects, so they must be
	explicitly included</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="the class can't be accessed, only called, so we have to wrap it with a function"/>
          <return-type type="do it with getters and setters"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="mix" scope="instance" type="Object"/>
      <property name="lettableWin" scope="instance" type="Object"/>
      <property name="ReadOnlyProxy" scope="instance" type="Object"/>
      <property name="utils" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="aop">
    <properties>
      <property name="memoizerGuard" scope="instance" type="Object"/>
      <property name="profiler" scope="instance" type="Object"/>
      <property name="timer" scope="instance" type="Object"/>
      <property name="unadvise" scope="instance" type="Object"/>
      <property name="getContext" scope="instance" type="Object"/>
      <property name="getContextStack" scope="instance" type="Object"/>
      <property name="proceed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="x">
    <properties>
      <property name="target" scope="instance" type="Object"/>
      <property name="targetName" scope="instance" type="Object"/>
      <property name="_listeners" scope="instance" type="Object"/>
      <property name="advices" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="context">
    <mixins scope="normal">
      <mixin type="zipped" scope="instance"/>
    </mixins>
    <properties>
      <property name="instance" scope="instance" type="Object"/>
      <property name="joinPoint" scope="instance" type="Object"/>
      <property name="depth" scope="instance" type="Object"/>
      <property name="around" scope="instance" type="Object"/>
      <property name="dynAdvices" scope="instance" type="Object"/>
      <property name="dynIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.functional">
    <description>Functional language constructs, including currying and lambda.</description>
    <methods>
      <method name="buildListcomp" scope="instance">
        <description>builds a function from a text snippet, which represents a valid
	JS 1.7 list comprehension, returns a string, which represents the function.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compileListcomp" scope="instance">
        <description>builds a function from a text snippet, which represents a valid
	JS 1.7 list comprehension, returns a function object.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="listcomp" scope="instance">
        <description>executes the list comprehension building an array.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="array" scope="instance" type="Object"/>
      <property name="binrec" scope="instance" type="Object"/>
      <property name="curry" scope="instance" type="Object"/>
      <property name="fold" scope="instance" type="Object"/>
      <property name="lambda" scope="instance" type="Object"/>
      <property name="linrec" scope="instance" type="Object"/>
      <property name="multirec" scope="instance" type="Object"/>
      <property name="numrec" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="reversed" scope="instance" type="Object"/>
      <property name="scan" scope="instance" type="Object"/>
      <property name="sequence" scope="instance" type="Object"/>
      <property name="tailrec" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="zip" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dict2._c=_t">
    <properties>
      <property name="c" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dict2._b=_t">
    <properties>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dict2._a=_t">
    <properties>
      <property name="a" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="f">
    <properties>
      <property name="c" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
      <property name="a" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="df">
    <properties>
      <property name="numrec" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="mix">
    <properties>
      <property name="processProps" scope="instance" type="Object"/>
      <property name="mixer" scope="instance" type="Object"/>
      <property name="makeFilter" scope="instance" type="Object"/>
      <property name="createFilter" scope="instance" type="Object"/>
      <property name="makeDecorator" scope="instance" type="Object"/>
      <property name="createDecorator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="frame.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout">
    <description>A collection of layout related Widgets</description>
    <properties>
      <property name="BorderContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane" superclass="dijit.layout.ContentPane">
    <description>cleans content to make it less likly to generate DOM/JS errors.</description>
    <methods>
      <method name="setHref" scope="prototype">
        <description>replace current content with url's content</description>
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.layout.ContentPane.DeferredHandle"/>
        </return-types>
      </method>
      <method name="refresh" scope="prototype">
        <description>force a re-download of content</description>
        <return-types>
          <return-type type="dojox.layout.ContentPane.DeferredHandle"/>
        </return-types>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="onExecError" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.layout.ContentPane.DeferredHandle"/>
        </return-types>
      </method>
      <method name="cancel" scope="prototype">
        <description>cancels a inflight download</description>
      </method>
      <method name="_setUpDeferreds" scope="prototype"/>
      <method name="_onLoadHandler" scope="prototype"/>
      <method name="_onUnloadHandler" scope="prototype"/>
      <method name="_onError" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareLoad" scope="prototype">
        <parameters>
          <parameter name="forceLoad" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="adjustPaths" scope="prototype" type="Object"/>
      <property name="cleanContent" scope="prototype" type="Boolean"/>
      <property name="renderStyles" scope="prototype" type="Boolean">
        <description>trigger/load styles in the content</description>
      </property>
      <property name="executeScripts" scope="prototype" type="Boolean">
        <description>Execute (eval) scripts that is found in the content</description>
      </property>
      <property name="scriptHasHooks" scope="prototype" type="Boolean">
        <description>replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	NOTE this name might change in the near future</description>
      </property>
      <property name="ioMethod" scope="instance-prototype" type="dojo.xhrGet|dojo.xhrPost">
        <description>reference to the method that should grab the content</description>
      </property>
      <property name="ioArgs" scope="instance-prototype" type="Object">
        <description>makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'</description>
      </property>
      <property name="onLoadDeferred" scope="instance-prototype" type="dojo.Deferred">
        <description>callbackchain will start when onLoad occurs</description>
      </property>
      <property name="onUnloadDeferred" scope="instance-prototype" type="dojo.Deferred">
        <description>callbackchain will start when onUnload occurs</description>
      </property>
      <property name="isLoaded" scope="instance" type="Object"/>
      <property name="_contentSetter" scope="instance" type="Object"/>
      <property name="_contentSetterParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane._xhrDfd">
    <properties>
      <property name="fired" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane.DeferredHandle">
    <methods>
      <method name="cancel" scope="instance">
        <description>cancel a in flight download</description>
      </method>
      <method name="addOnLoad" scope="instance">
        <description>add a callback to the onLoad chain</description>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addOnUnload" scope="instance">
        <description>add a callback to the onUnload chain</description>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.layout.DragPane" superclass="dijit._Widget">
    <description>Makes a pane's content dragable by/within it's surface</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_down" scope="prototype">
        <description>mousedown handler, start the dragging</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_up" scope="prototype">
        <description>mouseup handler, stop the dragging</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="prototype">
        <description>mousemove listener, offset the scroll amount by the delta
	since our last call.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="invert" scope="prototype" type="Boolean">
        <description>Naturally, the behavior is to invert the axis of the drag.
	Setting invert:false will make the pane drag in the same
	direction as the mouse.</description>
      </property>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_y" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ExpandoPane" superclass="dijit.layout.ContentPane">
    <description>An experimental expando-pane for dijit.layout.BorderContainer</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_afterResize" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupAnims" scope="prototype">
        <description>Create the show and hide animations</description>
      </method>
      <method name="toggle" scope="prototype">
        <description>Toggle this pane's visibility</description>
      </method>
      <method name="_hideWrapper" scope="prototype">
        <description>Set the Expando state to &amp;quot;closed&amp;quot;</description>
      </method>
      <method name="_showEnd" scope="prototype">
        <description>Common animation onEnd code - &amp;quot;unclose&amp;quot;</description>
      </method>
      <method name="_hideEnd" scope="prototype"/>
      <method name="resize" scope="prototype">
        <description>we aren't a layout widget, but need to act like one:</description>
      </method>
      <method name="_trap" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="maxHeight" scope="prototype" type="Object"/>
      <property name="maxWidth" scope="prototype" type="Object"/>
      <property name="splitter" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_showing" scope="instance-prototype" type="Object"/>
      <property name="easeOut" scope="instance-prototype" type="String|Function">
        <description>easing function used to hide pane</description>
      </property>
      <property name="easeIn" scope="instance-prototype" type="String|Function">
        <description>easing function use to show pane</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>duration to run show/hide animations</description>
      </property>
      <property name="startExpanded" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="_animConnects" scope="instance" type="Object"/>
      <property name="_isHorizontal" scope="instance" type="Object"/>
      <property name="_container" scope="instance" type="Object"/>
      <property name="_closedSize" scope="instance" type="Object"/>
      <property name="_currentSize" scope="instance" type="Object"/>
      <property name="_showSize" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="_common">
    <properties>
      <property name="easing" scope="instance" type="Object"/>
      <property name="properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane" superclass="dojox.layout.ContentPane">
    <description>A non-modal Floating window.</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="setTitle" scope="prototype">
        <description>Update the Title bar with a new string</description>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <description>Close and destroy this widget</description>
      </method>
      <method name="hide" scope="prototype">
        <description>Close, but do not destroy this FloatingPane</description>
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <description>Show the FloatingPane</description>
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="minimize" scope="prototype">
        <description>Hide and dock the FloatingPane</description>
      </method>
      <method name="maximize" scope="prototype">
        <description>Make this FloatingPane full-screen (viewport)</description>
      </method>
      <method name="_restore" scope="prototype"/>
      <method name="_dock" scope="prototype"/>
      <method name="resize" scope="prototype">
        <description>Size the FloatingPane and place accordingly</description>
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bringToTop" scope="prototype">
        <description>bring this FloatingPane above all other panes</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>Destroy this FloatingPane completely</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="closable" scope="prototype" type="Boolean">
        <description>Allow closure of this Node</description>
      </property>
      <property name="dockable" scope="prototype" type="Boolean">
        <description>Allow minimizing of pane if true</description>
      </property>
      <property name="resizable" scope="prototype" type="Boolean">
        <description>Allow resizing of pane true if true</description>
      </property>
      <property name="maxable" scope="prototype" type="Boolean">
        <description>Horrible param name for &amp;quot;Can you maximize this floating pane?&amp;quot;</description>
      </property>
      <property name="resizeAxis" scope="prototype" type="String">
        <description>One of: x | xy | y to limit pane's sizing direction</description>
      </property>
      <property name="title" scope="instance-prototype" type="String">
        <description>Title to use in the header</description>
      </property>
      <property name="dockTo" scope="instance-prototype" type="DomNode?">
        <description>if empty, will create private layout.Dock that scrolls with viewport
	on bottom span of viewport.</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>Time is MS to spend toggling in/out node</description>
      </property>
      <property name="iconSrc" scope="prototype" type="String">
        <description>[not implemented yet] will be either icon in titlepane to left
	of Title, and/or icon show when docked in a fisheye-like dock
	or maybe dockIcon would be better?</description>
      </property>
      <property name="contentClass" scope="prototype" type="String">
        <description>The className to give to the inner node which has the content</description>
      </property>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_dockNode" scope="instance-prototype" type="Object"/>
      <property name="_restoreState" scope="prototype" type="Object"/>
      <property name="_allFPs" scope="prototype" type="Object"/>
      <property name="_startZ" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_isDocked" scope="instance" type="Object"/>
      <property name="_naturalState" scope="instance" type="Object"/>
      <property name="_maximized" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.dockNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.closeNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.maxNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.restoreNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.resizeHandle.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.domNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="position" scope="instance" type="Object"/>
      <property name="display" scope="instance" type="Object"/>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.canvas.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.containerNode.style">
    <properties>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.Dock" superclass="dijit._Widget">
    <description>A widget that attaches to a node and keeps track of incoming / outgoing FloatingPanes
	and handles layout</description>
    <methods>
      <method name="addNode" scope="prototype">
        <description>Instert a dockNode refernce into the dock</description>
        <parameters>
          <parameter name="refNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_positionDock" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_docked" scope="prototype" type="Object"/>
      <property name="_inPositioning" scope="instance-prototype" type="Object"/>
      <property name="autoPosition" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_inPositiononing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._DockNode" superclass="dijit._Widget">
    <description>dojox.layout._DockNode is a private widget used to keep track of
	which pane is docked.</description>
    <methods>
      <method name="restore" scope="prototype">
        <description>remove this dock item from parent dock, and call show() on reffed floatingpane</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String">
        <description>Shown in dock icon. should read parent iconSrc?</description>
      </property>
      <property name="paneRef" scope="prototype" type="Widget">
        <description>reference to the FloatingPane we reprasent in any given dock</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer" superclass="dijit._Widget">
    <description>The Grid Container is a container of child elements that are placed in a kind of grid.</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_createCells" scope="prototype"/>
      <method name="init" scope="prototype">
        <description>Initialization of the GridContainer widget</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>destroy GridContainer Component.</description>
      </method>
      <method name="onResized" scope="prototype">
        <description>Callback method to resize the GridContainer widget and columns</description>
      </method>
      <method name="_organizeServices" scope="prototype">
        <description>List all zones and insert service into columns.</description>
      </method>
      <method name="_organizeServicesManually" scope="prototype">
        <description>Organize Services by column property of widget.</description>
      </method>
      <method name="_insertService" scope="prototype">
        <description>Insert a service in a specific column of the GridContainer widget.</description>
        <parameters>
          <parameter name="z" type="Integer" usage="required"/>
          <parameter name="p" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
          <parameter name="first" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addService" scope="prototype">
        <description>Add a service (child widget) in a specific column of the GridContainer widget.</description>
        <parameters>
          <parameter name="service" type="Object" usage="required">
            <description>widget to insert</description>
          </parameter>
          <parameter name="z" type="Integer" usage="required">
            <description>zone number (column)</description>
          </parameter>
          <parameter name="p" type="Integer" usage="required">
            <description>place in the zone (first = 0)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_createGrid" scope="prototype">
        <description>Create all grid (zones and grip)</description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_disconnectDnd" scope="prototype">
        <description>disconnect all events on insertNodes</description>
      </method>
      <method name="_createZone" scope="prototype">
        <description>Create a DnD column.</description>
        <parameters>
          <parameter name="zone" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="plottedDnd Object"/>
        </return-types>
      </method>
      <method name="_createGrip" scope="prototype">
        <description>Create a grip for a specific zone</description>
        <parameters>
          <parameter name="dz" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initPlaceGrips" scope="prototype">
        <description>Initialize the position of a grip which will not change (top)</description>
      </method>
      <method name="_placeGrips" scope="prototype">
        <description>Define the position of a grip and place it on page.</description>
      </method>
      <method name="_getZoneByIndex" scope="prototype">
        <description>Return a DOM node containing a zone by given a index.</description>
        <parameters>
          <parameter name="n" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="number"/>
        </return-types>
      </method>
      <method name="getIndexZone" scope="prototype">
        <description>Return an integer by given a zone</description>
        <parameters>
          <parameter name="zone" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="number"/>
        </return-types>
      </method>
      <method name="resizeColumnOn" scope="prototype">
        <description>Connect events to listen the resize action.
	Change the type of width columns (% to px)
	Calculate the minwidth according to the children</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resizeColumnMove" scope="prototype">
        <description>Change columns size.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resizeColumnOff" scope="prototype">
        <description>Disconnect resize events.
	Change the type of width columns (px to %)</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setColumns" scope="prototype">
        <description>Set the number of columns</description>
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_addColumn" scope="prototype">
        <description>Add some columns</description>
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_deleteColumn" scope="prototype">
        <description>Remove some columns with indices passed as an array</description>
        <parameters>
          <parameter name="indices" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="prototype">
        <description>Update the columns width.</description>
      </method>
      <method name="_selectFocus" scope="prototype">
        <description>Enable a11y into the GridContainer :
	- Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
	- Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +  ARROW).
	If the type of widget is not draggable, a popup is displayed.</description>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_displayPopup" scope="prototype">
        <description>display a popup when a widget type can not move</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="isContainer" scope="prototype" type="Object"/>
      <property name="i18n" scope="instance-prototype" type="Object">
        <description>Contain i18n ressources.</description>
      </property>
      <property name="isAutoOrganized" scope="prototype" type="Boolean:">
        <description>Define auto organisation of children into the grid container.</description>
      </property>
      <property name="isRightFixed" scope="prototype" type="Boolean">
        <description>Define if the right border has a fixed size.</description>
      </property>
      <property name="isLeftFixed" scope="prototype" type="Boolean">
        <description>Define if the left border has a fixed size.</description>
      </property>
      <property name="hasResizableColumns" scope="prototype" type="Boolean">
        <description>Allow or not resizing of columns by a grip handle.</description>
      </property>
      <property name="nbZones" scope="instance-prototype" type="Integer">
        <description>The number of dropped zones.</description>
      </property>
      <property name="opacity" scope="prototype" type="Integer">
        <description>Define the opacity of the DnD Avatar.</description>
      </property>
      <property name="minColWidth" scope="prototype" type="Integer">
        <description>Minimum column width in percentage.</description>
      </property>
      <property name="minChildWidth" scope="prototype" type="Integer">
        <description>Minimun children with in pixel (only used for IE6 that doesn't handle min-width css property */</description>
      </property>
      <property name="acceptTypes" scope="instance-prototype" type="Array">
        <description>The gridcontainer will only accept the children that fit to the types.
	In order to do that, the child must have a widgetType or a dndType attribute corresponding to the accepted type.*/</description>
      </property>
      <property name="mode" scope="instance-prototype" type="String">
        <description>location to add columns, must be set to left or right(default)</description>
      </property>
      <property name="allowAutoScroll" scope="prototype" type="Boolean">
        <description>auto-scrolling enable inside the GridContainer</description>
      </property>
      <property name="timeDisplayPopup" scope="prototype" type="Integer">
        <description>display time of popup in miliseconds</description>
      </property>
      <property name="isOffset" scope="prototype" type="Boolean">
        <description>if true : Let the mouse to its original location when moving (allow to specify it proper offset)
	if false : Current behavior, mouse in the upper left corner of the widget</description>
      </property>
      <property name="offsetDrag" scope="prototype" type="Object">
        <description>Allow to specify its own offset (x and y) onl when Parameter isOffset is true</description>
      </property>
      <property name="withHandles" scope="prototype" type="Boolean">
        <description>Specify if there is a specific drag handle on widgets</description>
      </property>
      <property name="handleClasses" scope="prototype" type="Array">
        <description>Array of classes of nodes that will act as drag handles</description>
      </property>
      <property name="_draggedWidget" scope="prototype" type="Object"/>
      <property name="_isResized" scope="instance-prototype" type="Boolean">
        <description>Determine if user can resizing the widget with the mouse.</description>
      </property>
      <property name="_activeGrip" scope="instance-prototype" type="Object"/>
      <property name="_oldwidth" scope="instance-prototype" type="Integer">
        <description>Save the old width size.</description>
      </property>
      <property name="_oldheight" scope="instance-prototype" type="Integer">
        <description>Save the old height size.</description>
      </property>
      <property name="_a11yOn" scope="instance-prototype" type="Object"/>
      <property name="_canDisplayPopup" scope="instance-prototype" type="Object"/>
      <property name="startup" scope="prototype" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="dropHandler" scope="instance" type="Object"/>
      <property name="tabDZ" scope="instance" type="Object"/>
      <property name="handleDndStart" scope="instance" type="Object"/>
      <property name="onMouseOver" scope="instance" type="Object"/>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_topGrip" scope="instance" type="Object"/>
      <property name="initX" scope="instance" type="Object"/>
      <property name="oldTabSize" scope="instance" type="Object"/>
      <property name="currentColumn" scope="instance" type="Object"/>
      <property name="currentColumnWidth" scope="instance" type="Object"/>
      <property name="nextColumn" scope="instance" type="Object"/>
      <property name="nextColumnWidth" scope="instance" type="Object"/>
      <property name="currentMinCol" scope="instance" type="Object"/>
      <property name="nextMinCol" scope="instance" type="Object"/>
      <property name="connectResizeColumnMove" scope="instance" type="Object"/>
      <property name="connectResizeColumnOff" scope="instance" type="Object"/>
      <property name="dragOffset" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._activeGrip.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.grid">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroup" superclass="dijit.layout.StackContainer">
    <description>A Container that turns its Layout Children into a single Pane and transitions between states
	onHover of the button</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>scan the container for children, and make &amp;quot;tab buttons&amp;quot; for them</description>
      </method>
      <method name="_makeButton" scope="prototype">
        <description>Creates a hover button for a child node of the RadioGroup</description>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <description>Add a child to this Group and create a button if necessary</description>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <description>called when StackContainer receives a selectChild call, used to transition the panes.</description>
        <parameters>
          <parameter name="newWidget" type="Widget" usage="required"/>
          <parameter name="oldWidget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="prototype">
        <description>show the selected child widget</description>
        <parameters>
          <parameter name="page" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="prototype">
        <description>hide the specified child widget</description>
        <parameters>
          <parameter name="page" type="Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="prototype" type="Object"/>
      <property name="hasButtons" scope="prototype" type="Boolean">
        <description>toggles internal button making on or off</description>
      </property>
      <property name="buttonClass" scope="prototype" type="String">
        <description>The full declared className of the Button widget to use for hasButtons</description>
      </property>
      <property name="templateString" scope="prototype" type="String">
        <description>the template for our container</description>
      </property>
      <property name="_children" scope="instance" type="Object"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroupFade" superclass="dojox.layout.RadioGroup">
    <description>An extension on a stock RadioGroup, that fades the panes.</description>
    <methods>
      <method name="_hideChild" scope="prototype">
        <description>hide the specified child widget</description>
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="prototype">
        <description>show the specified child widget</description>
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.layout.RadioGroupSlide" superclass="dojox.layout.RadioGroup">
    <description>A Sliding Radio Group</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>on startup, set each of the panes off-screen (_showChild is called later)</description>
      </method>
      <method name="_positionChild" scope="prototype">
        <description>set the child out of view immediately after being hidden</description>
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="prototype">
        <description>Slide in the selected child widget</description>
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="prototype">
        <description>reset the position of the hidden pane out of sight</description>
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="easing" scope="instance-prototype" type="Object"/>
      <property name="zTop" scope="prototype" type="Integer">
        <description>A z-index to apply to the incoming pane</description>
      </property>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="_tmpConnect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._RadioButton" superclass="dijit._Widget">
    <description>The Buttons for a RadioGroup</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>start listening to mouseOver</description>
      </method>
      <method name="_onMouse" scope="prototype">
        <description>set the selected child on hover, and set our hover state class</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSelected" scope="prototype">
        <description>remove hover state class from sibling Buttons. This is easier (and more reliable)
	than setting up an additional connection to onMouseOut
	FIXME: this relies on the template being [div][span]node[/span][/div]</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="prototype" type="String">
        <description>the Text Label of the button</description>
      </property>
      <property name="page" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="child">
    <properties>
      <property name="_radioButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ResizeHandle" superclass="dijit._Widget">
    <description>A dragable handle used to resize an attached node.</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>setup our one major listener upon creation</description>
      </method>
      <method name="_beginSizing" scope="prototype">
        <description>setup movement listeners and calculate initial size</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSizing" scope="prototype">
        <description>called when moving the ResizeHandle ... determines
	new size based on settings/position and sets styles.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewCoords" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_changeSizing" scope="prototype">
        <description>apply sizing information based on information in (e) to attached node</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_endSizing" scope="prototype">
        <description>disconnect listenrs and cleanup sizing</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="prototype">
        <description>Stub fired when sizing is done, for things like Grid</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="targetId" scope="prototype" type="String">
        <description>id of the Widget OR DomNode that I will size</description>
      </property>
      <property name="targetContainer" scope="prototype" type="DomNode">
        <description>over-ride targetId and attch this handle directly to a reference of a DomNode</description>
      </property>
      <property name="resizeAxis" scope="prototype" type="String">
        <description>one of: x|y|xy limit resizing to a single axis, default to xy ...</description>
      </property>
      <property name="activeResize" scope="prototype" type="Boolean">
        <description>if true, node will size realtime with mouse movement,
	if false, node will create virtual node, and only resize target on mouseUp</description>
      </property>
      <property name="activeResizeClass" scope="prototype" type="String">
        <description>css class applied to virtual resize node.</description>
      </property>
      <property name="animateSizing" scope="instance-prototype" type="Boolean">
        <description>only applicable if activeResize = false. onMouseup, animate the node to the
	new size</description>
      </property>
      <property name="animateMethod" scope="prototype" type="String">
        <description>one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; ... visual effect only. combine will &amp;quot;scale&amp;quot;
	node to size, &amp;quot;chain&amp;quot; will alter width, then height</description>
      </property>
      <property name="animateDuration" scope="prototype" type="Integer">
        <description>time in MS to run sizing animation. if animateMethod=&amp;quot;chain&amp;quot;, total animation
	playtime is 2*animateDuration</description>
      </property>
      <property name="minHeight" scope="prototype" type="Integer">
        <description>smallest height in px resized node can be</description>
      </property>
      <property name="minWidth" scope="prototype" type="Integer">
        <description>smallest width in px resize node can be</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_resizeHelper" scope="instance" type="Object"/>
      <property name="minSize" scope="instance" type="Object"/>
      <property name="_resizeX" scope="instance" type="Object"/>
      <property name="_resizeY" scope="instance" type="Object"/>
      <property name="targetDomNode" scope="instance" type="Object"/>
      <property name="_isSizing" scope="instance" type="Object"/>
      <property name="startPoint" scope="instance" type="Object"/>
      <property name="startSize" scope="instance" type="Object"/>
      <property name="_pconnects" scope="instance" type="Object"/>
      <property name="_activeResizeLastEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ResizeHandle.targetWidget">
    <properties>
      <property name="resize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._ResizeHelper" superclass="dijit._Widget">
    <description>A global private resize helper shared between any resizeHandle with activeSizing='false;</description>
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="show" scope="prototype">
        <description>show helper to start resizing</description>
      </method>
      <method name="hide" scope="prototype">
        <description>hide helper after resizing is complete</description>
      </method>
      <method name="resize" scope="prototype">
        <description>size the widget and place accordingly
	FIXME: this is off when padding present</description>
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.layout._ResizeHelper.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorContainer" superclass="dijit.layout.StackContainer">
    <description>Extends a StackContainer to automatically transition between children
	and display navigation in the form of tabs or a pager.</description>
    <example>
		&lt;div dojoType="dojox.layout.RotatorContainer" id="myRotator" showTabs="true" autoStart="true" transitionDelay="5000"&gt;
			&lt;div id="pane1" dojoType="dijit.layout.ContentPane" title="1"&gt;
				Pane 1!
			&lt;/div&gt;
			&lt;div id="pane2" dojoType="dijit.layout.ContentPane" title="2"&gt;
				Pane 2!
			&lt;/div&gt;
			&lt;div id="pane3" dojoType="dijit.layout.ContentPane" title="3" transitionDelay="10000"&gt;
				Pane 3 with overrided transitionDelay!
			&lt;/div&gt;
		&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Initializes the DOM nodes, tabs, and transition stuff.</description>
      </method>
      <method name="startup" scope="prototype">
        <description>Initializes the pagers.</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>Unsubscribe to all of our topics</description>
      </method>
      <method name="setAttribute" scope="prototype">
        <description>Exposes attributes to be changed.</description>
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePager" scope="prototype">
        <description>Notify the pager's current and total numbers.</description>
      </method>
      <method name="_onMouseOver" scope="prototype">
        <description>Triggered when the mouse is moved over the rotator container.</description>
      </method>
      <method name="_onMouseOut" scope="prototype">
        <description>Triggered when the mouse is moved off the rotator container.</description>
      </method>
      <method name="_resetTimer" scope="prototype">
        <description>Resets the timer used to start the next transition.</description>
      </method>
      <method name="_cycle" scope="prototype">
        <description>Cycles to the next/previous child.</description>
        <parameters>
          <parameter name="next" type="boolean or int" usage="required"/>
        </parameters>
      </method>
      <method name="_manualChange" scope="prototype">
        <description>This function is only called when a manual change occurs in which
	case we may need to stop playing and we need to reset the cycle counter</description>
      </method>
      <method name="_play" scope="prototype">
        <description>Schedules the next transition.</description>
        <parameters>
          <parameter name="skip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pause" scope="prototype">
        <description>Clears the transition timer and pauses the rotator.</description>
      </method>
      <method name="_state" scope="prototype">
        <description>Fired when the play/pause pager button is toggled.</description>
        <parameters>
          <parameter name="playing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <description>Dispatches the appropriate transition.</description>
        <parameters>
          <parameter name="next" type="Widget" usage="required"/>
          <parameter name="prev" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_transitionEnd" scope="prototype"/>
      <method name="_fade" scope="prototype">
        <description>Crossfades two children.</description>
        <parameters>
          <parameter name="next" type="Widget" usage="required"/>
          <parameter name="prev" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_styleNode" scope="prototype">
        <description>Helper function to style the children.</description>
        <parameters>
          <parameter name="node" type="DOMnode" usage="required"/>
          <parameter name="opacity" type="number" usage="required"/>
          <parameter name="zIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="showTabs" scope="instance-prototype" type="Boolean">
        <description>Sets the display of the tabs.  The tabs are actually a StackController.
	The child's title is used for the tab's label.</description>
      </property>
      <property name="transitionDelay" scope="prototype" type="int">
        <description>The delay in milliseconds before transitioning to the next child.</description>
      </property>
      <property name="transition" scope="prototype" type="String">
        <description>The type of transition to perform when switching children.
	A null transition will transition instantly.</description>
      </property>
      <property name="transitionDuration" scope="instance-prototype" type="int">
        <description>The duration of the transition in milliseconds.</description>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <description>Starts the timer to transition children upon creation.</description>
      </property>
      <property name="suspendOnHover" scope="prototype" type="Boolean">
        <description>Pause the rotator when the mouse hovers over it.</description>
      </property>
      <property name="pauseOnManualChange" scope="instance-prototype" type="Boolean">
        <description>Pause the rotator when the tab is changed or the pager's next/previous
	buttons are clicked.</description>
      </property>
      <property name="reverse" scope="prototype" type="Boolean">
        <description>Causes the rotator to rotate in reverse order.</description>
      </property>
      <property name="pagerId" scope="prototype" type="String">
        <description>ID the pager widget.</description>
      </property>
      <property name="cycles" scope="instance-prototype" type="int">
        <description>Number of cycles before pausing.</description>
      </property>
      <property name="_timer" scope="instance-prototype" type="int">
        <description>The timer used for controlling the transitions.</description>
      </property>
      <property name="_over" scope="instance-prototype" type="Boolean">
        <description>Flag to quick check if the mouse is over the rotator.</description>
      </property>
      <property name="_playing" scope="instance-prototype" type="Boolean">
        <description>Flag to track transition state.</description>
      </property>
      <property name="pagerClass" scope="prototype" type="String">
        <description>The declared Class of the Pager used for this Widget</description>
      </property>
      <property name="tabNode" scope="instance" type="Object"/>
      <property name="_stackController" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager" superclass="dijit._Widget">
    <description>Defines controls used to manipulate a RotatorContainer</description>
    <example>A pager with the current/total children and previous/next buttons.
		&lt;div dojoType="dojox.layout.RotatorPager" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="previous"&gt;Prev&lt;/button&gt;
			&lt;span dojoAttachPoint="current"&gt;&lt;/span&gt; / &lt;span dojoAttachPoint="total"&gt;&lt;/span&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="next"&gt;Next&lt;/button&gt;
		&lt;/div&gt;</example>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <description>Unsubscribe to all of our topics</description>
      </method>
      <method name="_state" scope="prototype">
        <description>Updates the display of the play/pause button</description>
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <description>Updates the pager's play/pause button, current child, and total number of children.</description>
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
          <parameter name="current" type="int" usage="required"/>
          <parameter name="total" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="rotatorId" scope="prototype" type="int">
        <description>The ID of the rotator this pager is tied to.
	Only required if defined outside of the RotatorContainer's container.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.current">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.total">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ScrollPane" superclass="dijit.layout._LayoutWidget">
    <description>A pane that &amp;quot;scrolls&amp;quot; its content based on the mouse poisition inside</description>
    <example>
		&lt;div dojoType="dojox.layout.ScrollPane" style="width:150px height:300px;"&gt;
			&lt;!-- any height content --&gt;
		&lt;/div&gt;</example>
    <methods>
      <method name="layout" scope="prototype">
        <description>calculates required sizes. Call this if you add/remove content manually, or reload the content.</description>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_set" scope="prototype">
        <description>set the pane's scroll offset, and position the virtual scroll helper</description>
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_calc" scope="prototype">
        <description>calculate the relative offset of the cursor over the node, and call _set</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leave" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="_line" scope="instance-prototype" type="dojo._Line">
        <description>storage for our top and bottom most scrollpoints</description>
      </property>
      <property name="_lo" scope="instance-prototype" type="the">
        <description>height of the visible pane</description>
      </property>
      <property name="_offset" scope="prototype" type="Object"/>
      <property name="orientation" scope="prototype" type="String">
        <description>either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot; for scroll orientation.</description>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="_helpLine" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_vertical" scope="instance" type="Object"/>
      <property name="_dir" scope="instance" type="Object"/>
      <property name="_edge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter" superclass="dijit.layout._Splitter">
    <description>A draggable and toggle-to-close/open spacer between two items in a BorderContainer</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_onMouseUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onPrelimMouseMove" scope="prototype">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="prototype">
        <description>handle mousedown events from the domNode</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="prototype"/>
      <method name="_getStyleProps" scope="prototype">
        <description>create an object with the style property name: values
	that will need to be applied to the child pane render the given state</description>
        <parameters>
          <parameter name="paneNode" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
          <parameter name="paneStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="prototype"/>
      <method name="_setOpenAttr" scope="prototype">
        <description>setter for the open property</description>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype"/>
      <method name="onClose" scope="prototype"/>
      <method name="_toggleMe" scope="prototype">
        <description>event handle, toggle the open state</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="container" scope="prototype" type="Object"/>
      <property name="child" scope="prototype" type="Object"/>
      <property name="region" scope="prototype" type="Object"/>
      <property name="open" scope="instance-prototype" type="Boolean">
        <description>the initial and current state of the splitter (and its attached pane)</description>
      </property>
      <property name="closedThreshold" scope="prototype" type="Integer">
        <description>how small the attached pane can be before its considered closed</description>
      </property>
      <property name="openSize" scope="instance-prototype" type="String">
        <description>the css height/width value to apply by default when the attached pane is open</description>
      </property>
      <property name="_closedSize" scope="prototype" type="String">
        <description>the css height/width value to apply by default when the attached pane is closed</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_openStyleProps" scope="instance" type="Object"/>
      <property name="_onUpHandle" scope="instance" type="Object"/>
      <property name="_startPosn" scope="instance" type="Object"/>
      <property name="_onMoveHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd">
    <methods>
      <method name="_setGcDndHandle" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="withHandles" type="Object" usage="required"/>
          <parameter name="handleClasses" type="Object" usage="required"/>
          <parameter name="first" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handdleIE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar">
    <description>An Object, which represents the object being moved in a GridContainer</description>
    <methods>
      <method name="construct" scope="prototype">
        <description>A constructor function. it is separate so it can be (dynamically)
	overwritten in case of need.</description>
        <parameters>
          <parameter name="opacity" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <description>Destroy this avatar instance</description>
      </method>
      <method name="update" scope="prototype"/>
      <method name="_generateText" scope="prototype"/>
    </methods>
    <properties>
      <property name="manager" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd" superclass="dojo.dnd.Source">
    <description>dnd source handling plotted zone to show the dropping area</description>
    <methods>
      <method name="_calculateCoords" scope="prototype">
        <description>Calculate each position of children</description>
        <parameters>
          <parameter name="height" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="prototype">
        <description>Checks if user clicked on &amp;quot;approved&amp;quot; items.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setDndItemSelectable" scope="prototype">
        <description>set an item as selectable</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="isSelectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDraggedWidget" scope="prototype">
        <description>Return one or more widget selected during the drag.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="isAccepted" scope="prototype">
        <description>test if this node can be accepted</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="onDndDrop" scope="prototype">
        <description>Called to finish the DnD operation</description>
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>Event processor for onmousedown.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>Event processor for onmouseup.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>Event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="prototype">
        <description>Assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status</description>
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <description>Removes a class of the current target anchor based on &amp;quot;before&amp;quot; status.</description>
      </method>
      <method name="setIndicatorPosition" scope="prototype">
        <description>set the position of the drop indicator</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOutEvent" scope="prototype"/>
      <method name="deleteDashedZone" scope="prototype">
        <description>hide the dashed zone</description>
      </method>
      <method name="insertDashedZone" scope="prototype">
        <description>Insert the dashed zone at the right place</description>
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="prototype">
        <description>Inserts new data items (see Dojo Container's insertNodes method for details).</description>
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_checkAutoScroll" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopAutoScroll" scope="prototype"/>
      <method name="_sumAncestorProperties" scope="prototype">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="GC_OFFSET_X" scope="prototype" type="Object"/>
      <property name="GC_OFFSET_Y" scope="prototype" type="Object"/>
      <property name="onDndStart" scope="prototype" type="Object"/>
      <property name="onDndCancel" scope="prototype" type="Object"/>
      <property name="onOverEvent" scope="prototype" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="anchor" scope="instance" type="Object"/>
      <property name="containerSource" scope="instance" type="Object"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="targetBox" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="_over" scope="instance" type="Object"/>
      <property name="firstIndicator" scope="instance" type="Object"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="autoScrollActive" scope="instance" type="Object"/>
      <property name="childBoxes" scope="instance" type="Object"/>
      <property name="dropIndicator" scope="instance" type="Object"/>
      <property name="withHandles" scope="instance" type="Object"/>
      <property name="handleClasses" scope="instance" type="Object"/>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="allowAutoScroll" scope="instance" type="Object"/>
      <property name="dom" scope="instance" type="Object"/>
      <property name="singular" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="Object"/>
      <property name="defaultHandleClass" scope="instance" type="Object"/>
      <property name="isDropped" scope="instance" type="Object"/>
      <property name="isOffset" scope="instance" type="Object"/>
      <property name="hideSource" scope="instance" type="Object"/>
      <property name="_drop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.current">
    <properties>
      <property name="coords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd._drop.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.offsetDrag">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.dropObject">
    <properties>
      <property name="c" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.DropIndicator">
    <description>An empty widget to show at the user the drop zone of the widget.</description>
    <methods>
      <method name="isInserted" scope="prototype"/>
      <method name="create" scope="prototype">
        <parameters>
          <parameter name="/*nodeRef*/){   if(this.node &amp;&amp; this.isInserted()) return this.node;   var h= &quot;90px&quot;;    var el = document.createElement(this.tag);   if(this.style){    el.className = this.style;    el.style.height = h;   }else{    with(el.style) {     position = &quot;relative&quot;;     border = &quot;1px dashed #F60&quot;;     margin = &quot;2px&quot;;     height = h;    }   }   this.node = el;   return el;  },    destroy : function(" type="NodenodeRef" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.DropIndicator.node.parentNode">
    <properties>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="document.body">
    <methods>
      <method name="onselectstart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math">
    <description>A collection of various advanced math functions.</description>
    <methods>
      <method name="degreesToRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="radiansToDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="factorial" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="NaN"/>
        </return-types>
      </method>
      <method name="permutations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="k" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="combinations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="r" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bernstein" scope="instance">
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="i" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="gaussian" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="sd" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="variance" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="optional"/>
          <parameter name="step" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="distance" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="midpoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves">
    <properties>
      <property name="Line" scope="instance" type="Object"/>
      <property name="Bezier" scope="instance" type="Object"/>
      <property name="CatmullRom" scope="instance" type="Object"/>
      <property name="Arc" scope="instance" type="Object"/>
      <property name="CenteredArc" scope="instance" type="Object"/>
      <property name="Circle" scope="instance" type="Object"/>
      <property name="Path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.matrix">
    <methods>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="product" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <return-types>
          <return-type type="Number"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inverse" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="determinant" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="upperTriangle" scope="instance">
        <parameters>
          <parameter name="m" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
          <parameter name="value" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="ones" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="zeros" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="identity" scope="instance">
        <parameters>
          <parameter name="size" type="Number" usage="required"/>
          <parameter name="scale" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adjoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="transpose" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="points" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="copy" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="factor" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="iDF" scope="instance" type="Object"/>
      <property name="ALMOST_ZERO" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.off">
    <description>the Dojo Offline project</description>
    <methods>
      <method name="onLoad" scope="instance">
        <description>Called when Dojo Offline can be used.</description>
      </method>
      <method name="onNetwork" scope="instance">
        <description>Called when our on- or offline- status changes.</description>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Either &amp;quot;online&amp;quot; or &amp;quot;offline&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="initialize" scope="instance">
        <description>void
	Called when a Dojo Offline-enabled application is finished
	configuring Dojo Offline, and is ready for Dojo Offline to
	initialize itself.</description>
      </method>
      <method name="goOffline" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Manually goes offline, away from the network.</description>
      </method>
      <method name="goOnline" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Attempts to go online.</description>
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>An optional callback function that will receive one argument:
	whether the site is available or not and is boolean. If this
	function is not present we call dojo.xoff.onOnline instead if
	we are able to go online.
	console.debug(&amp;quot;goOnline&amp;quot;);</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFrameworkEvent" scope="instance">
        <description>For advanced usage; most developers can ignore this.
	A standard event handler that can be attached to to find out
	about low-level framework events. Most developers will not need to
	attach to this method; it is meant for low-level information
	that can be useful for updating offline user-interfaces in
	exceptional circumstances. The default Dojo Offline UI
	widget takes care of most of these situations.</description>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>The type of the event:
	* &amp;quot;offlineCacheInstalled&amp;quot;
	An event that is fired when a user
	has installed an offline cache after the page has been loaded.
	If a user didn't have an offline cache when the page loaded, a
	UI of some kind might have prompted them to download one. This
	method is called if they have downloaded and installed an
	offline cache so a UI can reinitialize itself to begin using
	this offline cache.
	* &amp;quot;coreOperationFailed&amp;quot;
	Fired when a core operation during interaction with the
	offline cache is denied by the user. Some offline caches, such
	as Google Gears, prompts the user to approve or deny caching
	files, using the database, and more. If the user denies a
	request that is core to Dojo Offline's operation, we set
	dojox.off.coreOpFailed to true and call this method for
	listeners that would like to respond some how to Dojo Offline
	'failing fast'.
	* &amp;quot;save&amp;quot;
	Called whenever the framework saves data into persistent
	storage. This could be useful for providing save feedback
	or providing appropriate error feedback if saving fails
	due to a user not allowing the save to occur</description>
          </parameter>
          <parameter name="saveData" type="Object" usage="optional">
            <description>If the type was 'save', then a saveData object is provided with
	further save information. This object has the following properties:
	* status - dojox.storage.SUCCESS, dojox.storage.PENDING, dojox.storage.FAILED
	Whether the save succeeded, whether it is pending based on a UI
	dialog asking the user for permission, or whether it failed.
	* isCoreSave - boolean
	If true, then this save was for a core piece of data necessary
	for the functioning of Dojo Offline. If false, then it is a
	piece of normal data being saved for offline access. Dojo
	Offline will 'fail fast' if some core piece of data could not
	be saved, automatically setting dojox.off.coreOpFailed to
	'true' and dojox.off.enabled to 'false'.
	* key - String
	The key that we are attempting to persist
	* value - Object
	The object we are trying to persist
	* namespace - String
	The Dojo Storage namespace we are saving this key/value pair
	into, such as &amp;quot;default&amp;quot;, &amp;quot;Documents&amp;quot;, &amp;quot;Contacts&amp;quot;, etc.
	Optional.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkOfflineCacheAvailable" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLoad" scope="instance"/>
      <method name="_onOfflineCacheChecked" scope="instance"/>
      <method name="_keepCheckingUntilInstalled" scope="instance"/>
      <method name="_finishStartingUp" scope="instance"/>
      <method name="_onPageLoad" scope="instance"/>
      <method name="_onStorageLoad" scope="instance"/>
      <method name="_isSiteAvailable" scope="instance">
        <description>Determines if our web application's website is available.</description>
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>An optional callback function that will receive one argument:
	whether the site is available or not and is boolean. If this
	function is not present we call dojox.off.onNetwork instead if we
	are able to go online.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startNetworkThread" scope="instance"/>
      <method name="_getAvailabilityURL" scope="instance"/>
      <method name="_onOfflineCacheInstalled" scope="instance"/>
      <method name="_cacheDojoResources" scope="instance"/>
      <method name="_save" scope="instance">
        <description>Causes the Dojo Offline framework to save its configuration
	data into local storage.</description>
      </method>
      <method name="_load" scope="instance">
        <description>Causes the Dojo Offline framework to load its configuration
	data from local storage</description>
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isOnline" scope="instance" type="Object"/>
      <property name="NET_CHECK" scope="instance" type="Object"/>
      <property name="STORAGE_NAMESPACE" scope="instance" type="Object"/>
      <property name="enabled" scope="instance" type="Object"/>
      <property name="availabilityURL" scope="instance" type="Object"/>
      <property name="goingOnline" scope="instance" type="Object"/>
      <property name="coreOpFailed" scope="instance" type="Object"/>
      <property name="doNetChecking" scope="instance" type="Object"/>
      <property name="hasOfflineCache" scope="instance" type="Object"/>
      <property name="browserRestart" scope="instance" type="Object"/>
      <property name="_STORAGE_APP_NAME" scope="instance" type="Object"/>
      <property name="_initializeCalled" scope="instance" type="Object"/>
      <property name="_storageLoaded" scope="instance" type="Object"/>
      <property name="_pageLoaded" scope="instance" type="Object"/>
      <property name="_common" scope="instance" type="Object"/>
      <property name="offline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.off.files">
    <methods>
      <method name="slurp" scope="instance">
        <description>Autoscans the page to find all resources to
	cache. This includes scripts, images, CSS, and hyperlinks
	to pages that are in the same scheme/port/host as this
	page. We also scan the embedded CSS of any stylesheets
	to find @import statements and url()'s.
	You should call this method from the top-level, outside of
	any functions and before the page loads:
	&amp;lt;script&amp;gt;
	dojo.require(&amp;quot;dojox.sql&amp;quot;);
	dojo.require(&amp;quot;dojox.off&amp;quot;);
	dojo.require(&amp;quot;dojox.off.ui&amp;quot;);
	dojo.require(&amp;quot;dojox.off.sync&amp;quot;);
	// configure how we should work offline
	// set our application name
	dojox.off.ui.appName = &amp;quot;Moxie&amp;quot;;
	// automatically &amp;quot;slurp&amp;quot; the page and
	// capture the resources we need offline
	dojox.off.files.slurp();
	// tell Dojo Offline we are ready for it to initialize itself now
	// that we have finished configuring it for our application
	dojox.off.initialize();
	&amp;lt;/script&amp;gt;
	Note that inline styles on elements are not handled (i.e.
	if you somehow have an inline style that uses a URL);
	object and embed tags are not scanned since their format
	differs based on type; and elements created by JavaScript
	after page load are not found. For these you must manually
	add them with a dojox.off.files.cache() method call.
	just schedule the slurp once the page is loaded and
	Dojo Offline is ready to slurp; dojox.off will call
	our _slurp() method before indicating it is finished
	loading</description>
      </method>
      <method name="cache" scope="instance">
        <description>void
	Caches a file or list of files to be available offline. This
	can either be a full URL, such as http://foobar.com/index.html,
	or a relative URL, such as ../index.html. This URL is not
	actually cached until dojox.off.sync.synchronize() is called.</description>
        <parameters>
          <parameter name="urlOrList" type="String" usage="required">
            <description>or Array[]
	A URL of a file to cache or an Array of Strings of files to
	cache
	console.debug(&amp;quot;dojox.off.files.cache, urlOrList=&amp;quot;+urlOrList);</description>
          </parameter>
        </parameters>
      </method>
      <method name="printURLs" scope="instance">
        <description>A helper function that will dump and print out
	all of the URLs that are cached for offline
	availability. This can help with debugging if you
	are trying to make sure that all of your URLs are
	available offline</description>
      </method>
      <method name="remove" scope="instance">
        <description>void
	Removes a URL from the list of files to cache.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="isAvailable" scope="instance">
        <description>boolean
	Determines whether the given resource is available offline.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL to check</description>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <description>void
	console.debug(&amp;quot;dojox.off.files.refresh&amp;quot;);
	For advanced usage; most developers can ignore this.
	Refreshes our list of offline resources,
	making them available offline.</description>
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>A callback that receives two arguments: whether an error
	occurred, which is a boolean; and an array of error message strings
	with details on errors encountered. If no error occured then message is
	empty array with length 0.</description>
          </parameter>
        </parameters>
      </method>
      <method name="abortRefresh" scope="instance">
        <description>For advanced usage; most developers can ignore this.
	Aborts and cancels a refresh.</description>
      </method>
      <method name="_slurp" scope="instance"/>
      <method name="_sameLocation" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trimAnchor" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doRefresh" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="newVersion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getVersionInfo" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="versionURL" scope="instance" type="String">
        <description>An optional file, that if present, records the version
	of our bundle of files to make available offline. If this
	file is present, and we are not currently debugging,
	then we only refresh our offline files if the version has
	changed.</description>
      </property>
      <property name="listOfURLs" scope="instance" type="Array">
        <description>For advanced usage; most developers can ignore this.
	Our list of URLs that will be cached and made available
	offline.</description>
      </property>
      <property name="refreshing" scope="instance" type="boolean">
        <description>For advanced usage; most developers can ignore this.
	Whether we are currently in the middle
	of refreshing our list of offline files.</description>
      </property>
      <property name="_cancelID" scope="instance" type="Object"/>
      <property name="_error" scope="instance" type="Object"/>
      <property name="_errorMessages" scope="instance" type="Object"/>
      <property name="_currentFileIndex" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="_doSlurp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.off.resources">
    <properties>
      <property name="learnhow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.off.sync">
    <methods>
      <method name="onSync" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="synchronize" scope="instance">
        <description>void
	Starts synchronizing</description>
      </method>
      <method name="cancel" scope="instance">
        <description>void
	Attempts to cancel this sync session</description>
      </method>
      <method name="finishedDownloading" scope="instance">
        <description>Applications call this method from their
	after getting a &amp;quot;download&amp;quot; event in
	dojox.off.sync.onSync to signal that
	they are finished downloading any data
	that should be available offline</description>
        <parameters>
          <parameter name="successful" type="boolean" usage="optional">
            <description>Whether our downloading was successful or not.
	If not present, defaults to true.</description>
          </parameter>
          <parameter name="errorMessage" type="String" usage="optional">
            <description>If unsuccessful, a message explaining why</description>
          </parameter>
        </parameters>
      </method>
      <method name="start" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Called at the start of the syncing process. Advanced
	developers can over-ride this method to use their
	own sync mechanism to start syncing.</description>
      </method>
      <method name="refreshFiles" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Called when we are going to refresh our list
	of offline files during syncing. Advanced developers
	can over-ride this method to do some advanced magic related to
	refreshing files.
	dojo.debug(&amp;quot;refreshFiles&amp;quot;);</description>
      </method>
      <method name="upload" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Called when syncing wants to upload data. Advanced
	developers can over-ride this method to completely
	throw away the Action Log and replaying system
	and roll their own advanced sync mechanism if needed.</description>
      </method>
      <method name="download" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Called when syncing wants to download data. Advanced
	developers can over-ride this method to use their
	own sync mechanism.</description>
      </method>
      <method name="finished" scope="instance">
        <description>void
	For advanced usage; most developers can ignore this.
	Called when syncing is finished. Advanced
	developers can over-ride this method to clean
	up after finishing their own sync
	mechanism they might have rolled.</description>
      </method>
      <method name="_save" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_load" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isSyncing" scope="instance" type="Object"/>
      <property name="cancelled" scope="instance" type="Object"/>
      <property name="successful" scope="instance" type="Object"/>
      <property name="details" scope="instance" type="Object"/>
      <property name="error" scope="instance" type="Object"/>
      <property name="actions" scope="instance" type="Object"/>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.off.sync.ActionLog">
    <methods>
      <method name="add" scope="prototype">
        <description>void
	Adds an action to our action log</description>
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReplay" scope="prototype">
        <description>void
	Called when we replay our log, for each of our action
	entries.</description>
        <parameters>
          <parameter name="action" type="Object" usage="required">
            <description>A custom object literal representing an action for this
	application, such as
	{actionName: &amp;quot;create&amp;quot;, item: {title: &amp;quot;message&amp;quot;, content: &amp;quot;hello world&amp;quot;}}</description>
          </parameter>
          <parameter name="actionLog" type="dojox.off.sync.ActionLog" usage="required">
            <description>A reference to the dojox.off.sync.actions log so that developers
	can easily call actionLog.continueReplay() or actionLog.haltReplay().</description>
          </parameter>
        </parameters>
      </method>
      <method name="length" scope="prototype">
        <description>Number
	Returns the length of this
	action log</description>
      </method>
      <method name="haltReplay" scope="prototype">
        <description>void
	Halts replaying this command log.</description>
        <parameters>
          <parameter name="reason" type="String" usage="required">
            <description>The reason we halted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="continueReplay" scope="prototype">
        <description>void
	Indicates that we should continue processing out list of
	actions.</description>
      </method>
      <method name="clear" scope="prototype">
        <description>void
	Completely clears this action log of its entries</description>
      </method>
      <method name="replay" scope="prototype">
        <description>void
	For advanced usage; most developers can ignore this.
	Replays all of the commands that have been
	cached in this command log when we go back online;
	onCommand will be called for each command we have</description>
      </method>
      <method name="onReplayFinished" scope="prototype">
        <description>For advanced usage; most developers can ignore this.
	Called when we are finished replaying our commands;
	called if we have successfully exhausted all of our
	commands, or if an error occurred during replaying.
	The default implementation simply continues the
	synchronization process. Connect to this to register
	for the event:
	dojo.connect(dojox.off.sync.actions, &amp;quot;onReplayFinished&amp;quot;,
	someFunc)</description>
      </method>
      <method name="toString" scope="prototype"/>
      <method name="_save" scope="prototype">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_load" scope="prototype">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="entries" scope="instance-prototype" type="Array">
        <description>An array of our action entries, where each one is simply a custom
	object literal that were passed to add() when this action entry
	was added.</description>
      </property>
      <property name="reasonHalted" scope="instance-prototype" type="String">
        <description>If we halted, the reason why</description>
      </property>
      <property name="isReplaying" scope="instance-prototype" type="boolean">
        <description>If true, we are in the middle of replaying a command log; if false,
	then we are not</description>
      </property>
      <property name="autoSave" scope="prototype" type="boolean">
        <description>Whether we automatically save the action log after each call to
	add(); defaults to true. For applications that are rapidly adding
	many action log entries in a short period of time, it can be
	useful to set this to false and simply call save() yourself when
	you are ready to persist your command log -- otherwise performance
	could be slow as the default action is to attempt to persist the
	actions log constantly with calls to add().</description>
      </property>
    </properties>
  </class>
  <class type="dojox.off.ui">
    <methods>
      <method name="onLoad" scope="instance">
        <description>A function that should be connected to allow your
	application to know when Dojo Offline, the page, and
	the Offline Widget are all initialized and ready to be
	used:
	dojo.connect(dojox.off.ui, &amp;quot;onLoad&amp;quot;, someFunc)</description>
      </method>
      <method name="_initialize" scope="instance"/>
      <method name="_doAutoEmbed" scope="instance"/>
      <method name="_templateLoaded" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_testNet" scope="instance"/>
      <method name="_updateNetIndicator" scope="instance"/>
      <method name="_initLearnHow" scope="instance"/>
      <method name="_validateAppName" scope="instance">
        <parameters>
          <parameter name="appName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSyncUI" scope="instance"/>
      <method name="_setSyncMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSyncMessage" scope="instance"/>
      <method name="_initImages" scope="instance"/>
      <method name="_showDetails" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsBrowserRestart" scope="instance"/>
      <method name="_showNeedsOfflineCache" scope="instance"/>
      <method name="_hideNeedsOfflineCache" scope="instance"/>
      <method name="_initMainEvtHandlers" scope="instance"/>
      <method name="_setOfflineEnabled" scope="instance">
        <parameters>
          <parameter name="enabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_syncFinished" scope="instance"/>
      <method name="_onFrameworkEvent" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="saveData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSync" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNetwork" scope="instance">
        <description>Called when we go on- or off-line</description>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;online&amp;quot; if we just moved online, and &amp;quot;offline&amp;quot; if we just
	moved offline.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="appName" scope="instance" type="Object"/>
      <property name="autoEmbed" scope="instance" type="Object"/>
      <property name="autoEmbedID" scope="instance" type="Object"/>
      <property name="runLink" scope="instance" type="Object"/>
      <property name="runLinkTitle" scope="instance" type="Object"/>
      <property name="learnHowPath" scope="instance" type="Object"/>
      <property name="customLearnHowPath" scope="instance" type="Object"/>
      <property name="htmlTemplatePath" scope="instance" type="Object"/>
      <property name="cssTemplatePath" scope="instance" type="Object"/>
      <property name="onlineImagePath" scope="instance" type="Object"/>
      <property name="offlineImagePath" scope="instance" type="Object"/>
      <property name="rollerImagePath" scope="instance" type="Object"/>
      <property name="checkmarkImagePath" scope="instance" type="Object"/>
      <property name="learnHowJSPath" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation">
    <description>A simple, experimental PowerPoint-like presentation project</description>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Deck" superclass="dijit.layout.StackContainer">
    <description>dojox.presentation class
	basic powerpoint esque engine for handling transitons and control
	in a page-by-page and part-by-part way
	FIXME: parsing part(s)/widget(s) in href=&amp;quot;&amp;quot; Slides not working
	TODO: make auto actions progress.
	FIXME: Safari keydown/press/up listener not working.
	noClick=true prevents progression of slides in that broweser</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>connect to the various handlers and controls for this presention</description>
      </method>
      <method name="moveTo" scope="prototype">
        <description>jump to slide based on param</description>
        <parameters>
          <parameter name="number" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <description>stub function? TODOC: ?</description>
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextSlide" scope="prototype">
        <description>transition to the next slide.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="previousSlide" scope="prototype">
        <description>transition to the previous slide</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="getHash" scope="prototype">
        <description>get the current hash to set in localtion</description>
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideNav" scope="prototype">
        <description>hides navigation</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showNav" scope="prototype">
        <description>shows navigation</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleNav" scope="prototype">
        <description>does nothing? _that_ seems useful.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSlides" scope="prototype">
        <description>populate navigation select list with refs to slides call this
	if you add a node to your presentation dynamically.</description>
      </method>
      <method name="_onEvent" scope="prototype">
        <description>main presentation function, determines next 'best action' for a
	specified event.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_gotoSlide" scope="prototype">
        <description>goes to slide</description>
        <parameters>
          <parameter name="slideIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_isUnclickable" scope="prototype">
        <description>returns true||false base of a nodes click-ability</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_readHash" scope="prototype"/>
      <method name="_setHash" scope="prototype">
        <description>sets url #mark to direct slide access</description>
      </method>
      <method name="_resizeWindow" scope="prototype">
        <description>resize this and children to fix this window/container</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <description>over-ride stackcontainers _transition method
	but atm, i find it to be ugly with not way to call
	_showChild() without over-riding it too. hopefull
	basic toggles in superclass._transition will be available
	in dijit, and this won't be necessary.</description>
        <parameters>
          <parameter name="newWidget" type="Object" usage="required"/>
          <parameter name="oldWidget" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="fullScreen" scope="prototype" type="Boolean">
        <description>unsupported (that i know of) just yet. Default it to take control
	of window. Would be nice to be able to contain presentation in a
	styled container, like StackContainer ... theoretically possible.
	[and may not need this variable?]</description>
      </property>
      <property name="useNav" scope="prototype" type="Boolean">
        <description>true to allow navigation popup, false to disallow</description>
      </property>
      <property name="navDuration" scope="prototype" type="Integer">
        <description>time in MS fadein/out of popup nav [default: 250]</description>
      </property>
      <property name="noClick" scope="prototype" type="Boolean">
        <description>if true, prevents _any_ click events to propagate actions
	(limiting control to keyboard and/or action.on=&amp;quot;auto&amp;quot; or action.delay=&amp;quot;&amp;quot;
	actions.</description>
      </property>
      <property name="setHash" scope="prototype" type="Boolean">
        <description>if true, window location bar will get a #link to slide for direct
	access to a particular slide number.</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="nextIcon" scope="prototype" type="String">
        <description>icon for navigation &amp;quot;next&amp;quot; button</description>
      </property>
      <property name="prevIcon" scope="prototype" type="String">
        <description>icon for navigation &amp;quot;previous&amp;quot; button</description>
      </property>
      <property name="_navOpacMin" scope="prototype" type="Object"/>
      <property name="_navOpacMax" scope="prototype" type="Object"/>
      <property name="_slideIndex" scope="instance-prototype" type="Object"/>
      <property name="_slides" scope="instance-prototype" type="Object"/>
      <property name="_navShowing" scope="prototype" type="Object"/>
      <property name="_inNav" scope="prototype" type="Object"/>
      <property name="_navAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Deck.showNav.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Deck.select">
    <properties>
      <property name="selectedIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Slide" superclass="dijit.layout.ContentPane">
    <description>a Comonent of a dojox.presentation, and container for each 'Slide'
	made up of direct HTML (no part/action relationship), and dojox.presentation.Part(s),
	and their attached Actions.</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>setup this slide with actions and components (Parts)</description>
      </method>
      <method name="_nextAction" scope="prototype">
        <description>gotoAndPlay current cached action</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextAction" scope="prototype">
        <description>returns the _next action in this sequence</description>
      </method>
      <method name="_reset" scope="prototype">
        <description>set action chain back to 0 and re-init each Part</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="title" scope="prototype" type="String">
        <description>string to insert into titleNode, title of Slide</description>
      </property>
      <property name="refreshOnShow" scope="prototype" type="Object"/>
      <property name="preLoad" scope="prototype" type="Object"/>
      <property name="doLayout" scope="prototype" type="Object"/>
      <property name="parseContent" scope="prototype" type="Object"/>
      <property name="noClick" scope="prototype" type="Boolean">
        <description>true on slide tag prevents clicking, false allows
	(can also be set on base presentation for global control)</description>
      </property>
      <property name="_parts" scope="prototype" type="Object"/>
      <property name="_actions" scope="instance-prototype" type="Object"/>
      <property name="_actionIndex" scope="instance-prototype" type="Object"/>
      <property name="_runningDelay" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Slide.slideTitleText">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Part" superclass="dijit._Widget">
    <description>a node in a presentation.Slide that inherits control from a
	dojox.presentation.Action
	can be any element type, and requires styling before parsing</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>override and init() this component</description>
      </method>
      <method name="_reset" scope="prototype">
        <description>set part back to initial calculate state
	these _seem_ backwards, but quickToggle flips it</description>
      </method>
      <method name="_quickToggle" scope="prototype">
        <description>ugly [unworking] fix to test setting state of component
	before/after an animation. display:none prevents fadeIns?</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="as" scope="prototype" type="String">
        <description>like an ID, attach to Action via (part) as=&amp;quot;&amp;quot; / (action) forSlide=&amp;quot;&amp;quot; tags
	this should be unique identifier?</description>
      </property>
      <property name="startVisible" scope="prototype" type="boolean">
        <description>true to leave in page on slide startup/reset
	false to hide on slide startup/reset</description>
      </property>
      <property name="_isShowing" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.presentation.Action" superclass="dijit._Widget">
    <description>a widget to attach to a dojox.presentation.Part to control
	it's properties based on an inherited chain of events ...</description>
    <methods>
      <method name="_runAction" scope="prototype">
        <description>runs this action on attached node(s)</description>
      </method>
      <method name="_getSiblingsByType" scope="prototype">
        <description>quick replacement for getChildrenByType(&amp;quot;class&amp;quot;), but in
	a child here ... so it's getSiblings. courtesy bill in #dojo
	could be moved into parent, and just call this.getChildren(),
	which makes more sense.</description>
        <parameters>
          <parameter name="declaredClass" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="postCreate" scope="prototype">
        <description>run this once, should this be startup: function()?</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="on" scope="prototype" type="String">
        <description>FIXME: only 'click' supported ATM. plans include on=&amp;quot;delay&amp;quot;,
	on=&amp;quot;end&amp;quot; of=&amp;quot;&amp;quot;, and on=&amp;quot;auto&amp;quot;. those should make semantic sense
	to you.</description>
      </property>
      <property name="forSlide" scope="instance-prototype" type="String">
        <description>attach this action to a dojox.presentation.Part with a matching 'as' attribute</description>
      </property>
      <property name="toggle" scope="prototype" type="String">
        <description>will toggle attached [matching] node(s) via forSlide/as relationship(s)</description>
      </property>
      <property name="delay" scope="prototype" type="Integer"/>
      <property name="duration" scope="prototype" type="Integer">
        <description>default time in MS to run this action effect on it's 'forSlide' node</description>
      </property>
      <property name="_attached" scope="instance-prototype" type="Object"/>
      <property name="_nullAnim" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate">
    <description>Additional input validation methods</description>
    <methods>
      <method name="isText" scope="instance">
        <description>Checks if a string has non whitespace characters.
	Parameters allow you to constrain the length.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>length Number, minlength: Number, maxlength: Number}
	flags.length  If set, checks if there are exactly flags.length number of characters.
	flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="instance">
        <description>Validates whether a string denoting a number
	is between a max and min.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>max:Number min:Number, decimal:String}
	flags.max  A number, which the value must be less than or equal to for the validation to be true.
	flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	flags.decimal  The character used for the decimal point.  Default is &amp;quot;.&amp;quot;.
	fixes ticket #2908</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isNumberFormat" scope="instance">
        <description>Validates any sort of number based format</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>format:String flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidLuhn" scope="instance">
        <description>Compares value against the Luhn algorithm to verify its integrity</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="check" scope="instance">
        <description>validates user input of an HTML form based on input profile</description>
        <parameters>
          <parameter name="form" type="HTMLFormElement" usage="required">
            <description>form to be validated</description>
          </parameter>
          <parameter name="profile" type="Object" usage="required">
            <description>specifies how the form fields are to be validated
	{trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array,
	required:Array, dependencies:Object, constraints:Object, confirm:Object}</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="evaluateConstraint" scope="instance">
        <description>Evaluates dojo.validate.check() constraints that are specified as array
	arguments</description>
        <parameters>
          <parameter name="profile" type="The" usage="required">
            <description>dojo.validate.check() profile that this evaluation is against.</description>
          </parameter>
          <parameter name="constraint" type="Array" usage="required">
            <description>The single [] array of function and arguments for the function.</description>
          </parameter>
          <parameter name="fieldName" type="The" usage="required">
            <description>form dom name of the field being validated.</description>
          </parameter>
          <parameter name="elem" type="The" usage="required">
            <description>form element field.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCreditCard" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isValidCreditCardNumber" scope="instance">
        <description>checks if value matches the pattern for that card or any card types if none is specified</description>
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <description>Boolean CC #, white spaces and dashes are ignored</description>
          </parameter>
          <parameter name="ccType" type="String" usage="optional">
            <description>one of the values in cardinfo -- if Omitted it it returns a | delimited string of matching card types, or false if no matches found</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="string "/>
          <return-type type=" boolean"/>
        </return-types>
      </method>
      <method name="isValidCvv" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidIsbn" scope="instance">
        <description>Vadlidate ISBN-10 or ISBN-13 based on the length of value</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="isIpAddress" scope="instance">
        <description>Validates an IP address</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isUrl" scope="instance">
        <description>Checks if a string could be a valid URL</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or either.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isEmailAddress" scope="instance">
        <description>Checks if a string could be a valid email address</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getEmailAddressList" scope="instance">
        <description>Check if value is an email address list. If an empty list
	is returned, the value didn't pass the test or it was empty.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object (same as dojo.validate.isEmailAddressList)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="creditCard" scope="instance" type="Object">
        <description>Validate various credit card types</description>
      </property>
      <property name="_isInRangeCache" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="isbn" scope="instance" type="Object"/>
      <property name="regexp" scope="instance" type="Object"/>
      <property name="isEmailAddressList" scope="instance" type="Object"/>
      <property name="web" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.resources">
    <properties>
      <property name="_modules" scope="instance" type="Object"/>
      <property name="manualTests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.robot">
    <properties>
      <property name="recorder" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc">
    <methods>
      <method name="getTarget" scope="instance">
        <parameters>
          <parameter name="smd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toOrdered" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Client" scope="instance" type="Object"/>
      <property name="JsonRPC" scope="instance" type="Object"/>
      <property name="ProxiedPath" scope="instance" type="Object"/>
      <property name="transportRegistry" scope="instance" type="Object"/>
      <property name="envelopeRegistry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.JsonRest">
    <methods>
      <method name="commit" scope="instance">
        <description>Saves the dirty data using REST Ajax methods</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDirtyObjects" scope="instance"/>
      <method name="revert" scope="instance">
        <description>Reverts all the changes made to JSON/REST data</description>
      </method>
      <method name="changing" scope="instance">
        <description>adds an object to the list of dirty objects.  This object
	contains a reference to the object itself as well as a
	cloned and trimmed version of old object for use with
	revert.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteObject" scope="instance">
        <description>deletes an object</description>
        <parameters>
          <parameter name="object" type="object" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <description>Creates or gets a constructor for objects from this service</description>
        <parameters>
          <parameter name="service" type="Function|String" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <description>Fetches a resource by an absolute path/id and returns a dojo.Deferred.</description>
        <parameters>
          <parameter name="absoluteId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdAttribute" scope="instance">
        <description>Return the ids attribute used by this service (based on it's schema).
	Defaults to &amp;quot;id&amp;quot;, if not other id is defined</description>
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getServiceAndId" scope="instance">
        <description>Returns the REST service and the local id for the given absolute id. The result
	is returned as an object with a service property and an id property</description>
        <parameters>
          <parameter name="absoluteId" type="String" usage="required">
            <description>This is the absolute id of the object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="services" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="serviceAndId.service"/>
  <class type="serviceAndId.service._constructor">
    <mixins scope="normal">
      <mixin type="service._schema" scope="instance"/>
    </mixins>
    <properties>
      <property name="load" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="OfflineRest">
    <properties>
      <property name="stores" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Rest">
    <description>Creates a REST service using the provided path.</description>
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="if it is not found we have to just return the error"/>
          <return-type type="server error, let the error propagate"/>
        </return-types>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="serializedContent" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc.OfflineRest">
    <methods>
      <method name="turnOffAutoSync" scope="instance"/>
      <method name="downloadChanges" scope="instance"/>
      <method name="addStore" scope="instance">
        <description>Adds a store to the monitored store for local storage</description>
        <parameters>
          <parameter name="store" type="data-store" usage="required">
            <description>Store to add</description>
          </parameter>
          <parameter name="baseQuery" type="query" usage="optional">
            <description>This is the base query to should be used to load the items for
	the store. Generally you want to load all the items that should be
	available when offline.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="sync" scope="instance" type="Object"/>
      <property name="sendChanges" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="drr">
    <properties>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_change" scope="instance" type="Object"/>
      <property name="_get" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Service">
    <description>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</description>
    <methods>
      <method name="_generateService" scope="prototype">
        <parameters>
          <parameter name="serviceName" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="define the schema"/>
        </return-types>
      </method>
      <method name="_getRequest" scope="prototype">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="serialize with the right schema for the context;"/>
        </return-types>
      </method>
      <method name="_executeMethod" scope="prototype">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_options" scope="instance" type="Object"/>
      <property name="_requestId" scope="instance" type="Object"/>
      <property name="_nextId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="request">
    <properties>
      <property name="sync" scope="instance" type="Object"/>
      <property name="contentType" scope="instance" type="Object"/>
      <property name="headers" scope="instance" type="Object"/>
      <property name="target" scope="instance" type="Object"/>
      <property name="transport" scope="instance" type="Object"/>
      <property name="envelope" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Object"/>
      <property name="callbackParamName" scope="instance" type="Object"/>
      <property name="schema" scope="instance" type="Object"/>
      <property name="handleAs" scope="instance" type="Object"/>
      <property name="preventCache" scope="instance" type="Object"/>
      <property name="frameDoc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="r">
    <properties>
      <property name="url" scope="instance" type="Object"/>
      <property name="postData" scope="instance" type="Object"/>
      <property name="callbackParamName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.secure">
    <methods>
      <method name="_safeDojoFunctions" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="wrap" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="wrap the NodeList"/>
          <return-type type="use the safe document"/>
        </return-types>
      </method>
      <method name="sandbox" scope="instance">
        <description>Creates a secure sandbox from which scripts and HTML can be loaded that
	will only be able to access the provided element and it's descendants, the
	rest of the DOM and JS environment will not be accessible to the sandboxed
	scripts and HTML.</description>
        <parameters>
          <parameter name="element" type="The" usage="required">
            <description>DOM element to use as the container for the sandbox</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.secure.__Sandbox"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="unwrap" scope="instance" type="Object"/>
      <property name="badProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.secure.DOM">
    <mixins scope="prototype">
      <mixin type="result.safetyCheck" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.secure.capability">
    <methods>
      <method name="validate" scope="instance">
        <description>pass in the text of a script. If it passes and it can be eval'ed, it should be safe.
	Note that this does not do full syntax checking, it relies on eval to reject invalid scripts.
	There are also known false rejections:
	Nesting vars inside blocks will not declare the variable for the outer block
	Named functions are not treated as declaration so they are generally not allowed unless the name is declared with a var.
	Var declaration that involve multiple comma delimited variable assignments are not accepted</description>
        <parameters>
          <parameter name="script" type="string" usage="required">
            <description>the script to execute</description>
          </parameter>
          <parameter name="safeLibraries" type="Array" usage="required">
            <description>The safe libraries that can be called (the functions can not be access/modified by the untrusted code, only called)</description>
          </parameter>
          <parameter name="safeGlobals" type="Object" usage="required">
            <description>These globals can be freely interacted with by the untrusted code</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="comments are replaced with a space, strings and regex are replaced with a single safe token (0)"/>
          <return-type type="replace literal keys with 0: and replace properties with the innocuous ~"/>
          <return-type type="check for illegal operator usages"/>
          <return-type type="the whitelist for [ operator for array initializer context or [+num] syntax"/>
          <return-type type="turn into a known safe call"/>
          <return-type type="return a block reference so the outer block can fetch it"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.secure.__Sandbox">
    <methods>
      <method name="loadJS" scope="prototype">
        <description>Loads the script from the given URL using XHR (assuming
	a plugin system is in place for cross-site requests) within the sandbox</description>
        <parameters>
          <parameter name="url" type="The" usage="required">
            <description>url of the script to load</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadHTML" scope="prototype">
        <description>Loads the web page from the provided URL using XHR (assuming the
	plugin system is in place) within the sandbox. All scripts within the web
	page will also be sandboxed.</description>
        <parameters>
          <parameter name="url" type="The" usage="required">
            <description>url of the web page to load</description>
          </parameter>
        </parameters>
      </method>
      <method name="evaluate" scope="prototype">
        <description>Evaluates the given script within the sandbox</description>
        <parameters>
          <parameter name="script" type="The" usage="required">
            <description>JavaScript text to evaluate</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Anchor">
    <methods>
      <method name="type" scope="instance"/>
      <method name="beginEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="doChange" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setUndo" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
      <property name="annotation" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_key" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="isControl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch">
    <methods>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeToolbar" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tools" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.AnnotationTool" superclass="ta._Plugin">
    <methods>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="rect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_create" scope="prototype">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_cshape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="p">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
      <property name="getType" scope="instance" type="Object"/>
      <property name="remove" scope="instance" type="Object"/>
      <property name="property" scope="instance" type="Object"/>
      <property name="onPropertyChange" scope="instance" type="Object"/>
      <property name="onCreate" scope="instance" type="Object"/>
      <property name="onDblClick" scope="instance" type="Object"/>
      <property name="initialize" scope="instance" type="Object"/>
      <property name="destroy" scope="instance" type="Object"/>
      <property name="draw" scope="instance" type="Object"/>
      <property name="apply" scope="instance" type="Object"/>
      <property name="serialize" scope="instance" type="Object"/>
      <property name="getBBox" scope="instance" type="Object"/>
      <property name="beginEdit" scope="instance" type="Object"/>
      <property name="endEdit" scope="instance" type="Object"/>
      <property name="calculate" scope="instance" type="Object"/>
      <property name="drawBBox" scope="instance" type="Object"/>
      <property name="setBinding" scope="instance" type="Object"/>
      <property name="doChange" scope="instance" type="Object"/>
      <property name="getTextBox" scope="instance" type="Object"/>
      <property name="setMode" scope="instance" type="Object"/>
      <property name="writeCommonAttrs" scope="instance" type="Object"/>
      <property name="readCommonAttrs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="mode" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
      <property name="hasAnchors" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.Modes">
    <properties>
      <property name="View" scope="instance" type="Object"/>
      <property name="Edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.labelFont">
    <properties>
      <property name="family" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="weight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textYOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="startRotation" scope="instance" type="Object"/>
      <property name="endRotation" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.prototype">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.DoubleArrowAnnotation">
    <methods>
      <method name="type" scope="prototype"/>
      <method name="getType" scope="prototype"/>
      <method name="_rot" scope="prototype"/>
      <method name="_pos" scope="prototype"/>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBBox" scope="prototype"/>
      <method name="serialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="startRotation" scope="instance" type="Object"/>
      <property name="endRotation" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.DoubleArrowAnnotation.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.DoubleArrowAnnotation.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.DoubleArrowAnnotation.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e.target.parentNode">
    <methods>
      <method name="initUndoStack" scope="instance"/>
      <method name="setTool" scope="instance">
        <parameters>
          <parameter name="t" type="dojox.sketch._Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClickShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="isLoading" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFit" scope="instance"/>
      <method name="unzoom" scope="instance"/>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="ann" type="Object" usage="required"/>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="_loadAnnotation" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUndo" scope="instance"/>
      <method name="onBeforeUndo" scope="instance"/>
      <method name="onRedo" scope="instance"/>
      <method name="onBeforeRedo" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="getValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure">
    <methods>
      <method name="nextKey" scope="instance"/>
      <method name="hasSelections" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSelections" scope="instance"/>
      <method name="replaceSelection" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_click" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_md" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mm" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delete" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="shapes" scope="instance" type="Object"/>
      <property name="image" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="zoomFactor" scope="instance" type="Object"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Object"/>
      <property name="_c" scope="instance" type="Object"/>
      <property name="_ctr" scope="instance" type="Object"/>
      <property name="_lp" scope="instance" type="Object"/>
      <property name="_action" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_ctool" scope="instance" type="Object"/>
      <property name="_start" scope="instance" type="Object"/>
      <property name="_end" scope="instance" type="Object"/>
      <property name="_absEnd" scope="instance" type="Object"/>
      <property name="_cshape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e.target.parentNode.zoom.image.rawNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="textYOffset" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.prototype">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.LeadAnnotation">
    <methods>
      <method name="type" scope="prototype"/>
      <method name="getType" scope="prototype"/>
      <method name="_pos" scope="prototype"/>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getBBox" scope="prototype"/>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.LeadAnnotation.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.LeadAnnotation.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.LeadAnnotation.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.prototype">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.PreexistingAnnotation">
    <methods>
      <method name="type" scope="prototype"/>
      <method name="getType" scope="prototype"/>
      <method name="_pos" scope="prototype"/>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getBBox" scope="prototype"/>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.PreexistingAnnotation.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.PreexistingAnnotation.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="textYOffset" scope="instance" type="Object"/>
      <property name="rotation" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.prototype">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.SingleArrowAnnotation">
    <methods>
      <method name="type" scope="prototype"/>
      <method name="getType" scope="prototype"/>
      <method name="_rot" scope="prototype"/>
      <method name="_pos" scope="prototype"/>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBBox" scope="prototype"/>
      <method name="serialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.SingleArrowAnnotation.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.SingleArrowAnnotation.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.SingleArrowAnnotation.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Slider" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="_zoomToFit" scope="prototype"/>
      <method name="_setZoom" scope="prototype">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.ButtonGroup">
    <methods>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="plugin" type="_Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="_resetGroup" scope="prototype">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_childMaps" scope="instance" type="Object"/>
      <property name="_children" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Toolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="addGroupItem" scope="prototype">
        <parameters>
          <parameter name="item" type="_Plugin" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="_setShape" scope="prototype">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="figure" scope="prototype" type="Object"/>
      <property name="plugins" scope="instance-prototype" type="Object"/>
      <property name="shapeGroup" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance" type="Object"/>
      <property name="_defaultTool" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.prototype">
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="ta.UnderlineAnnotation">
    <methods>
      <method name="type" scope="prototype"/>
      <method name="getType" scope="prototype"/>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getBBox" scope="prototype"/>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="prototype"/>
    </methods>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UndoStack">
    <methods>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="ann" type="ta.Annotation" usage="optional"/>
          <parameter name="before" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="undo" scope="prototype"/>
      <method name="redo" scope="prototype"/>
    </methods>
    <properties>
      <property name="_undoedSteps" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="_steps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.CommandTypes">
    <properties>
      <property name="Create" scope="instance" type="Object"/>
      <property name="Move" scope="instance" type="Object"/>
      <property name="Modify" scope="instance" type="Object"/>
      <property name="Delete" scope="instance" type="Object"/>
      <property name="Convert" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch._Plugin">
    <methods>
      <method name="_initButton" scope="prototype"/>
      <method name="attr" scope="prototype">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onActivate" scope="prototype"/>
      <method name="activate" scope="prototype">
        <parameters>
          <parameter name="e" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFigure" scope="prototype">
        <parameters>
          <parameter name="figure" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="toolbar" type="Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="figure" scope="instance-prototype" type="Object"/>
      <property name="iconClassPrefix" scope="prototype" type="Object"/>
      <property name="itemGroup" scope="prototype" type="Object"/>
      <property name="button" scope="instance-prototype" type="Object"/>
      <property name="queryCommand" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="prototype" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql">
    <methods>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="dbName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="dbName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_exec" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="encrypted results will arrive asynchronously"/>
          <return-type type="decrypted results will arrive asynchronously"/>
        </return-types>
      </method>
      <method name="_initDb" scope="instance"/>
      <method name="_printDebugSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeResults" scope="instance">
        <parameters>
          <parameter name="rs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsEncrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsDecrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="normal">
      <mixin type="orig_sql" scope="instance"/>
    </mixins>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="debug" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._SQLCrypto">
    <description>A private class encapsulating any cryptography that must be done
	on a SQL statement. We instantiate this class and have it hold
	it's state so that we can potentially have several encryption
	operations happening at the same time by different SQL statements.</description>
    <methods>
      <method name="_execEncryptSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execDecryptSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encrypt" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="encryptColumns" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decrypt" scope="prototype">
        <parameters>
          <parameter name="resultSet" type="Object" usage="required"/>
          <parameter name="needsDecrypt" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripCryptoSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_flagEncryptedArgs" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_determineDecryptedColumns" scope="prototype">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decryptSingleColumn" scope="prototype">
        <parameters>
          <parameter name="columnName" type="Object" usage="required"/>
          <parameter name="columnValue" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="currentRowIndex" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_totalCrypto" scope="instance" type="Object"/>
      <property name="_finishedCrypto" scope="instance" type="Object"/>
      <property name="_finishedSpawningCrypto" scope="instance" type="Object"/>
      <property name="_finalArgs" scope="instance" type="Object"/>
      <property name="_finalResultSet" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto">
    <methods>
      <method name="encrypt" scope="instance">
        <description>Use Corrected Block TEA to encrypt plaintext using password
	(note plaintext &amp;amp; password must be strings not string objects).
	Results will be returned to the 'callback' asychronously.</description>
        <parameters>
          <parameter name="plaintext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="instance">
        <description>Use Corrected Block TEA to decrypt ciphertext using password
	(note ciphertext &amp;amp; password must be strings not string objects).
	Results will be returned to the 'callback' asychronously.</description>
        <parameters>
          <parameter name="ciphertext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assignWork" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_workerHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="convert state to 1-d array before returning [&#xA7;3.4]"/>
          <return-type type="see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf"/>
          <return-type type="standard allows 128/192/256 bit keys"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_POOL_SIZE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool">
    <properties>
      <property name="_unemployed" scope="instance" type="Object"/>
      <property name="_employed" scope="instance" type="Object"/>
      <property name="_handleMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool._manager">
    <methods>
      <method name="onmessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.storage">
    <description>Objects for mass storage within the browser.  For when cookies just aren't enough.</description>
    <mixins scope="normal">
      <mixin type="this.currentProvider" scope="instance"/>
    </mixins>
    <properties>
      <property name="_common" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirDBStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="_sql" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginTransaction" scope="prototype"/>
      <method name="_commitTransaction" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
    <properties>
      <property name="DATABASE_FILE" scope="prototype" type="Object"/>
      <property name="TABLE_NAME" scope="prototype" type="Object"/>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="_db" scope="instance-prototype" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="air">
    <properties>
      <property name="File" scope="instance" type="Object"/>
      <property name="SQLConnection" scope="instance" type="Object"/>
      <property name="SQLStatement" scope="instance" type="Object"/>
      <property name="ByteArray" scope="instance" type="Object"/>
      <property name="EncryptedLocalStore" scope="instance" type="Object"/>
      <property name="FileStream" scope="instance" type="Object"/>
      <property name="FileMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirEncryptedLocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItem" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItem" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
    <properties>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirFileStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
    <properties>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="_storagePath" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.FlashStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="setFlushDelay" scope="prototype">
        <parameters>
          <parameter name="newDelay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlushDelay" scope="prototype"/>
      <method name="flush" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_destringify" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="getResourceList" scope="prototype"/>
      <method name="_loaded" scope="prototype"/>
      <method name="_onStatus" scope="prototype">
        <parameters>
          <parameter name="statusResult" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="_available" scope="instance-prototype" type="Object"/>
      <property name="_statusHandler" scope="instance-prototype" type="Object"/>
      <property name="_flashReady" scope="instance-prototype" type="Object"/>
      <property name="_pageReady" scope="instance-prototype" type="Object"/>
      <property name="_allNamespaces" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.GearsStorageProvider" superclass="dojox.storage.Provider">
    <description>Storage provider that uses the features of Google Gears
	to store data (it is saved into the local SQL database
	provided by Gears, using dojox.sql)</description>
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="_initStorage" scope="prototype"/>
    </methods>
    <properties>
      <property name="TABLE_NAME" scope="instance-prototype" type="Object"/>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="_available" scope="instance-prototype" type="Object"/>
      <property name="_storageReady" scope="instance-prototype" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.Provider">
    <description>A singleton for working with dojox.storage.</description>
    <methods>
      <method name="onHideSettingsUI" scope="prototype">
        <description>If a function is assigned to this property, then when the settings
	provider's UI is closed this function is called. Useful, for example,
	if the user has just cleared out all storage for this provider using
	the settings UI, and you want to update your UI.</description>
      </method>
      <method name="initialize" scope="prototype">
        <description>Allows this storage provider to initialize itself. This is
	called after the page has finished loading, so you can not do
	document.writes(). Storage Provider subclasses should initialize
	themselves inside of here rather than in their function
	constructor.</description>
      </method>
      <method name="isAvailable" scope="prototype">
        <description>Boolean
	Returns whether this storage provider is available on this
	platform.</description>
      </method>
      <method name="put" scope="prototype">
        <description>Puts a key and value into this storage system.</description>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to use when retrieving this value in the future.</description>
          </parameter>
          <parameter name="value" type="object" usage="required">
            <description>A value to store; this can be any JavaScript type.</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <description>Object
	Gets the value with the given key. Returns null if this key is
	not in the storage system.</description>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasKey" scope="prototype">
        <description>Determines whether the storage has the given key.</description>
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getKeys" scope="prototype">
        <description>Array
	Enumerates all of the available keys in this storage system.
	return: Array of available keys</description>
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <description>Completely clears this storage system of all of it's values and
	keys. If 'namespace' is provided just clears the keys in that
	namespace.</description>
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <description>Removes the given key from this storage system.</description>
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="isPermanent" scope="prototype">
        <description>Boolean
	Returns whether this storage provider's values are persisted
	when this platform is shutdown.</description>
      </method>
      <method name="getMaximumSize" scope="prototype">
        <description>mixed
	The maximum storage allowed by this provider</description>
        <return-description>Returns the maximum storage size
	supported by this provider, in
	thousands of bytes (i.e., if it
	returns 60 then this means that 60K
	of storage is supported).
	If this provider can not determine
	it's maximum size, then
	dojox.storage.SIZE_NOT_AVAILABLE is
	returned; if there is no theoretical
	limit on the amount of storage
	this provider can return, then
	dojox.storage.SIZE_NO_LIMIT is
	returned</return-description>
      </method>
      <method name="putMultiple" scope="prototype">
        <description>Puts multiple keys and values into this storage system.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to use when retrieving this value in the future,
	one per value to be stored</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to store; this can be any JavaScript type, though the
	performance of plain strings is considerably better</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <description>Object
	Gets the valuse corresponding to each of the given keys.
	Returns a null array element for each given key that is
	not in the storage system.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <description>Removes the given keys from this storage system.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidKeyArray" scope="prototype">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasSettingsUI" scope="prototype">
        <description>Boolean
	Determines whether this provider has a settings UI.</description>
      </method>
      <method name="showSettingsUI" scope="prototype">
        <description>If this provider has a settings UI, determined
	by calling hasSettingsUI(), it is shown.</description>
      </method>
      <method name="hideSettingsUI" scope="prototype">
        <description>If this provider has a settings UI, hides it.</description>
      </method>
      <method name="isValidKey" scope="prototype">
        <description>Boolean
	Subclasses can call this to ensure that the key given is valid
	in a consistent way across different storage providers. We use
	the lowest common denominator for key values allowed: only
	letters, numbers, and underscores are allowed. No spaces.</description>
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceList" scope="prototype">
        <description>Array[]
	Returns a list of URLs that this
	storage provider might depend on.</description>
      </method>
    </methods>
    <properties>
      <property name="SUCCESS" scope="prototype" type="String">
        <description>Flag that indicates a put() call to a
	storage provider was succesful.</description>
      </property>
      <property name="FAILED" scope="prototype" type="String">
        <description>Flag that indicates a put() call to
	a storage provider failed.</description>
      </property>
      <property name="PENDING" scope="prototype" type="String">
        <description>Flag that indicates a put() call to a
	storage provider is pending user approval.</description>
      </property>
      <property name="SIZE_NOT_AVAILABLE" scope="prototype" type="String">
        <description>Returned by getMaximumSize() if this storage provider can not determine
	the maximum amount of data it can support.</description>
      </property>
      <property name="SIZE_NO_LIMIT" scope="prototype" type="String">
        <description>Returned by getMaximumSize() if this storage provider has no theoretical
	limit on the amount of data it can store.</description>
      </property>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="String">
        <description>The namespace for all storage operations. This is useful if several
	applications want access to the storage system from the same domain but
	want different storage silos.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.storage.WhatWGStorageProvider" superclass="dojox.storage.Provider">
    <description>Storage provider that uses WHAT Working Group features in Firefox 2
	to achieve permanent storage.</description>
    <methods>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="getFullKey" scope="prototype">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDomain" scope="prototype"/>
    </methods>
    <properties>
      <property name="initialized" scope="instance-prototype" type="Object"/>
      <property name="_domain" scope="instance-prototype" type="Object"/>
      <property name="_available" scope="instance-prototype" type="Object"/>
      <property name="_statusHandler" scope="instance-prototype" type="Object"/>
      <property name="_allNamespaces" scope="prototype" type="Object"/>
      <property name="_storageEventListener" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.manager">
    <description>A singleton class in charge of the dojox.storage system</description>
    <methods>
      <method name="initialize" scope="instance">
        <description>Initializes the storage system and autodetects the best storage
	provider we can provide on this platform</description>
      </method>
      <method name="register" scope="instance">
        <description>Registers the existence of a new storage provider; used by
	subclasses to inform the manager of their existence. The
	storage manager will select storage providers based on
	their ordering, so the order in which you call this method
	matters.</description>
        <parameters>
          <parameter name="name" type="string" usage="required">
            <description>The full class name of this provider, such as
	&amp;quot;dojox.storage.FlashStorageProvider&amp;quot;.</description>
          </parameter>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance of this provider, which we will use to call
	isAvailable() on.
	keep list of providers as a list so that we can know what order
	storage providers are preferred; also, store the providers hashed
	by name in case someone wants to get a provider that uses
	a particular storage backend</description>
          </parameter>
        </parameters>
      </method>
      <method name="setProvider" scope="instance">
        <description>Instructs the storageManager to use the given storage class for
	all storage requests.</description>
        <parameters>
          <parameter name="storageClass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="autodetect" scope="instance">
        <description>Autodetects the best possible persistent storage provider
	available on this platform.
	console.debug(&amp;quot;dojox.storage.manager.autodetect&amp;quot;);</description>
      </method>
      <method name="isAvailable" scope="instance">
        <description>Boolean
	Returns whether any storage options are available.</description>
      </method>
      <method name="addOnLoad" scope="instance">
        <description>void
	Adds an onload listener to know when Dojo Offline can be used.</description>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A function to call when Dojo Offline is ready to go</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeOnLoad" scope="instance">
        <description>void
	Removes the given onLoad listener</description>
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isInitialized" scope="instance">
        <description>Boolean
	Returns whether the storage system is initialized and ready to
	be used.</description>
      </method>
      <method name="supportsProvider" scope="instance">
        <description>Boolean
	Determines if this platform supports the given storage provider.</description>
        <parameters>
          <parameter name="storageClass" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getProvider" scope="instance">
        <description>Object
	Gets the current provider</description>
      </method>
      <method name="loaded" scope="instance">
        <description>The storage provider should call this method when it is loaded
	and ready to be used. Clients who will use the provider will
	connect to this method to know when they can use the storage
	system. You can either use dojo.connect to connect to this
	function, or can use dojox.storage.manager.addOnLoad() to add
	a listener that does not depend on the dojo.event package.</description>
      </method>
      <method name="_fireLoaded" scope="instance"/>
      <method name="getResourceList" scope="instance">
        <description>Returns a list of whatever resources are necessary for storage
	providers to work.</description>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="Object"/>
      <property name="providers" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_onLoadListeners" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.manager.currentProvider">
    <description>The storage provider that was automagically chosen to do storage
	on this platform, such as dojox.storage.FlashStorageProvider.</description>
    <properties>
      <property name="declaredClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.BidiComplex">
    <methods>
      <method name="attachInput" scope="instance">
        <description>Attach key listeners to the INPUT field to accomodate dynamic complex BiDi expressions</description>
        <parameters>
          <parameter name="field" type="DOMNode" usage="required">
            <description>INPUT DOM node</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="createDisplayString" scope="instance">
        <description>Create the display string by adding the Unicode direction Markers</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required">
            <description>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="stripSpecialCharacters" scope="instance">
        <description>removes all Unicode directional markers from the string</description>
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_ceKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processCopy" scope="instance">
        <description>This function strips the unicode directional controls when the text copied to the Clipboard</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isReverse" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="FIXME: what's this?"/>
        </return-types>
      </method>
      <method name="_ceCopyText" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCutText" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRange" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="selectionStart" type="Object" usage="required"/>
          <parameter name="selectionEnd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isBidiChar" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isLatinChar" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isCharBeforeBiDiChar" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="previous" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_insertMarkers" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_segmentsPointers" scope="instance" type="Object"/>
      <property name="_ce_type" scope="instance" type="Object"/>
      <property name="_PATH" scope="instance" type="Object"/>
      <property name="_insertAlways" scope="instance" type="Object"/>
      <property name="_fOnCut" scope="instance" type="Object"/>
      <property name="_fOnCopy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string">
    <description>A collection of various objects for advanced string manipulation, including a Builder and a tokenizer.</description>
    <methods>
      <method name="tokenize" scope="instance">
        <description>Split a string by a regular expression with the ability to capture the delimeters</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="re" type="RegExp" usage="required"/>
          <parameter name="parseDelim" type="Function" usage="optional">
            <description>Each group (excluding the 0 group) is passed as a parameter. If the function returns
	a value, it's added to the list of tokens.</description>
          </parameter>
          <parameter name="instance" type="Object" usage="optional">
            <description>Used as the &amp;quot;this&amp;quot; instance when calling parseDelim</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.Builder">
    <description>A fast buffer for creating large strings.</description>
    <methods>
      <method name="append" scope="instance">
        <description>Append all arguments to the end of the buffer</description>
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <description>Alias for append.</description>
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="appendArray" scope="instance">
        <description>Append an array of items to the internal buffer.</description>
        <parameters>
          <parameter name="strings" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <description>Remove all characters from the buffer.</description>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <description>Replace instances of one string with another in the buffer.</description>
        <parameters>
          <parameter name="oldStr" type="String" usage="required"/>
          <parameter name="newStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <description>Remove len characters starting at index start.  If len
	is not provided, the end of the string is assumed.</description>
        <parameters>
          <parameter name="start" type="Number" usage="required"/>
          <parameter name="len" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <description>Insert string str starting at index.</description>
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <description>Return the string representation of the internal buffer.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="this.append" scope="instance"/>
    </mixins>
    <properties>
      <property name="length" scope="instance" type="Number">
        <description>The current length of the internal string.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.string.sprintf">
    <mixins scope="prototype">
      <mixin type="formatter.format" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.string.sprintf.Formatter">
    <methods>
      <method name="_parseDelim" scope="prototype">
        <parameters>
          <parameter name="mapping" type="Object" usage="required"/>
          <parameter name="intmapping" type="Object" usage="required"/>
          <parameter name="flags" type="Object" usage="required"/>
          <parameter name="minWidth" type="Object" usage="required"/>
          <parameter name="period" type="Object" usage="required"/>
          <parameter name="precision" type="Object" usage="required"/>
          <parameter name="specifier" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="filler" type="mixed" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="formatInt" scope="prototype">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatDouble" scope="prototype">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zeroPad" scope="prototype">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="fitField" scope="prototype">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spacePad" scope="prototype">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_mapped" scope="instance" type="Object"/>
      <property name="_format" scope="instance" type="Object"/>
      <property name="_tokens" scope="instance" type="Object"/>
      <property name="_re" scope="prototype" type="Object"/>
      <property name="_zeros10" scope="prototype" type="Object"/>
      <property name="_spaces10" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.b">
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers"/>
  <class type="dojox.string.sprintf.Formatter._specifiers.o">
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.x">
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.X">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.d">
    <properties>
      <property name="base" scope="instance" type="Object"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.i">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.u">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
      <property name="isUnsigned" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.c">
    <methods>
      <method name="setArg" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.s">
    <methods>
      <method name="setMaxWidth" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.e">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.E">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.f">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.F">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.g">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.G">
    <properties>
      <property name="extend" scope="instance" type="Object"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.testing"/>
  <class type="dojox.testing.DocTest">
    <description>This class executes doctests.</description>
    <methods>
      <method name="run" scope="prototype">
        <description>Run the doctests in the module given.</description>
        <example>doctest = new dojox.testing.DocTest();
	doctest.run("dojox.testing.DocTest");
	doctest.errors should finally be an empty array.
	// The above is not a doctest, because it just would
	//	execute itself in a never ending loop.
	&gt;&gt;&gt; true==true // Test a new line terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a new test terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a "not a comment"-line, especially an empty line terminating the test.
	true</example>
        <parameters>
          <parameter name="moduleName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="prototype">
        <description>Each element in the array contains the test in the first element,
	and the expected result in the second element.</description>
        <parameters>
          <parameter name="tests" type="Array" usage="required">
            <description>Make sure that the types are compared properly. There used to be
	the bug that a return value false was compared to &amp;quot;false&amp;quot; which
	made the test fail. This is fixed and should be verified by the
	following tests.
	&amp;gt;&amp;gt;&amp;gt; false
	false
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;false&amp;quot;
	&amp;quot;false&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; true
	true
	&amp;gt;&amp;gt;&amp;gt; 1
	1
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;s&amp;quot;
	&amp;quot;s&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; dojo.toJson({one:1})
	&amp;quot;{&amp;quot;one&amp;quot;:1}&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="runTest" scope="prototype">
        <parameters>
          <parameter name="commands" type="Object" usage="required"/>
          <parameter name="expected" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="errors" scope="instance-prototype" type="Object"/>
      <property name="getTests" scope="prototype" type="Object"/>
      <property name="getTestsFromString" scope="prototype" type="Object"/>
      <property name="_getTestsFromString" scope="prototype" type="Object"/>
      <property name="tests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing">
    <description>A set of objects to perform advanced time-based tasks, including a basic Timer.</description>
    <properties>
      <property name="ThreadPool" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Sequence">
    <description>This class provides functionality to really sequentialize
	function calls. You need to provide a list of functions and
	some parameters for each (like: pauseBefore) and they will
	be run one after another. This can be very useful for slideshows
	or alike things.</description>
    <methods>
      <method name="go" scope="prototype">
        <description>Run the passed sequence definition</description>
        <parameters>
          <parameter name="defs" type="Array" usage="required">
            <description>The sequence of actions</description>
          </parameter>
          <parameter name="doneFunction" type="Function|Array" usage="optional">
            <description>The function to call when done</description>
          </parameter>
        </parameters>
      </method>
      <method name="_go" scope="prototype">
        <description>Execute one task of this._defsResolved.</description>
      </method>
      <method name="goOn" scope="prototype">
        <description>This method just provides a hook from the outside, so that
	an interrupted sequence can be continued.</description>
      </method>
      <method name="stop" scope="prototype">
        <description>Stop the currently running sequence.</description>
      </method>
    </methods>
    <properties>
      <property name="_defsResolved" scope="instance-prototype" type="Object"/>
      <property name="_goOnPause" scope="instance-prototype" type="Object"/>
      <property name="_running" scope="instance-prototype" type="Object"/>
      <property name="_curId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Streamer">
    <methods>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="ms" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onTick" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.timing.Streamer" usage="required"/>
        </parameters>
      </method>
      <method name="start" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="onStop" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="the">
        <description>interval in ms at which the output function is fired.</description>
      </property>
      <property name="minimumSize" scope="instance" type="Object"/>
      <property name="inputFunction" scope="instance" type="Object"/>
      <property name="outputFunction" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Thread">
    <methods>
      <method name="invoke" scope="instance"/>
    </methods>
    <properties>
      <property name="state" scope="instance" type="Object"/>
      <property name="priority" scope="instance" type="Object"/>
      <property name="lastError" scope="instance" type="Object"/>
      <property name="func" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.threadStates">
    <properties>
      <property name="UNSTARTED" scope="instance" type="Object"/>
      <property name="STOPPED" scope="instance" type="Object"/>
      <property name="PENDING" scope="instance" type="Object"/>
      <property name="RUNNING" scope="instance" type="Object"/>
      <property name="SUSPENDED" scope="instance" type="Object"/>
      <property name="WAITING" scope="instance" type="Object"/>
      <property name="COMPLETE" scope="instance" type="Object"/>
      <property name="ERROR" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.threadPriorities">
    <properties>
      <property name="LOWEST" scope="instance" type="Object"/>
      <property name="BELOWNORMAL" scope="instance" type="Object"/>
      <property name="NORMAL" scope="instance" type="Object"/>
      <property name="ABOVENORMAL" scope="instance" type="Object"/>
      <property name="HIGHEST" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer">
    <description>Timer object executes an &amp;quot;onTick()&amp;quot; method repeatedly at a specified interval.
	repeatedly at a given interval.</description>
    <methods>
      <method name="onTick" scope="prototype">
        <description>Method called every time the interval passes.  Override to do something useful.</description>
      </method>
      <method name="setInterval" scope="prototype">
        <description>Reset the interval of a timer, whether running or not.</description>
        <parameters>
          <parameter name="interval" type="New" usage="required">
            <description>interval, in milliseconds.</description>
          </parameter>
        </parameters>
      </method>
      <method name="start" scope="prototype">
        <description>Start the timer ticking.</description>
      </method>
      <method name="stop" scope="prototype">
        <description>Stop the timer.</description>
      </method>
    </methods>
    <properties>
      <property name="timer" scope="instance" type="Object"/>
      <property name="isRunning" scope="instance" type="Object"/>
      <property name="interval" scope="instance" type="Interval">
        <description>between function calls, in milliseconds.</description>
      </property>
      <property name="onStart" scope="instance" type="Object"/>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid">
    <description>Universally Unique Identifier (UUID) implementations, including an implementation of UUID 2</description>
    <methods>
      <method name="assert" scope="instance">
        <description>Throws an exception if the assertion fails.</description>
        <parameters>
          <parameter name="booleanValue" type="Boolean" usage="required">
            <description>Must be true for the assertion to succeed.</description>
          </parameter>
          <parameter name="message" type="String" usage="optional">
            <description>A string describing the assertion.
	throws: Throws an Error if 'booleanValue' is false.</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateNilUuid" scope="instance">
        <description>This function returns the Nil UUID: &amp;quot;00000000-0000-0000-0000-000000000000&amp;quot;.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance">
        <description>Returns true if the UUID was initialized with a valid value.</description>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVariant" scope="instance">
        <description>Returns a variant code that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.variant values.</description>
        <example>var variant = dojox.uuid.getVariant("3b12f1df-5232-4804-897e-917bf397618a");
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.variant"/>
        </return-types>
      </method>
      <method name="getVersion" scope="instance">
        <description>Returns a version number that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.version values.</description>
        <example>var version = dojox.uuid.getVersion("b4308fb0-86cd-11da-a72b-0800200c9a66");
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <description>If this is a version 1 UUID (a time-based UUID), getNode() returns a
	12-character string with the &amp;quot;node&amp;quot; or &amp;quot;pseudonode&amp;quot; portion of the UUID,
	which is the rightmost 12 characters.</description>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String (a 12-character string, which will look something like &quot;917bf397618a&quot;)"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="instance">
        <description>If this is a version 1 UUID (a time-based UUID), this method returns
	the timestamp value encoded in the UUID.  The caller can ask for the
	timestamp to be returned either as a JavaScript Date object or as a
	15-character string of hex digits.</description>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
          <parameter name="returnType" type="String" usage="optional">
            <description>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</description>
          </parameter>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	var date, string, hexString;
	date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String (e.g. &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;)"/>
          <return-type type="String (e.g. &quot;1da86cdb4308fb0&quot;)"/>
          <return-type type="no returnType was specified, so default to Date"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="generateRandomUuid" scope="instance">
        <description>This function generates random UUIDs, meaning &amp;quot;version 4&amp;quot; UUIDs.</description>
        <return-types>
          <return-type type="for example: &quot;3B12F1DF&quot;"/>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="NIL_UUID" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid">
    <description>This is the constructor for the Uuid class.  The Uuid class offers
	methods for inspecting existing UUIDs.</description>
    <methods>
      <method name="compare" scope="prototype">
        <description>Compares this UUID to another UUID, and returns 0, 1, or -1.</description>
        <parameters>
          <parameter name="uuidOne" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="uuidTwo" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="integer (either 0, 1, or -1)"/>
        </return-types>
      </method>
      <method name="setGenerator" scope="instance">
        <description>Sets the default generator, which will be used by the
	&amp;quot;new dojox.uuid.Uuid()&amp;quot; constructor if no parameters
	are passed in.</description>
        <parameters>
          <parameter name="generator" type="Function" usage="optional">
            <description>A UUID generator function, such as dojox.uuid.generateTimeBasedUuid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getGenerator" scope="instance">
        <description>Returns the default generator.  See setGenerator().</description>
        <return-types>
          <return-type type="generator (A UUID generator, such as dojox.uuid.TimeBasedGenerator)."/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <description>This method returns a standard 36-character string representing
	the UUID, such as &amp;quot;3b12f1df-5232-4804-897e-917bf397618a&amp;quot;.</description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="isEqual" scope="prototype">
        <description>Returns true if this UUID is equal to the otherUuid, or false otherwise.</description>
        <parameters>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isValid" scope="prototype">
        <description>Returns true if the UUID was initialized with a valid value.</description>
      </method>
      <method name="getVariant" scope="prototype">
        <description>Returns a variant code that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.variant values.</description>
      </method>
      <method name="getVersion" scope="prototype">
        <description>Returns a version number that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.version values.</description>
        <example>var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var version = uuid.getVersion();
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getNode" scope="prototype">
        <description>If this is a version 1 UUID (a time-based UUID), getNode() returns a
	12-character string with the &amp;quot;node&amp;quot; or &amp;quot;pseudonode&amp;quot; portion of the UUID,
	which is the rightmost 12 characters.</description>
        <return-types>
          <return-type type="String (a 12-character string, which will look something like &quot;917bf397618a&quot;)"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="prototype">
        <description>If this is a version 1 UUID (a time-based UUID), this method returns
	the timestamp value encoded in the UUID.  The caller can ask for the
	timestamp to be returned either as a JavaScript Date object or as a
	15-character string of hex digits.</description>
        <parameters>
          <parameter name="returnType" type="String" usage="optional">
            <description>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</description>
          </parameter>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var date, string, hexString;
	date   = uuid.getTimestamp();         // returns a JavaScript Date
	date   = uuid.getTimestamp(Date);     //
	string = uuid.getTimestamp(String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = uuid.getTimestamp("hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String (e.g. &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;)"/>
          <return-type type="String (e.g. &quot;1da86cdb4308fb0&quot;)"/>
          <return-type type="no returnType was specified, so default to Date"/>
          <return-type type="Date"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_uuidString" scope="instance" type="Object"/>
      <property name="_versionNumber" scope="instance" type="Object"/>
      <property name="_nodeString" scope="instance" type="Object"/>
      <property name="_timestampAsHexString" scope="instance" type="Object"/>
      <property name="_timestampAsDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.version">
    <properties>
      <property name="UNKNOWN" scope="instance" type="Object"/>
      <property name="TIME_BASED" scope="instance" type="Object"/>
      <property name="DCE_SECURITY" scope="instance" type="Object"/>
      <property name="NAME_BASED_MD5" scope="instance" type="Object"/>
      <property name="RANDOM" scope="instance" type="Object"/>
      <property name="NAME_BASED_SHA1" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.variant">
    <properties>
      <property name="NCS" scope="instance" type="Object"/>
      <property name="DCE" scope="instance" type="Object"/>
      <property name="MICROSOFT" scope="instance" type="Object"/>
      <property name="UNKNOWN" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid">
    <description>This function generates time-based UUIDs, meaning &amp;quot;version 1&amp;quot; UUIDs.</description>
    <methods>
      <method name="isValidNode" scope="instance">
        <parameters>
          <parameter name="node" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setNode" scope="instance">
        <description>Sets the 'node' value that will be included in generated UUIDs.</description>
        <parameters>
          <parameter name="node" type="String" usage="optional">
            <description>A 12-character hex string representing a pseudoNode or hardwareNode.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getNode" scope="instance">
        <description>Returns the 'node' value that will be included in generated UUIDs.</description>
        <return-types>
          <return-type type="String (a 12-character hex string representing a pseudoNode or hardwareNode)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid._generator">
    <methods>
      <method name="generateUuidString" scope="instance">
        <description>Generates a time-based UUID, meaning a version 1 UUID.</description>
        <parameters>
          <parameter name="node" type="String" usage="optional">
            <description>An optional 12-character string to use as the node in the new UUID.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String (a 36 character string, which will look something like &quot;b4308fb0-86cd-11da-a72b-0800200c9a66&quot;)"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="GREGORIAN_CHANGE_OFFSET_IN_HOURS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.ca">
    <description>Methods specific to the Canadian provinces</description>
    <methods>
      <method name="isPhoneNumber" scope="instance">
        <description>Validates 10 Canadian digit phone number for several common formats</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
        <return-types>
          <return-type type="same as US"/>
        </return-types>
      </method>
      <method name="isProvince" scope="instance">
        <description>Validates Canadian province abbreviations (2 chars)</description>
        <parameters>
          <parameter name="value" type="String[2]" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="isSocialInsuranceNumber" scope="instance">
        <description>Validates Canadian 9 digit social insurance number for several common formats
	This routine only pattern matches and does not use the Luhn Algorithm to validate number.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="isPostalCode" scope="instance">
        <description>Validates Canadian 6 digit postal code:
	Canadian postal codes are in the format ANA NAN,
	where A is a letter and N is a digit, with a space
	separating the third and fourth characters.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.regexp">
    <description>Additional pre-made regular expressions for use</description>
    <methods>
      <method name="tld" scope="instance">
        <description>Builds a RE that matches a top-level domain</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>flags.allowCC  Include 2 letter country code domains.  Default is true.
	flags.allowGeneric  Include the generic domains.  Default is true.
	flags.allowInfra  Include infrastructure domains.  Default is true.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="ipAddress" scope="instance">
        <description>Builds a RE that matches an IP Address</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="host" scope="instance">
        <description>Builds a RE that matches a host</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object.
	flags.allowNamed Allow a named host for local networks. Default is false.
	flags.allowIP  Allow an IP address for hostname.  Default is true.
	flags.allowLocal  Allow the host to be &amp;quot;localhost&amp;quot;.  Default is false.
	flags.allowPort  Allow a port number to be present.  Default is true.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="url" scope="instance">
        <description>Builds a regular expression that matches a URL</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or match either one.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="&quot;; } return &quot;&quot;; }"/>
        </return-types>
      </method>
      <method name="emailAddress" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="numberFormat" scope="instance">
        <description>Builds a regular expression to match any sort of number based format</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="emailAddressList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.regexp.us">
    <methods>
      <method name="state" scope="instance">
        <description>A regular expression to match US state and territory abbreviations
	flags  An object.
	flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
	flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.regexp.ca">
    <methods>
      <method name="postalCode" scope="instance"/>
      <method name="province" scope="instance">
        <description>a regular expression to match Canadian Province Abbreviations</description>
      </method>
    </methods>
  </class>
  <class type="dojox.validate.us">
    <methods>
      <method name="isState" scope="instance">
        <description>Validates US state and territory abbreviations.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A two character string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
	flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPhoneNumber" scope="instance">
        <description>Validates 10 US digit phone number for several common formats</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The telephone number string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialSecurityNumber" scope="instance">
        <description>Validates social security number</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isZipCode" scope="instance">
        <description>Validates U.S. zip-code</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.widget">
    <description>A collection of un-categorized widgets, or code not requiring it's own package.</description>
    <properties>
      <property name="CalendarFx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase" superclass="dijit._Widget">
    <description>constructor for the widget</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Instantiates the mixin views</description>
      </method>
      <method name="addFx" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <description>set the current date and update the UI.  If the date is disabled, the selection will
	not change, but the display will change to the corresponding month.</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="prototype">
        <description>May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onValueSelected" scope="prototype">
        <description>a date cell was selected.  It may be the same as the previous value.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_onDateSelected" scope="prototype">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <description>called only when the selected date has changed</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="prototype">
        <description>Transitions to the next view.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToToday" scope="prototype"/>
      <method name="_transitionVert" scope="prototype">
        <description>Animates the views to show one and hide another, in a
	vertical direction.
	If 'direction' is 1, then the views slide upwards.
	If 'direction' is -1, the views slide downwards.</description>
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_slideTable" scope="prototype">
        <description>Animates the horizontal sliding of a table.</description>
        <parameters>
          <parameter name="widget" type="String" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_addView" scope="prototype">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getClassForDate" scope="prototype">
        <description>May be overridden to return CSS classes to associate with the date entry for the given dateObject,
	for example to indicate a holiday in specified locale.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_adjustDisplay" scope="prototype">
        <description>This function overrides the base function defined in dijit._Calendar.
	It changes the displayed years, months and days depending on the inputs.</description>
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
          <parameter name="noSlide" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_views" scope="instance-prototype" type="Array">
        <description>The list of mixin views available on this calendar.</description>
      </property>
      <property name="useFx" scope="prototype" type="Boolean">
        <description>Specifies if visual effects should be applied to the widget.
	The default behavior of the widget does not contain any effects.
	The dojox.widget.CalendarFx package is needed for these.</description>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Boolean">
        <description>This widget is a container of other widgets, so this is true.</description>
      </property>
      <property name="value" scope="instance-prototype" type="Date">
        <description>the currently selected Date</description>
      </property>
      <property name="_height" scope="instance" type="Object"/>
      <property name="displayMonth" scope="instance" type="Object"/>
      <property name="_children" scope="instance" type="Object"/>
      <property name="_currentChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.footer">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarView" superclass="dijit._Widget">
    <description>Base implementation for all view mixins.
	All calendar views should extend this widget.</description>
    <methods>
      <method name="cloneClass" scope="prototype">
        <description>Clones all nodes with the class 'clazz' in a widget</description>
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="prototype">
        <description>sets the text inside a node</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="prototype">
        <description>returns the header node of a view. If none exists,
	an empty DIV is created and returned.</description>
      </method>
      <method name="onValueSelected" scope="prototype">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="prototype">
        <description>Adds or subtracts values from a date.
	The unit, e.g. &amp;quot;day&amp;quot;, &amp;quot;month&amp;quot; or &amp;quot;year&amp;quot;, is
	specified in the &amp;quot;datePart&amp;quot; property of the
	calendar view mixin.</description>
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="headerClass" scope="prototype" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDay">
    <description>Mixin for the dojox.widget.Calendar which provides
	the standard day-view. A single month is shown at a time.</description>
    <properties>
      <property name="parent" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDayView" superclass="dojox.widget._CalendarView">
    <description>View class for the dojox.widget.Calendar.
	Adds a view showing every day of a single month to the calendar.
	This should not be mixed in directly with dojox.widget._CalendarBase.
	Instead, use dojox.widget._CalendarDay</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Constructs the calendar view.</description>
      </method>
      <method name="_onDayClick" scope="prototype">
        <description>executed when a day value is clicked.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateDays" scope="prototype">
        <description>Fills the days of the current month.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="datePart" scope="prototype" type="String">
        <description>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</description>
      </property>
      <property name="dayWidth" scope="prototype" type="String">
        <description>Specifies the type of day name to display.  &amp;quot;narrow&amp;quot; causes just one letter to be shown.</description>
      </property>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonth">
    <description>Adds a dojox.widget._CalendarMonthView view to the calendar widget.</description>
    <properties>
      <property name="headerClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthView" superclass="dojox.widget._CalendarView">
    <description>A Calendar view listing the 12 months of the year</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Constructs the view</description>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMonthNames" scope="prototype">
        <description>Returns localized month names</description>
        <parameters>
          <parameter name="format" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateMonths" scope="prototype">
        <description>Populate the month names using the localized values.</description>
      </method>
      <method name="onClick" scope="prototype">
        <description>Handles clicks on month names</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="datePart" scope="prototype" type="String">
        <description>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</description>
      </property>
      <property name="_monthNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthView.header">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYear">
    <description>Adds a dojox.widget._CalendarYearView view to the
	dojo.widget._CalendarBase widget.</description>
    <properties>
      <property name="parent" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYearView" superclass="dojox.widget._CalendarView">
    <description>A Calendar view listing 12 years</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Constructs the view</description>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateYears" scope="prototype">
        <description>Writes the years to display to the view</description>
        <parameters>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="prototype">
        <description>Adjusts the value of a date. It moves it by 12 years each time.</description>
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>Handles clicks on year values.</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_displayedYear" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Calendar" superclass="dojox.widget._CalendarBase">
    <description>The standard Calendar. It includes day, month and year views.
	No visual effects are included.</description>
    <mixins scope="prototype">
      <mixin type="dojox.widget._CalendarDay" scope="prototype"/>
      <mixin type="dojox.widget._CalendarMonth" scope="prototype"/>
      <mixin type="dojox.widget._CalendarYear" scope="prototype"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DailyCalendar" superclass="dojox.widget._CalendarBase">
    <description>A calendar with only a daily view.</description>
    <mixins scope="prototype">
      <mixin type="dojox.widget._CalendarDay" scope="prototype"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthlyCalendar" superclass="dojox.widget._CalendarBase">
    <description>A calendar with only a month view.</description>
    <mixins scope="prototype">
      <mixin type="dojox.widget._CalendarMonth" scope="prototype"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.YearlyCalendar" superclass="dojox.widget._CalendarBase">
    <description>A calendar with only a year view.</description>
    <mixins scope="prototype">
      <mixin type="dojox.widget._CalendarYear" scope="prototype"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._FisheyeFX">
    <methods>
      <method name="addFx" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.CalendarFisheye" superclass="dojox.widget.Calendar">
    <description>The standard Calendar. It includes day, month and year views.
	FisheyeLite effects are included.</description>
    <mixins scope="prototype">
      <mixin type="dojox.widget._FisheyeFX" scope="prototype"/>
      <mixin type="dojox.widget._FisheyeFX" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.ColorPicker" superclass="dijit.form._FormWidget">
    <description>a HSV color picker - similar to Photoshop picker</description>
    <example>
		var picker = new dojox.widget.ColorPicker({
			// a couple of example toggles:
			animatePoint:false,
			showHsv: false,
			webSafe: false,
			showRgb: false
		});</example>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>As quickly as we can, set up ie6 alpha-filter support for our
	underlay.  we don't do image handles (done in css), just the 'core'
	of this widget: the underlay.</description>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_setTimer" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_clearTimer" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_setHue" scope="prototype">
        <description>sets a natural color background for the
	underlay image against closest hue value (full saturation)</description>
        <parameters>
          <parameter name="h" type="Decimal" usage="required">
            <description>0..255 </description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateColor" scope="prototype">
        <description>update the previewNode color, and input values [optional]
	all these should be in the [0..150] range</description>
      </method>
      <method name="_updatePoints" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setHuePoint" scope="prototype">
        <description>set the hue picker handle on relative y coordinates</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="prototype">
        <description>set our picker point based on relative x/y coordinates
	evt.preventDefault();</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="showRgb" scope="prototype" type="Boolean">
        <description>show/update RGB input nodes</description>
      </property>
      <property name="showHsv" scope="prototype" type="Boolean">
        <description>show/update HSV input nodes</description>
      </property>
      <property name="showHex" scope="prototype" type="Boolean">
        <description>show/update Hex value field</description>
      </property>
      <property name="webSafe" scope="prototype" type="Boolean">
        <description>deprecated? or just use a toggle to show/hide that node, too?</description>
      </property>
      <property name="animatePoint" scope="prototype" type="Boolean">
        <description>toggle to use slideTo (true) or just place the cursor (false) on click</description>
      </property>
      <property name="slideDuration" scope="prototype" type="Integer">
        <description>time in ms picker node will slide to next location (non-dragging) when animatePoint=true</description>
      </property>
      <property name="liveUpdate" scope="prototype" type="Boolean">
        <description>Set to true to fire onChange in an indeterminate way</description>
      </property>
      <property name="_underlay" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_offset" scope="instance" type="Object"/>
      <property name="_shift" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
      <property name="_hueMover" scope="instance" type="Object"/>
      <property name="_sc" scope="instance" type="Object"/>
      <property name="_hueSc" scope="instance" type="Object"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay.style">
    <properties>
      <property name="filter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.rgbNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hsvNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.safePreviewNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.previewNode.style">
    <properties>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexCode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Rval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Gval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Bval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Hval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Sval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Vval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog" superclass="dijit.Dialog">
    <description>A Lightbox-like Modal-dialog for HTML Content</description>
    <methods>
      <method name="_setup" scope="prototype">
        <description>Piggyback on dijit.Dialog's _setup for load-time options, deferred to</description>
      </method>
      <method name="layout" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSize" scope="prototype">
        <description>cache and set our desired end position</description>
      </method>
      <method name="show" scope="prototype"/>
      <method name="_handleNav" scope="prototype">
        <description>Handle's showing or hiding the close icon</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="prototype"/>
      <method name="_showContent" scope="prototype">
        <description>Show the inner container after sizing animation</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="fixedSize" scope="prototype" type="Boolean">
        <description>If false, fix the size of the dialog to the Viewport based on
	viewportPadding value rather than the calculated or natural
	stlye. If true, base the size on a passed dimension attribute.
	Eitherway, the viewportPadding value is used if the the content
	extends beyond the viewport size for whatever reason.</description>
      </property>
      <property name="viewportPadding" scope="prototype" type="Integer">
        <description>If fixedSize=&amp;quot;true&amp;quot;, this is the value  or used when fixed=&amp;quot;false&amp;quot; and dimensions exceed) to use</description>
      </property>
      <property name="dimensions" scope="instance-prototype" type="Array">
        <description>A two-element array of [widht,height] to animate the Dialog to. Defaults to [300,300]</description>
      </property>
      <property name="easing" scope="instance-prototype" type="Function?|String?">
        <description>An easing function to apply to the sizing animation.</description>
      </property>
      <property name="sizeDuration" scope="prototype" type="Integer">
        <description>Time (in ms) to use in the Animation for sizing.</description>
      </property>
      <property name="sizeMethod" scope="prototype" type="String">
        <description>To be passed to dojox.fx.sizeTo, one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; to effect
	the animation sequence.</description>
      </property>
      <property name="showTitle" scope="prototype" type="Boolean">
        <description>Toogle to show or hide the Title area. Can only be set at startup.</description>
      </property>
      <property name="draggable" scope="prototype" type="Boolean">
        <description>Make the pane draggable. Differs from dijit.Dialog by setting default to false</description>
      </property>
      <property name="_navIn" scope="instance" type="Object"/>
      <property name="_navOut" scope="instance" type="Object"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="_displaysize" scope="instance" type="Object"/>
      <property name="_sizing" scope="instance" type="Object"/>
      <property name="_sizingConnect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester" superclass="dijit._Widget">
    <description>A widget to run DocTests inside an HTML page.</description>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="_fillContent" scope="prototype" type="Object"/>
      <property name="postCreate" scope="prototype" type="Object"/>
      <property name="runTests" scope="prototype" type="Object"/>
      <property name="reset" scope="prototype" type="Object"/>
      <property name="_unescapeHtml" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane" superclass="dojox.widget._RollingListPane">
    <description>a pane to display the information for the currently-selected
	file</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="onItems" scope="prototype">
        <description>called after a fetch or load - at this point, this.items should be
	set and loaded.</description>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="string">
        <description>delete our template string</description>
      </property>
      <property name="templatePath" scope="prototype" type="string">
        <description>Our template path</description>
      </property>
      <property name="_messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.nameNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.pathNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.sizeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FilePicker" superclass="dojox.widget.RollingList">
    <description>a specialized version of RollingList that handles file information
	in a store</description>
    <methods>
      <method name="_itemsMatch" scope="prototype">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="getChildItems" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPathValueAttr" scope="prototype">
        <parameters>
          <parameter name="path" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_getPathValueAttr" scope="prototype">
        <description>returns the path value of the given value (or current value
	if not passed a value)</description>
        <parameters>
          <parameter name="val" type="item" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="className" scope="prototype" type="Object"/>
      <property name="pathSeparator" scope="instance-prototype" type="string">
        <description>Our file separator - it will be guessed if not set</description>
      </property>
      <property name="topDir" scope="instance-prototype" type="string">
        <description>The top directory string - it will be guessed if not set</description>
      </property>
      <property name="parentAttr" scope="prototype" type="string">
        <description>the attribute to read for finding our parent directory</description>
      </property>
      <property name="pathAttr" scope="prototype" type="string">
        <description>the attribute to read for getting the full path of our file</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList" superclass="dijit._Widget">
    <description>Menu similar to the fish eye menu on the Mac OS</description>
    <example>
		&lt;div dojoType="FisheyeList"
			itemWidth="40" itemHeight="40"
			itemMaxWidth="150" itemMaxHeight="150"
			orientation="horizontal"
			effectUnits="2"
			itemPadding="10"
			attachEdge="center"
			labelEdge="bottom"&gt;
			&lt;div dojoType="FisheyeListItem"
				id="item1"
				onclick="alert('click on' + this.label + '(from widget id ' + this.widgetId + ')!');"
				label="Item 1"
				iconSrc="images/fisheye_1.png"&gt;
			&lt;/div&gt;
			...
		&lt;/div&gt;</example>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype">
        <description>create our connections and setup our FisheyeList</description>
      </method>
      <method name="_initializePositioning" scope="prototype"/>
      <method name="_overElement" scope="prototype">
        <description>Returns whether the mouse is over the passed element.
	Node: Must must be display:block (ie, not a &amp;lt;span&amp;gt;)</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBodyOut" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setDormant" scope="prototype">
        <description>called when mouse moves out of menu's range</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already dormant?"/>
        </return-types>
      </method>
      <method name="_setActive" scope="prototype">
        <description>called when mouse is moved into menu's range</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already activated?"/>
        </return-types>
      </method>
      <method name="_onMouseMove" scope="prototype">
        <description>called when mouse is moved</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onScroll" scope="prototype"/>
      <method name="onResized" scope="prototype"/>
      <method name="_onGridMouseMove" scope="prototype">
        <description>called when mouse is moved in the vicinity of the menu</description>
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_paint" scope="prototype"/>
      <method name="_weighAt" scope="prototype">
        <parameters>
          <parameter name="cen" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_setItemSize" scope="prototype">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionElementsFrom" scope="prototype">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionLabel" scope="prototype">
        <parameters>
          <parameter name="itm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcHitGrid" scope="prototype"/>
      <method name="_toEdge" scope="prototype">
        <parameters>
          <parameter name="inp" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_expandSlowly" scope="prototype">
        <description>slowly expand the image to user specified max size</description>
      </method>
      <method name="destroyRecursive" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="snarfChildDomOutput" scope="prototype" type="Object"/>
      <property name="itemWidth" scope="prototype" type="Integer">
        <description>width of menu item (in pixels) in it's dormant state (when the mouse is far away)</description>
      </property>
      <property name="itemHeight" scope="prototype" type="Integer">
        <description>height of menu item (in pixels) in it's dormant state (when the mouse is far away)</description>
      </property>
      <property name="itemMaxWidth" scope="prototype" type="Integer">
        <description>width of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</description>
      </property>
      <property name="itemMaxHeight" scope="prototype" type="Integer">
        <description>height of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</description>
      </property>
      <property name="imgNode" scope="prototype" type="Object"/>
      <property name="orientation" scope="prototype" type="String">
        <description>orientation of the menu, either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot;</description>
      </property>
      <property name="isFixed" scope="prototype" type="Boolean">
        <description>toggle to enable additional listener (window scroll) if FisheyeList is in a fixed postion</description>
      </property>
      <property name="conservativeTrigger" scope="prototype" type="Boolean">
        <description>if true, don't start enlarging menu items until mouse is over an image;
	if false, start enlarging menu items as the mouse moves near them.</description>
      </property>
      <property name="effectUnits" scope="prototype" type="Number">
        <description>controls how much reaction the menu makes, relative to the distance of the mouse from the menu</description>
      </property>
      <property name="itemPadding" scope="prototype" type="Integer">
        <description>padding (in pixels) betweeen each menu item</description>
      </property>
      <property name="attachEdge" scope="prototype" type="String">
        <description>controls the border that the menu items don't expand past;
	for example, if set to &amp;quot;top&amp;quot;, then the menu items will drop downwards as they expand.
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</description>
      </property>
      <property name="labelEdge" scope="instance-prototype" type="String">
        <description>controls were the labels show up in relation to the menu item icons
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</description>
      </property>
      <property name="isHorizontal" scope="instance" type="Object"/>
      <property name="selectedNode" scope="instance" type="Object"/>
      <property name="isOver" scope="instance" type="Object"/>
      <property name="hitX1" scope="instance" type="Object"/>
      <property name="hitY1" scope="instance" type="Object"/>
      <property name="hitX2" scope="instance" type="Object"/>
      <property name="hitY2" scope="instance" type="Object"/>
      <property name="anchorEdge" scope="instance" type="Object"/>
      <property name="proximityLeft" scope="instance" type="Object"/>
      <property name="proximityRight" scope="instance" type="Object"/>
      <property name="proximityTop" scope="instance" type="Object"/>
      <property name="proximityBottom" scope="instance" type="Object"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="_onMouseMoveHandle" scope="instance" type="Object"/>
      <property name="_onScrollHandle" scope="instance" type="Object"/>
      <property name="_onMouseOutHandle" scope="instance" type="Object"/>
      <property name="_addChildHandle" scope="instance" type="Object"/>
      <property name="_onResizeHandle" scope="instance" type="Object"/>
      <property name="itemCount" scope="instance" type="Object"/>
      <property name="barWidth" scope="instance" type="Object"/>
      <property name="barHeight" scope="instance" type="Object"/>
      <property name="totalWidth" scope="instance" type="Object"/>
      <property name="totalHeight" scope="instance" type="Object"/>
      <property name="timerScale" scope="instance" type="Object"/>
      <property name="pos" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.EDGE">
    <properties>
      <property name="CENTER" scope="instance" type="Object"/>
      <property name="LEFT" scope="instance" type="Object"/>
      <property name="RIGHT" scope="instance" type="Object"/>
      <property name="TOP" scope="instance" type="Object"/>
      <property name="BOTTOM" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.domNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem" superclass="dijit._Widget">
    <methods>
      <method name="_isNode" scope="prototype">
        <description>checks to see if wh is actually a node.</description>
        <parameters>
          <parameter name="wh" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_hasParent" scope="prototype">
        <description>returns whether or not node is a child of another node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="onMouseOver" scope="prototype">
        <description>callback when user moves mouse over this menu item
	in conservative mode, don't activate the menu until user mouses over an icon</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <description>callback when user moves mouse off of this menu item</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <description>user overridable callback when user clicks this menu item</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconSrc" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type="String">
        <description>label to print next to the icon, when it is moused-over</description>
      </property>
      <property name="id" scope="prototype" type="String">
        <description>will be set to the id of the orginal div element</description>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode.style">
    <properties>
      <property name="filter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeLite" superclass="dijit._Widget">
    <description>A Light-weight Fisheye Component, or an exhanced version
	of dojo.fx.Toggler ...</description>
    <example>
		// make all the LI's in a node Fisheye's:
		 dojo.query("#node li").forEach(function(n){
			new dojox.widget.FisheyeLite({},n);
		});
	duationIn: Integer
	The time (in ms) the run the show animation</example>
    <methods>
      <method name="easeIn" scope="prototype">
        <description>An easing function to use for the show animation</description>
      </method>
      <method name="easeOut" scope="prototype">
        <description>An easing function to use for the hide animation</description>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="show" scope="prototype">
        <description>Show this Fisheye item.</description>
      </method>
      <method name="hide" scope="prototype">
        <description>Hide this fisheye item on mouse leave</description>
      </method>
      <method name="_makeAnims" scope="prototype">
        <description>Pre-generate the animations</description>
      </method>
      <method name="onClick" scope="prototype">
        <description>stub function fired when target is clicked
	connect or override to use.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <description>stub function fired when Fisheye Item is fully visible and
	hovered. connect or override use.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="durationIn" scope="prototype" type="Object"/>
      <property name="durationOut" scope="prototype" type="Integer">
        <description>The Time (in ms) to run the hide animation</description>
      </property>
      <property name="properties" scope="instance-prototype" type="Object">
        <description>An object of &amp;quot;property&amp;quot;:scale pairs
	defaults to font-size with a scale of 2.75</description>
      </property>
      <property name="unit" scope="prototype" type="String">
        <description>Sometimes, you need to specify a unit. Should be part of
	properties attrib, but was trying to shorthand the logic there</description>
      </property>
      <property name="_target" scope="instance" type="Object"/>
      <property name="_runningIn" scope="instance" type="Object"/>
      <property name="_runningOut" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator" superclass="dijit.Declaration">
    <methods>
      <method name="_setSrcIndex" scope="prototype">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="update" scope="prototype"/>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttrValuesObj" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDataAvailable" scope="prototype">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="constructor" scope="prototype" type="Object"/>
      <property name="start" scope="prototype" type="Object"/>
      <property name="fetchMax" scope="prototype" type="Object"/>
      <property name="attrs" scope="instance-prototype" type="Object"/>
      <property name="defaultValue" scope="prototype" type="Object"/>
      <property name="widgetCtor" scope="instance-prototype" type="Object"/>
      <property name="dataValues" scope="prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object"/>
      <property name="_srcIndex" scope="instance-prototype" type="Object"/>
      <property name="_srcParent" scope="instance-prototype" type="Object"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="_classes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator.query">
    <properties>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader" superclass="dijit._Widget">
    <description>a configurable global xhr-listener to display
	a loading message during running xhr's or to simply provide
	base-level topic to subscribe to for custom loading messages</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>setup the loader</description>
      </method>
      <method name="_setMessage" scope="prototype">
        <description>set's the message in the loader</description>
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_putLoader" scope="prototype">
        <description>place the floating loading element based on mousemove connection position</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_show" scope="prototype">
        <description>publish and show progress indicator</description>
      </method>
      <method name="_hide" scope="prototype">
        <description>publish &amp;quot;xhr ended&amp;quot; and hide progress indicator</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadIcon" scope="prototype" type="Object"/>
      <property name="loadMessage" scope="prototype" type="String">
        <description>string to use for progress loading</description>
      </property>
      <property name="hasVisuals" scope="prototype" type="Boolean">
        <description>true to display a fixed loading message in TR cornder, false to unly provide
	&amp;quot;Loader&amp;quot; topic to subscribe to for your own custom loading message.</description>
      </property>
      <property name="attachToPointer" scope="prototype" type="Object"/>
      <property name="duration" scope="prototype" type="Integer">
        <description>time in ms to toggle in/out the visual load indicator</description>
      </property>
      <property name="_offset" scope="prototype" type="Integer">
        <description>distance in px from the mouse pointer to show attachToPointer avatar</description>
      </property>
      <property name="_pointerConnect" scope="instance-prototype" type="Object"/>
      <property name="_xhrStart" scope="instance-prototype" type="Object"/>
      <property name="_xhrEnd" scope="instance-prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadMessageNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager" superclass="dijit._Widget">
    <description>A Pager, displaying a list of sized nodes</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_a11yStyle" scope="prototype">
        <description>top level onfocus/onblur listen to set a class &amp;quot;pagerFocus&amp;quot; on some node
	and remove it onblur</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <description>Handle keyboard navigation internally</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="prototype">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderPages" scope="prototype"/>
      <method name="_renderPager" scope="prototype"/>
      <method name="_renderStatus" scope="prototype"/>
      <method name="_pagerSkip" scope="prototype">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pagerNext" scope="prototype"/>
      <method name="_pagerPrevious" scope="prototype"/>
      <method name="onScrollEnd" scope="prototype">
        <description>Stub Function. Fired after the slide is complete. Override or connect.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="iconPrevious" scope="prototype" type="String?">
        <description>The url of the previous page icon</description>
      </property>
      <property name="iconNext" scope="prototype" type="String?">
        <description>The url of the next page icon</description>
      </property>
      <property name="iconPage" scope="prototype" type="Object"/>
      <property name="iconPageActive" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object">
        <description>A dojo.data Data store</description>
      </property>
      <property name="orientation" scope="instance-prototype" type="String">
        <description>Either &amp;quot;horizontal or &amp;quot;vertical&amp;quot; to define the direction the pages will slide</description>
      </property>
      <property name="statusPos" scope="instance-prototype" type="String">
        <description>A string describing where to put the Pager &amp;quot;current page&amp;quot; indicator. Options are
	&amp;quot;leading&amp;quot; or &amp;quot;trailing&amp;quot;. In the case of horiztonal orientation, &amp;quot;leading&amp;quot; indicates
	positioned above the PageItems. In the case of vertical, &amp;quot;leading&amp;quot; indicates &amp;quot;before&amp;quot;.</description>
      </property>
      <property name="pagerPos" scope="instance-prototype" type="String">
        <description>TODOC</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>Time in milliseconds to transition the pages</description>
      </property>
      <property name="itemSpace" scope="prototype" type="Integer">
        <description>Spacing between items? TODOC</description>
      </property>
      <property name="resizeChildren" scope="prototype" type="Boolean">
        <description>TODOC</description>
      </property>
      <property name="itemClass" scope="prototype" type="String">
        <description>The full dotted named of a Class to use for the internal Pager Items.</description>
      </property>
      <property name="itemsPage" scope="prototype" type="Integer">
        <description>The numbers of items to display in each &amp;quot;Page&amp;quot;</description>
      </property>
      <property name="items" scope="instance" type="Object"/>
      <property name="_totalPages" scope="instance" type="Object"/>
      <property name="iconWidth" scope="instance" type="Object"/>
      <property name="iconHeight" scope="instance" type="Object"/>
      <property name="iconsLoaded" scope="instance" type="Object"/>
      <property name="_iconConnects" scope="instance" type="Object"/>
      <property name="_currentPage" scope="instance" type="Object"/>
      <property name="_toScroll" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._PagerItem" superclass="dijit._Widget">
    <methods>
      <method name="resizeChildren" scope="prototype"/>
      <method name="parseChildren" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem" superclass="dijit.MenuItem">
    <description>A menu item that can be used as a placeholder.  Set the label
	of this item to a unique key and you can then use it to add new
	items at that location.  This item is not displayed.</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="replace" scope="prototype">
        <description>replaces this menu item with the given menuItems.  The original
	menu item is not actually removed from the menu - so if you want
	it removed, you must do that explicitly.</description>
        <parameters>
          <parameter name="menuItems" type="dijit.MenuItem[]" usage="required"/>
        </parameters>
        <return-description>true if the replace happened, false if not</return-description>
      </method>
      <method name="unReplace" scope="prototype">
        <description>Removes menu items added by calling replace().  It returns the
	array of items that were actually removed (in case you want to
	clean them up later)</description>
        <parameters>
          <parameter name="destroy" type="Boolean" usage="optional">
            <description>Also call destroy on any removed items.</description>
          </parameter>
        </parameters>
        <return-description>The array of items that were actually removed</return-description>
        <return-types>
          <return-type type="dijit.MenuItem[]"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_replaced" scope="instance-prototype" type="Object"/>
      <property name="_replacedWith" scope="instance-prototype" type="Object"/>
      <property name="_isPlaceholder" scope="prototype" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller" superclass="dijit._Widget">
    <description>A simple widget to take an unorder-list of Text and roll through them</description>
    <example>
		// create a scroller from a unorderlist with id="lister"
		var thinger = new dojox.widget.Roller.Roller({},"lister");</example>
    <methods>
      <method name="makeAnims" scope="prototype">
        <description>Animation creator function. Need to create an 'in' and 'out'
	_Animation stored in _anim Object, which the rest of the widget
	will reuse.</description>
      </method>
      <method name="_setupConnects" scope="prototype">
        <description>setup the loop connection logic</description>
      </method>
      <method name="start" scope="prototype">
        <description>Starts to Roller looping</description>
      </method>
      <method name="_run" scope="prototype"/>
      <method name="stop" scope="prototype">
        <description>Stops the Roller from looping anymore.</description>
      </method>
      <method name="_set" scope="prototype">
        <description>Set the Roller to some passed index. If beyond range, go to first.</description>
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="delay" scope="prototype" type="Integer">
        <description>Interval between rolls</description>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <description>Toggle to control starup behavior. Call .start() manually
	if set to `false`</description>
      </property>
      <property name="items" scope="prototype" type="Array">
        <description>If populated prior to instantiation, is used as the Items over the children</description>
      </property>
      <property name="_timeout" scope="instance" type="Object"/>
      <property name="rolling" scope="instance" type="Object"/>
      <property name="_idx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller._roller">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.RollerSlide" superclass="dojox.widget.Roller">
    <description>An add-on to the Roller to modify animations. This produces
	a slide-from-bottom like effect</description>
    <methods>
      <method name="makeAnims" scope="prototype">
        <description>Animation creator function. Need to create an 'in' and 'out'
	_Animation stored in _anim Object, which the rest of the widget
	will reuse.</description>
      </method>
    </methods>
  </class>
  <class type="this._anim">
    <properties>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListPane" superclass="dijit.layout.ContentPane">
    <description>a core pane that can be attached to a RollingList.  All panes
	should extend this one</description>
    <methods>
      <method name="_setContentAndScroll" scope="prototype">
        <description>sets the value of the content and scrolls it into view</description>
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_focusKey" scope="prototype">
        <description>called when a keypress happens on the widget</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <description>sets the focus to this current widget</description>
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_loadCheck" scope="prototype">
        <description>checks that the store is loaded</description>
        <parameters>
          <parameter name="forceLoad" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <description>either runs the query or loads potentially not-yet-loaded items.</description>
      </method>
      <method name="_hasItem" scope="prototype">
        <description>returns whether or not the given item is handled by this
	pane</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object | array" usage="required"/>
          <parameter name="newValue" type="object | array" usage="required"/>
        </parameters>
      </method>
      <method name="_onNewItem" scope="prototype">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="prototype">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchStart" scope="prototype">
        <description>called before a fetch starts</description>
      </method>
      <method name="onFetchError" scope="prototype">
        <description>called when a fetch error occurs.</description>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStart" scope="prototype">
        <description>called before a load starts</description>
      </method>
      <method name="onLoadError" scope="prototype">
        <description>called when a load error occurs.</description>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="prototype">
        <description>called after a fetch or load - at this point, this.items should be
	set and loaded.  Override this function to &amp;quot;do your stuff&amp;quot;</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Contained" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="parentPane" scope="prototype" type="dojox.widget._RollingListPane">
        <description>The pane that immediately precedes ours</description>
      </property>
      <property name="store" scope="prototype" type="store">
        <description>the store we must use</description>
      </property>
      <property name="items" scope="instance-prototype" type="item[]">
        <description>an array of (possibly not-yet-loaded) items to display in this.
	If this array is null, then the query and query options are used to
	get the top-level items to use.  This array is also used to watch and
	see if the pane needs to be reloaded (store notifications are handled)
	by the pane</description>
      </property>
      <property name="query" scope="prototype" type="object">
        <description>a query to pass to the datastore.  This is only used if items are null</description>
      </property>
      <property name="queryOptions" scope="prototype" type="object">
        <description>query options to be passed to the datastore</description>
      </property>
      <property name="_focusByNode" scope="prototype" type="Object"/>
      <property name="isLoaded" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListPane.parentWidget">
    <description>Our rolling list widget</description>
    <properties>
      <property name="_focusedPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane" superclass="dojox.widget._RollingListPane">
    <description>a pane that will handle groups (treats them as menu items)</description>
    <methods>
      <method name="_loadCheck" scope="prototype">
        <description>checks that the store is loaded</description>
        <parameters>
          <parameter name="forceLoad" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="prototype">
        <description>called after a fetch or load - at this point, this.items should be
	set and loaded.</description>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="focus" scope="prototype">
        <description>sets the focus to this current widget</description>
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenu" scope="prototype">
        <description>returns a widget to be used for the container widget.</description>
      </method>
      <method name="_getSelected" scope="prototype">
        <description>returns the selected menu item - or null if none are selected</description>
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_setSelected" scope="prototype">
        <description>selectes the given item in the given menu (defaults to pane's menu)</description>
        <parameters>
          <parameter name="item" type="dijit.MenuItem" usage="optional"/>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="prototype" type="string">
        <description>our template</description>
      </property>
      <property name="_menu" scope="instance-prototype" type="dijit.Menu">
        <description>The menu that we will call addChild() on for adding items</description>
      </property>
      <property name="_focusByNode" scope="instance" type="Object"/>
      <property name="_pendingFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList" superclass="dijit._Widget">
    <description>a rolling list that can be tied to a data store with children</description>
    <methods>
      <method name="_itemsMatch" scope="prototype">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_removeAfter" scope="prototype">
        <description>removes all widgets after the given widget (or index)</description>
        <parameters>
          <parameter name="idx" type="Widget or int" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <description>adds a child to this rolling list - if passed an insertIndex,
	then all children from that index on will be removed and destroyed
	before adding the child.</description>
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateClass" scope="prototype">
        <description>sets the state of the given node with the given type and options</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional">
            <description>an object with key-value-pairs.  The values are boolean, if true,
	the key is added as a class, if false, it is removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="prototype">
        <description>scrolls the given widget into view</description>
        <parameters>
          <parameter name="childWidget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="_onChange" scope="prototype">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="prototype">
        <description>internally sets the value and fires onchange</description>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <description>sets the value of this widget to the given store item</description>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClick" scope="prototype">
        <description>internally called when a widget should pop up its child</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPaneForItem" scope="prototype">
        <description>gets the pane for the given item, and mixes in our needed parts
	Returns the pane for the given item (null if the root pane) - after mixing in
	its stuff.</description>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenuItemForItem" scope="prototype">
        <description>returns a widget for the given store item.  The returned
	item will be added to this widget's container widget.  null will
	be passed in for an &amp;quot;empty&amp;quot; item.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="prototype">
        <description>sets the store for this widget */</description>
        <parameters>
          <parameter name="store" type="dojo.data.api.Read" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <description>called when a keypress event happens on this widget</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <description>sets the focus state of this widget</description>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="getChildItems" scope="prototype">
        <description>Returns the child items for the given store item</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="prototype">
        <description>user overridable function to return a widget for the given item
	and its children.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="prototype">
        <description>user-overridable function to return a pane that corresponds
	to the given item in the store.  It can return null to not add a new pane
	(ie, you are planning on doing something else with it in onItemClick)
	Item is undefined for the root pane, children is undefined for non-group panes</description>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="prototype">
        <description>called when an item is clicked - it receives the store item</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onExecute" scope="prototype">
        <description>exists so that popups don't disappear too soon</description>
      </method>
      <method name="onCancel" scope="prototype">
        <description>exists so that we can close ourselves if we wish</description>
      </method>
      <method name="onChange" scope="prototype">
        <description>called when the value of this widget has changed</description>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="string">
        <description>our template string to use</description>
      </property>
      <property name="className" scope="prototype" type="string">
        <description>an additional class (or space-separated classes) to add for our widget</description>
      </property>
      <property name="store" scope="instance-prototype" type="store">
        <description>the store we must use</description>
      </property>
      <property name="query" scope="prototype" type="object">
        <description>a query to pass to the datastore.  This is only used if items are null</description>
      </property>
      <property name="queryOptions" scope="prototype" type="object">
        <description>query options to be passed to the datastore</description>
      </property>
      <property name="childrenAttrs" scope="prototype" type="String[]">
        <description>one ore more attributes that holds children of a node</description>
      </property>
      <property name="parentAttr" scope="prototype" type="string">
        <description>the attribute to read for finding our parent item (if any)</description>
      </property>
      <property name="value" scope="instance-prototype" type="item">
        <description>The value that has been selected</description>
      </property>
      <property name="handleKey" scope="prototype" type="Object"/>
      <property name="_declaredClasses" scope="instance" type="Object"/>
      <property name="_scrollingTimeout" scope="instance" type="Object"/>
      <property name="_setInProgress" scope="instance" type="Object"/>
      <property name="_visibleItem" scope="instance" type="Object"/>
      <property name="_isIdentity" scope="instance" type="Object"/>
      <property name="_savedFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList" superclass="dijit.layout._LayoutWidget">
    <description>A sortable unordered-list with a fixed header for use in dijit.demos.chat
	for demonstration purposes only for now. feel free to make API suggestions
	or fixes.</description>
    <methods>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="resize" scope="prototype">
        <description>do our additional calculations when resize() is called by or in a parent</description>
      </method>
      <method name="onSort" scope="prototype">
        <description>sort the data, and style the nodes.</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="prototype">
        <description>set hover state</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_unset" scope="prototype">
        <description>remove hover state (FIXME: combine with _set?)</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="prototype">
        <description>click listener for data portion of widget. toggle selected state
	of node, and update this.selected array accordingly</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="prototype"/>
      <method name="_sorter" scope="prototype">
        <description>a basic sort function, use query sort, or keep this?</description>
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <description>Sets the widget title to a String</description>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChanged" scope="prototype">
        <description>stub function, passes the last changed item, and is fired after current state</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance-prototype" type="String">
        <description>The title in the header</description>
      </property>
      <property name="heading" scope="prototype" type="String">
        <description>In the event a parent container is expecting a title=&amp;quot;&amp;quot; attribute, set it for the parent
	via title, and the title of this widget via heading=&amp;quot;&amp;quot; ... assuming you want different
	titles for each. eg: TabContainer, AccordionContainer, etc.</description>
      </property>
      <property name="descending" scope="instance-prototype" type="Boolean">
        <description>Toggle sort order based on this value.</description>
      </property>
      <property name="selected" scope="instance-prototype" type="Array">
        <description>A list of the selected &amp;lt;li&amp;gt; nodes at any given time.</description>
      </property>
      <property name="sortable" scope="prototype" type="Boolean">
        <description>toggle to enable/disable sorting</description>
      </property>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="key" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.bodyWrapper.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.focusNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster" superclass="dijit._Widget">
    <description>Message that slides in from the corner of the screen, used for notifications
	like &amp;quot;new email&amp;quot;.</description>
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="_handleMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_capitalize" scope="prototype">
        <parameters>
          <parameter name="w" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <description>sets and displays the given message and show duration</description>
        <parameters>
          <parameter name="message" type="String|Function" usage="required">
            <description>the message. If this is a function, it will be called with this toaster widget as the only argument.</description>
          </parameter>
          <parameter name="messageType" type="String" usage="required">
            <description>type of message; possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</description>
          </parameter>
          <parameter name="duration" type="int" usage="optional">
            <description>duration in milliseconds to display message before removing it. Widget has default value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeClip" scope="prototype"/>
      <method name="onSelect" scope="prototype">
        <description>callback for when user clicks the message</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <description>show the Toaster</description>
      </method>
      <method name="hide" scope="prototype">
        <description>hide the Toaster</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="messageTopic" scope="prototype" type="String">
        <description>Name of topic; anything published to this topic will be displayed as a message.
	Message format is either String or an object like
	{message: &amp;quot;hello word&amp;quot;, type: &amp;quot;error&amp;quot;, duration: 500}</description>
      </property>
      <property name="_uniqueId" scope="prototype" type="Object"/>
      <property name="defaultType" scope="prototype" type="String">
        <description>If message type isn't specified (see &amp;quot;messageTopic&amp;quot; parameter),
	then display message as this type.
	Possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</description>
      </property>
      <property name="positionDirection" scope="prototype" type="String">
        <description>Position from which message slides into screen, one of
	[&amp;quot;br-up&amp;quot;, &amp;quot;br-left&amp;quot;, &amp;quot;bl-up&amp;quot;, &amp;quot;bl-right&amp;quot;, &amp;quot;tr-down&amp;quot;, &amp;quot;tr-left&amp;quot;, &amp;quot;tl-down&amp;quot;, &amp;quot;tl-right&amp;quot;]</description>
      </property>
      <property name="positionDirectionTypes" scope="prototype" type="Array">
        <description>Possible values for positionDirection parameter</description>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <description>Number of milliseconds to show message</description>
      </property>
      <property name="separator" scope="prototype" type="String">
        <description>String used to separate messages if consecutive calls are made to setContent before previous messages go away</description>
      </property>
      <property name="_cancelHideTimer" scope="prototype" type="Object"/>
      <property name="_setHideTimer" scope="prototype" type="Object"/>
      <property name="slideAnim" scope="instance" type="Object"/>
      <property name="fadeAnim" scope="instance" type="Object"/>
      <property name="isVisible" scope="instance" type="Object"/>
      <property name="_stickyMessage" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.messageTypes">
    <description>Possible message types.</description>
    <properties>
      <property name="MESSAGE" scope="instance" type="Object"/>
      <property name="WARNING" scope="instance" type="Object"/>
      <property name="ERROR" scope="instance" type="Object"/>
      <property name="FATAL" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.contentNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard" superclass="dijit.layout.StackContainer">
    <description>A set of panels that display sequentially, typically notating a step-by-step
	procedure like an install</description>
    <methods>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_checkButtons" scope="prototype"/>
      <method name="_setButtonClass" scope="prototype">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forward" scope="prototype">
        <description>callback when next button is clicked</description>
      </method>
      <method name="done" scope="prototype">
        <description>Finish the wizard's operation</description>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="nextButtonLabel" scope="prototype" type="String">
        <description>Label override for the &amp;quot;Next&amp;quot; button.</description>
      </property>
      <property name="previousButtonLabel" scope="prototype" type="String">
        <description>Label override for the &amp;quot;Previous&amp;quot; button.</description>
      </property>
      <property name="cancelButtonLabel" scope="prototype" type="String">
        <description>Label override for the &amp;quot;Cancel&amp;quot; button.</description>
      </property>
      <property name="doneButtonLabel" scope="prototype" type="String">
        <description>Label override for the &amp;quot;Done&amp;quot; button.</description>
      </property>
      <property name="cancelFunction" scope="instance-prototype" type="Function|String">
        <description>Name of function to call if user presses cancel button.
	Cancel button is not displayed if function is not specified.</description>
      </property>
      <property name="hideDisabled" scope="prototype" type="Boolean">
        <description>If true, disabled buttons are hidden; otherwise, they are assigned the
	&amp;quot;WizardButtonDisabled&amp;quot; CSS class</description>
      </property>
      <property name="_subscription" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.cancelButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.doneButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.nextButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.WizardPane" superclass="dijit.layout.ContentPane">
    <description>A panel in a `dojox.widget.Wizard`</description>
    <methods>
      <method name="startup" scope="prototype"/>
      <method name="_checkPass" scope="prototype">
        <description>Called when the user presses the &amp;quot;next&amp;quot; button.
	Calls passFunction to see if it's OK to advance to next panel, and
	if it isn't, then display error.
	Returns true to advance, false to not advance. If passFunction
	returns a string, it is assumed to be a custom error message, and
	is alert()'ed</description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="done" scope="prototype"/>
    </methods>
    <properties>
      <property name="canGoBack" scope="instance-prototype" type="Boolean">
        <description>If true, then can move back to a previous panel (by clicking the &amp;quot;Previous&amp;quot; button)</description>
      </property>
      <property name="passFunction" scope="instance-prototype" type="String">
        <description>Name of function that checks if it's OK to advance to the next panel.
	If it's not OK (for example, mandatory field hasn't been entered), then
	returns an error message (String) explaining the reason.</description>
      </property>
      <property name="doneFunction" scope="instance-prototype" type="String">
        <description>Name of function that is run if you press the &amp;quot;Done&amp;quot; button from this panel</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire">
    <description>Declarative data binding and action tags for simplified MVC</description>
    <methods>
      <method name="register" scope="instance">
        <description>Register a Wire class
	desription:
	The specified Wire class or a class name is registered with
	a key property of arguments to create a Wire</description>
        <parameters>
          <parameter name="wireClass" type="Function||String" usage="required">
            <description>A class or full qualified class name</description>
          </parameter>
          <parameter name="key" type="String" usage="required">
            <description>A key property of arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getClass" scope="instance">
        <description>Returns a class</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>A class name</description>
          </parameter>
        </parameters>
        <return-description>A class</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>Create a Wire from arguments</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-description>A Wire</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isWire" scope="instance">
        <description>Check if an object is a Wire</description>
        <parameters>
          <parameter name="wire" type="Object" usage="required">
            <description>An object to check</description>
          </parameter>
        </parameters>
        <return-description>True if the object is a Wire, otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="transfer" scope="instance">
        <description>Transfer a source value to a target value</description>
        <parameters>
          <parameter name="source" type="Wire||Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire||Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
          <parameter name="defaultObject" type="Object" usage="optional">
            <description>defaultTargetObject Optional default root objects passed to Wires</description>
          </parameter>
          <parameter name="defaultTargetObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Transfer a source value to a target value on a trigger event or
	topic</description>
        <parameters>
          <parameter name="trigger" type="Object" usage="required">
            <description>An event or topic to trigger a transfer</description>
          </parameter>
          <parameter name="source" type="Wire||Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire||Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
        </parameters>
        <return-description>A connection handle for disconnect()</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Remove a connection or subscription for transfer</description>
        <parameters>
          <parameter name="connection" type="Object" usage="required">
            <description>A connection handle returned by connect()</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_defaultWireClass" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.CompositeWire" superclass="dojox.wire.Wire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return an object with property values or an array with element
	values</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <description>A root object</description>
          </parameter>
        </parameters>
        <return-description>An object or array with values</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Set an object properties or an array elements to an object
	desription:
	This method calls setValues() method of the child Wires with
	a corresponding property or element in 'value' argument and
	'object' argument.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <description>A root object</description>
          </parameter>
          <parameter name="value" type="Object||Array" usage="required">
            <description>An object or array with values to set</description>
          </parameter>
        </parameters>
        <return-description>'object'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_initializeChildren" scope="prototype">
        <description>Initialize child Wires</description>
        <parameters>
          <parameter name="children" type="Object||Array" usage="required">
            <description>An object or array containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.DataWire" superclass="dojox.wire.Wire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return an attribute value of an item</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Set an attribute value to an item</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-description>'object', or 'undefined' for invalid attribute</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getAttributeValue" scope="prototype">
        <description>Return an attribute value of an item</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item
	attribute
	An attribute name</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="return array for &quot;attribute[]&quot;"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setAttributeValue" scope="prototype">
        <description>Set an attribute value to an item</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>An attribute name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
      <property name="dataStore" scope="instance" type="A">
        <description>data store
	attribute:
	A dotted notation to a descendant attribute</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.TableAdapter" superclass="dojox.wire.CompositeWire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return an array of table row value (object or array)</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of table row value</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Not supported</description>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getRow" scope="prototype">
        <description>Return an array or object for a table row</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>An array or object for a table row</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.TextAdapter" superclass="dojox.wire.CompositeWire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return a concatenated text</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Not supported</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addSegment" scope="prototype">
        <description>Return a concatenated text</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>A base text</description>
          </parameter>
          <parameter name="segment" type="String" usage="required">
            <description>A text segment to add</description>
          </parameter>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
      <property name="delimiter" scope="instance" type="A">
        <description>delimiter string</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.TreeAdapter" superclass="dojox.wire.CompositeWire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return an array of tree node values</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of tree node values</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Not supported</description>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_initializeChildren" scope="prototype">
        <description>Initialize child Wires</description>
        <parameters>
          <parameter name="children" type="Array" usage="required">
            <description>An array of objects containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodes" scope="prototype">
        <description>Return an array of tree node values</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="child" type="Object" usage="required">
            <description>An object with child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.Wire">
    <description>Initialize properties</description>
    <methods>
      <method name="getValue" scope="prototype">
        <description>Return a value of an object</description>
        <parameters>
          <parameter name="defaultObject" type="Object||Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
        <return-description>A value found</return-description>
        <return-types>
          <return-type type="anything (null, undefined, etc)"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <description>Set a value to an object</description>
        <parameters>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
          <parameter name="defaultObject" type="Object||Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPropertyValue" scope="prototype">
        <description>Return a property value of an object</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <description>A default root object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setPropertyValue" scope="prototype">
        <description>Set a property value to an object</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
      <property name="converter" scope="instance" type="A">
        <description>converter object (or class name) to convert the return
	value (for the source Wire)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.XmlWire" superclass="dojox.wire.Wire">
    <description>Initialize properties</description>
    <methods>
      <method name="_getValue" scope="prototype">
        <description>Return an attribute value, a text value or an array of elements</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <description>Set an attribute value or a child text value to an element</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="to be returned as a new object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodeValue" scope="prototype">
        <description>Return an attribute value, a text value or an array of elements</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute, text or elements</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setNodeValue" scope="prototype">
        <description>Set an attribute value or a child text value to an element</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute or text</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildNode" scope="prototype">
        <description>Return a child node</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A parent node</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>A tag name</description>
          </parameter>
        </parameters>
        <return-description>A child node</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="prototype">
        <description>Return a DOM document</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire._wireClasses">
    <properties>
      <property name="attribute" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="columns" scope="instance" type="Object"/>
      <property name="nodes" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml">
    <methods>
      <method name="_getValue" scope="instance">
        <description>Return a value</description>
        <parameters>
          <parameter name="source" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>An optional arguments array</description>
          </parameter>
        </parameters>
        <return-description>A value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>Store a value</description>
        <parameters>
          <parameter name="target" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Action" superclass="dijit._Widget">
    <description>A base widget to &amp;quot;run&amp;quot; a task on an event or a topic</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Call _connect()</description>
      </method>
      <method name="_connect" scope="prototype">
        <description>Connect run() method to an event or a topic</description>
      </method>
      <method name="_disconnect" scope="prototype">
        <description>Disconnect run() method from an event or a topic</description>
      </method>
      <method name="run" scope="prototype">
        <description>Run a task</description>
      </method>
      <method name="_run" scope="prototype">
        <description>Call run() methods of child Action widgets</description>
      </method>
      <method name="uninitialize" scope="prototype">
        <description>Over-ride of base widget unitialize function to do some connection cleanup.</description>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="trigger" scope="prototype" type="An">
        <description>event scope</description>
      </property>
      <property name="triggerEvent" scope="prototype" type="An">
        <description>event (function) name</description>
      </property>
      <property name="triggerTopic" scope="prototype" type="A">
        <description>topic name</description>
      </property>
      <property name="_triggerHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.ActionFilter" superclass="dijit._Widget">
    <description>A widget to define a filter for the parent Action to run</description>
    <methods>
      <method name="filter" scope="prototype">
        <description>Check if a required property is specified.  Also, if provided, check to see
	if the required property contains a specific value.</description>
        <return-description>True if a required property is specified (and if requiredValue is specified,
	that they match), otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="required" scope="instance-prototype" type="A">
        <description>property required</description>
      </property>
      <property name="requiredValue" scope="instance-prototype" type="Optional.">
        <description>A specific value the property is required to have.  If this isn't provided
	than any non-false/non-null value of the required propery will cause this filter
	to pass.</description>
      </property>
      <property name="type" scope="prototype" type="Optional.">
        <description>A specific type to compare the values as (if requiredValue is set)
	Valid values for type are boolean, int, string.  Default is string.</description>
      </property>
      <property name="message" scope="prototype" type="An">
        <description>error message to emit if the filter doesn't execute due to property mismatch.</description>
      </property>
      <property name="error" scope="prototype" type="A">
        <description>property to store an error due to property mismatch.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.Data" superclass="dijit._Widget">
    <description>A widget for a data object</description>
    <methods>
      <method name="startup" scope="prototype">
        <description>Call _initializeProperties()</description>
      </method>
      <method name="_initializeProperties" scope="prototype">
        <description>Initialize a data object</description>
        <parameters>
          <parameter name="reset" type="Boolean" usage="required">
            <description>A boolean to reset current properties</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="prototype">
        <description>Return a property value</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="prototype">
        <description>Store a property value</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataProperty" superclass="dijit._Widget">
    <description>A widget to define a data property</description>
    <methods>
      <method name="getValue" scope="prototype">
        <description>Returns a property value</description>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="prototype" type="A">
        <description>property name</description>
      </property>
      <property name="type" scope="instance-prototype" type="A">
        <description>property type name</description>
      </property>
      <property name="value" scope="prototype" type="A">
        <description>property value</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore" superclass="dijit._Widget">
    <description>A widget for a data store</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Call _createStore()</description>
      </method>
      <method name="_createStore" scope="prototype">
        <description>Create a data store
	desription:
	A data store of 'storeClass' is created with arguments
	specified with attributes.</description>
        <return-description>A data store</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="prototype">
        <description>Call getFeatures() method of a data store</description>
        <return-description>A features object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fetch" scope="prototype">
        <description>Call fetch() method of a data store</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
        </parameters>
        <return-description>A request object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <description>Call save() method of a data store</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A save arguments object</description>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <description>Call newItem() method of a data store</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A new item arguments object</description>
          </parameter>
        </parameters>
        <return-description>A new item</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <description>Call deleteItem() method of a data store</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="prototype">
        <description>Call revert() method of a data store</description>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="storeClass" scope="prototype" type="A">
        <description>class name of a data store</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Invocation" superclass="dojox.wire.ml.Action">
    <description>A widget to invoke a method or publish a topic</description>
    <methods>
      <method name="_run" scope="prototype">
        <description>Invoke a method or publish a topic</description>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="onComplete" scope="prototype">
        <description>A function called when the method or the topic publish
	completed</description>
        <parameters>
          <parameter name="result" type="anything" usage="required">
            <description>The return value of a method or undefined for a topic</description>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <description>A function called on an error occurs</description>
        <parameters>
          <parameter name="error" type="anything" usage="required">
            <description>The exception or error occurred</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getParameters" scope="prototype">
        <description>Returns arguments to a method or topic to invoke</description>
        <parameters>
          <parameter name="args" type="Array" usage="required">
            <description>Arguments to a trigger event or topic</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="object" scope="prototype" type="A">
        <description>scope of a method to invoke</description>
      </property>
      <property name="method" scope="instance-prototype" type="A">
        <description>name of a method to invoke</description>
      </property>
      <property name="topic" scope="prototype" type="A">
        <description>name of a topic to publish</description>
      </property>
      <property name="parameters" scope="prototype" type="Arguments">
        <description>for the method or the topic</description>
      </property>
      <property name="result" scope="prototype" type="A">
        <description>property to store a return value of the method call</description>
      </property>
      <property name="error" scope="prototype" type="A">
        <description>property to store an error on the method call</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service" superclass="dijit._Widget">
    <description>A widget for a service</description>
    <methods>
      <method name="postCreate" scope="prototype">
        <description>Call _createHandler()</description>
      </method>
      <method name="_createHandler" scope="prototype">
        <description>Create a service handler
	desription:
	A service handler class is determined by:
	1. 'handlerClass' attribute
	2. 'serviceType' attribute
	3. 'serviceType' property in a service description</description>
        <return-description>A service handler</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="callMethod" scope="prototype">
        <description>Call a service method with parameters</description>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array parameters</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="prototype" type="A">
        <description>URL to a service description</description>
      </property>
      <property name="serviceUrl" scope="instance-prototype" type="A">
        <description>URL to a service</description>
      </property>
      <property name="serviceType" scope="prototype" type="A">
        <description>service type</description>
      </property>
      <property name="handlerClass" scope="prototype" type="A">
        <description>service handler class name</description>
      </property>
      <property name="preventCache" scope="prototype" type="Object"/>
      <property name="handler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service._handlerClasses">
    <properties>
      <property name="TEXT" scope="instance" type="Object"/>
      <property name="XML" scope="instance" type="Object"/>
      <property name="JSON" scope="instance" type="Object"/>
      <property name="JSON-RPC" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.RestHandler">
    <description>A REST service handler</description>
    <methods>
      <method name="bind" scope="prototype">
        <description>Call a service method with parameters.</description>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array of parameters</description>
          </parameter>
          <parameter name="deferred" type="Deferred" usage="required"/>
          <parameter name="url" type="A" usage="required">
            <description>URL for the method</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getUrl" scope="prototype">
        <description>Generate a URL</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>A base URL</description>
          </parameter>
        </parameters>
        <return-description>A URL</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getContent" scope="prototype">
        <description>Generate a request content</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="anything"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getResult" scope="prototype">
        <description>Extract a result</description>
        <parameters>
          <parameter name="data" type="anything" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="contentType" scope="prototype" type="Object"/>
      <property name="handleAs" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlHandler" superclass="dojox.wire.ml.RestHandler">
    <description>A REST service handler for XML</description>
    <methods>
      <method name="_getContent" scope="prototype">
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
      </method>
      <method name="_getResult" scope="prototype">
        <description>Extract a result</description>
        <parameters>
          <parameter name="data" type="Document" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
      </method>
    </methods>
    <properties>
      <property name="contentType" scope="prototype" type="Object"/>
      <property name="handleAs" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler" superclass="dojox.wire.ml.RestHandler">
    <description>A REST service handler for JSON</description>
    <methods>
      <method name="_getContent" scope="prototype">
        <description>Generate a request content</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="contentType" scope="prototype" type="Object"/>
      <property name="handleAs" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler.headers">
    <properties>
      <property name="Accept" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Transfer" superclass="dojox.wire.ml.Action">
    <description>A widget to transfer values through source and target Wires</description>
    <methods>
      <method name="_run" scope="prototype">
        <description>Transfer a value from a source to a target</description>
      </method>
      <method name="_getWire" scope="prototype">
        <description>Build Wire arguments from attributes</description>
        <parameters>
          <parameter name="which" type="String" usage="required">
            <description>Which Wire arguments to build, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="source" scope="prototype" type="A">
        <description>source object and/or property</description>
      </property>
      <property name="sourceStore" scope="prototype" type="A">
        <description>data store for a source data item</description>
      </property>
      <property name="sourceAttribute" scope="prototype" type="An">
        <description>attribute of a source data item</description>
      </property>
      <property name="sourcePath" scope="prototype" type="A">
        <description>simplified XPath to a source property of an XML element</description>
      </property>
      <property name="type" scope="prototype" type="A">
        <description>type of the value to be transferred</description>
      </property>
      <property name="converter" scope="prototype" type="A">
        <description>class name of a converter for the value to be transferred</description>
      </property>
      <property name="delimiter" scope="prototype" type="Object"/>
      <property name="target" scope="prototype" type="A">
        <description>target object and/or property</description>
      </property>
      <property name="targetStore" scope="prototype" type="A">
        <description>data store for a target data item</description>
      </property>
      <property name="targetAttribute" scope="prototype" type="An">
        <description>attribute of a target data item</description>
      </property>
      <property name="targetPath" scope="prototype" type="A">
        <description>simplified XPath to a target property of an XML element</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.ChildWire" superclass="dijit._Widget">
    <description>A widget to add a child wire</description>
    <methods>
      <method name="_addWire" scope="prototype">
        <description>Add a child Wire to Wire arguments</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getWire" scope="prototype">
        <description>Build child Wire arguments from attributes</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
      </method>
    </methods>
    <properties>
      <property name="which" scope="prototype" type="Which">
        <description>Wire to add a child Wire, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;, default to
	&amp;quot;source&amp;quot;</description>
      </property>
      <property name="object" scope="prototype" type="A">
        <description>root object for the value</description>
      </property>
      <property name="property" scope="prototype" type="A">
        <description>property for the value</description>
      </property>
      <property name="type" scope="prototype" type="A">
        <description>type of the value</description>
      </property>
      <property name="converter" scope="prototype" type="A">
        <description>class name of a converter for the value</description>
      </property>
      <property name="attribute" scope="prototype" type="A">
        <description>data item attribute for the value</description>
      </property>
      <property name="path" scope="prototype" type="A">
        <description>simplified XPath for the value</description>
      </property>
      <property name="name" scope="prototype" type="A">
        <description>composite property name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.ColumnWire" superclass="dojox.wire.ml.ChildWire">
    <description>A widget to add a column wire</description>
    <methods>
      <method name="_addWire" scope="prototype">
        <description>Add a column Wire to Wire arguments</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="column" scope="prototype" type="A">
        <description>column name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.NodeWire" superclass="dojox.wire.ml.ChildWire">
    <description>A widget to add node wires</description>
    <methods>
      <method name="_addWire" scope="prototype">
        <description>Add node Wires to Wire arguments</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getWires" scope="prototype">
        <description>Build node Wires arguments from attributes</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Container" scope="prototype"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleProperty" scope="prototype" type="A">
        <description>property for the node title</description>
      </property>
      <property name="titleAttribute" scope="prototype" type="A">
        <description>data item attribute for the node title</description>
      </property>
      <property name="titlePath" scope="prototype" type="A">
        <description>simplified XPath for the node title</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.SegmentWire" superclass="dojox.wire.ml.ChildWire">
    <description>A widget to add a segment wire</description>
    <methods>
      <method name="_addWire" scope="prototype">
        <description>Add a segument Wire to Wire arguments</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.XmlElement">
    <description>Initialize with an XML element or a tag name</description>
    <methods>
      <method name="getPropertyValue" scope="prototype">
        <description>Return a property value</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="XmlElement"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="prototype">
        <description>Store a property value</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="String||Array||XmlElement" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <description>Return a value of the first text child of the element</description>
        <return-description>A value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toObject" scope="prototype">
        <description>Return an object representation of the element</description>
        <return-description>An object representation of the element</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="prototype">
        <description>Return a DOM document</description>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.XmlElement.element">
    <description>XML element or a tag name</description>
    <properties>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xml">
    <description>XML utilities.  Currently only includes a DomParser, which returns a psuedo-XML document in JSON-like form.</description>
  </class>
  <class type="dojox.xml.DomParser">
    <methods>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getElementById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="nodeType" scope="instance" type="Object"/>
      <property name="nodeName" scope="instance" type="Object"/>
      <property name="namespaces" scope="instance" type="Object"/>
      <property name="_nsPaths" scope="instance" type="Object"/>
      <property name="childNodes" scope="instance" type="Object"/>
      <property name="documentElement" scope="instance" type="Object"/>
      <property name="byId" scope="instance" type="Object"/>
      <property name="byName" scope="instance" type="Object"/>
      <property name="byNameNS" scope="instance" type="Object"/>
      <property name="childrenByName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xml.Script"/>
  <class type="dojox.xml.parser">
    <methods>
      <method name="parse" scope="instance">
        <description>returns a new native XML document from the string provided as the
	single argument to parse(). Parsing errors throw exceptions.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomDocument"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.xml.widgetParser">
    <methods>
      <method name="parseNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processScript" scope="instance">
        <parameters>
          <parameter name="script" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toHTML" scope="instance">
        <parameters>
          <parameter name="node" type="XmlNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="toBuild.push" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.xmpp"/>
  <class type="dojox.xmpp.ChatService">
    <methods>
      <method name="recieveMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="initial" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSession" scope="prototype">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="prototype">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invite" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendChatState" scope="prototype">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onNewMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onInvite" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="state" scope="instance-prototype" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="uid" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
      <property name="chatid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.chat">
    <properties>
      <property name="CHAT_STATE_NS" scope="instance" type="Object"/>
      <property name="ACTIVE_STATE" scope="instance" type="Object"/>
      <property name="COMPOSING_STATE" scope="instance" type="Object"/>
      <property name="INACTIVE_STATE" scope="instance" type="Object"/>
      <property name="PAUSED_STATE" scope="instance" type="Object"/>
      <property name="GONE_STATE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService">
    <methods>
      <method name="publish" scope="prototype">
        <parameters>
          <parameter name="presence" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendAvatarHash" scope="prototype">
        <parameters>
          <parameter name="avatarHash" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPresence" scope="prototype"/>
      <method name="toggleBlockContact" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleContactInvisiblity" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRestrictedJid" scope="prototype"/>
      <method name="_updateRestricted" scope="prototype"/>
      <method name="_setVisible" scope="prototype"/>
      <method name="_setInvisible" scope="prototype"/>
      <method name="_manageSubscriptions" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="approveSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="declineSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="presence" scope="instance" type="Object"/>
      <property name="avatarHash" scope="instance" type="Object"/>
      <property name="isInvisible" scope="instance" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="restrictedContactjids" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.presence">
    <properties>
      <property name="UPDATE" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_REQUEST" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_SUBSTATUS_NONE" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_NONE" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_FROM" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_TO" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_BOTH" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_REQUEST_PENDING" scope="instance" type="Object"/>
      <property name="STATUS_ONLINE" scope="instance" type="Object"/>
      <property name="STATUS_AWAY" scope="instance" type="Object"/>
      <property name="STATUS_CHAT" scope="instance" type="Object"/>
      <property name="STATUS_DND" scope="instance" type="Object"/>
      <property name="STATUS_EXTENDED_AWAY" scope="instance" type="Object"/>
      <property name="STATUS_OFFLINE" scope="instance" type="Object"/>
      <property name="STATUS_INVISIBLE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.RosterService">
    <methods>
      <method name="addRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="verifyRoster" scope="prototype">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItemToGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterGroup" scope="prototype">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterGroup" scope="prototype">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItemFromGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterItemRenameGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="oldGroup" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="newName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAvatar" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publishAvatar" scope="prototype">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="binval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRoster" scope="prototype">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRosterFailed" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.roster">
    <properties>
      <property name="ADDED" scope="instance" type="Object"/>
      <property name="CHANGED" scope="instance" type="Object"/>
      <property name="REMOVED" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession">
    <methods>
      <method name="_iframeOnload" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleBOSH" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="prototype"/>
      <method name="_sendLogin" scope="prototype"/>
      <method name="processScriptSrc" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keepAlive" scope="prototype"/>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="protocolMsg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="protocolMatchType" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
          <parameter name="matchProperty" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatchPacket" scope="prototype"/>
      <method name="redispatchPacket" scope="prototype">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToOutboundQueue" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeFromOutboundQueue" scope="prototype">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolPacketQueue" scope="prototype"/>
      <method name="findOpenIframe" scope="prototype"/>
      <method name="sendXml" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processDocument" scope="prototype">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processInboundQueue" scope="prototype"/>
      <method name="addToInboundQueue" scope="prototype">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processResponse" scope="prototype">
        <parameters>
          <parameter name="body" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="prototype">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isTerminated" scope="prototype"/>
      <method name="processError" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="httpStatusCode" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProcessProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="prototype">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="transportIframes" scope="instance" type="Object"/>
      <property name="rid" scope="instance-prototype" type="Object"/>
      <property name="hold" scope="prototype" type="Object"/>
      <property name="polling" scope="instance-prototype" type="Object"/>
      <property name="secure" scope="prototype" type="Object"/>
      <property name="wait" scope="instance-prototype" type="Object"/>
      <property name="lang" scope="prototype" type="Object"/>
      <property name="submitContentType" scope="prototype" type="Object"/>
      <property name="serviceUrl" scope="prototype" type="Object"/>
      <property name="defaultResource" scope="prototype" type="Object"/>
      <property name="domain" scope="prototype" type="Object"/>
      <property name="sendTimeout" scope="prototype" type="Object"/>
      <property name="useScriptSrcTransport" scope="prototype" type="Object"/>
      <property name="keepAliveTimer" scope="instance-prototype" type="Object"/>
      <property name="state" scope="instance-prototype" type="Object"/>
      <property name="transmitState" scope="instance-prototype" type="Object"/>
      <property name="outboundQueue" scope="instance-prototype" type="Object"/>
      <property name="outboundRequests" scope="instance-prototype" type="Object"/>
      <property name="inboundQueue" scope="instance-prototype" type="Object"/>
      <property name="deferredRequests" scope="instance-prototype" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance-prototype" type="Object"/>
      <property name="status" scope="instance" type="Object"/>
      <property name="dispatchTimer" scope="instance" type="Object"/>
      <property name="lastPollTime" scope="instance" type="Object"/>
      <property name="sid" scope="instance" type="Object"/>
      <property name="authId" scope="instance" type="Object"/>
      <property name="inactivity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.protocolPacketQueue">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.UserService">
    <methods>
      <method name="getPersonalProfile" scope="prototype"/>
      <method name="setPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfileFailure" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onGetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfileFailure" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl">
    <properties>
      <property name="saslNS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.SunWebClientAuth"/>
  <class type="dojox.xmpp.sasl.SaslPlain"/>
  <class type="dojox.xmpp.util">
    <methods>
      <method name="xmlEncode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createElement" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="terminal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stripHtml" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeHtmlEntities" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="htmlToPlain" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.util.Base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="keylist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget"/>
  <class type="dojox.xmpp.widget.ChatSession" superclass="dijit.layout.LayoutContainer">
    <methods>
      <method name="postCreate" scope="prototype"/>
      <method name="displayMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToLastMessage" scope="prototype"/>
      <method name="onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dijit._Templated" scope="prototype"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="enableSubWidgets" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="widgetType" scope="prototype" type="Object"/>
      <property name="chatWith" scope="prototype" type="Object"/>
      <property name="instance" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.messages.domNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.chatInput">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp">
    <properties>
      <property name="STREAM_NS" scope="instance" type="Object"/>
      <property name="CLIENT_NS" scope="instance" type="Object"/>
      <property name="STANZA_NS" scope="instance" type="Object"/>
      <property name="SASL_NS" scope="instance" type="Object"/>
      <property name="BIND_NS" scope="instance" type="Object"/>
      <property name="BODY_NS" scope="instance" type="Object"/>
      <property name="XHTML_BODY_NS" scope="instance" type="Object"/>
      <property name="XHTML_IM_NS" scope="instance" type="Object"/>
      <property name="INACTIVE" scope="instance" type="Object"/>
      <property name="CONNECTED" scope="instance" type="Object"/>
      <property name="ACTIVE" scope="instance" type="Object"/>
      <property name="TERMINATE" scope="instance" type="Object"/>
      <property name="LOGIN_FAILURE" scope="instance" type="Object"/>
      <property name="INVALID_ID" scope="instance" type="Object"/>
      <property name="NO_ID" scope="instance" type="Object"/>
      <property name="error" scope="instance" type="Object"/>
      <property name="CONFLICT" scope="instance" type="Object"/>
      <property name="FEATURE_NOT_IMPLEMENTED" scope="instance" type="Object"/>
      <property name="FORBIDDEN" scope="instance" type="Object"/>
      <property name="GONE" scope="instance" type="Object"/>
      <property name="INTERNAL_SERVER_ERROR" scope="instance" type="Object"/>
      <property name="ITEM_NOT_FOUND" scope="instance" type="Object"/>
      <property name="ID_MALFORMED" scope="instance" type="Object"/>
      <property name="NOT_ACCEPTABLE" scope="instance" type="Object"/>
      <property name="NOT_ALLOWED" scope="instance" type="Object"/>
      <property name="NOT_AUTHORIZED" scope="instance" type="Object"/>
      <property name="SERVICE_UNAVAILABLE" scope="instance" type="Object"/>
      <property name="SUBSCRIPTION_REQUIRED" scope="instance" type="Object"/>
      <property name="UNEXPECTED_REQUEST" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession">
    <methods>
      <method name="open" scope="prototype">
        <parameters>
          <parameter name="user" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="resource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype"/>
      <method name="processProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="messageHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="featuresHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saslHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="chatHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="simpleMessageHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerChatInstance" scope="prototype">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqSetHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendIqResult" scope="prototype">
        <parameters>
          <parameter name="iqId" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterSetHandler" scope="prototype">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceUpdate" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="retrieveRoster" scope="prototype"/>
      <method name="getRosterIndex" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRosterEntry" scope="prototype">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bindResource" scope="prototype"/>
      <method name="getNextIqId" scope="prototype"/>
      <method name="presenceSubscriptionRequest" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="prototype">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="prototype">
        <parameters>
          <parameter name="searchString" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="searchAttribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSearchResults" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLogin" scope="prototype"/>
      <method name="onLoginFailure" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBindResource" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSearchResults" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRetrieveRoster" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterUpdated" scope="prototype"/>
      <method name="onSubscriptionRequest" scope="prototype">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPresenceUpdate" scope="prototype">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportReady" scope="prototype"/>
      <method name="onTransportTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onConnected" scope="prototype"/>
      <method name="onTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActive" scope="prototype"/>
      <method name="onRegisterChatInstance" scope="prototype">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterAdded" scope="prototype">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterRemoved" scope="prototype">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterChanged" scope="prototype">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
          <parameter name="previousCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processXmppError" scope="prototype">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendStanzaError" scope="prototype">
        <parameters>
          <parameter name="stanzaType" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="errorType" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBareJid" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceFromJid" scope="prototype">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
      <property name="roster" scope="prototype" type="Object"/>
      <property name="chatRegister" scope="prototype" type="Object"/>
      <property name="_iqId" scope="prototype" type="Object"/>
      <property name="jid" scope="instance" type="Object"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
      <property name="state" scope="instance" type="Object"/>
      <property name="useChatState" scope="instance" type="Object"/>
      <property name="rosterService" scope="instance" type="Object"/>
      <property name="presenceService" scope="instance" type="Object"/>
      <property name="userService" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover">
    <description>an object, which makes a node follow the mouse,
	used as a default mover, and as a base class for custom movers</description>
    <methods>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <description>makes the node absolute; it is meant to be called only once</description>
      </method>
      <method name="destroy" scope="prototype">
        <description>stops the move, deletes all references, so the object can be garbage-collected</description>
      </method>
    </methods>
    <properties>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Node">
        <description>a node (or node's id) to be moved</description>
      </property>
      <property name="host" scope="instance" type="Object?">
        <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.marginBox">
    <properties>
      <property name="l" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Selector" superclass="dojo.dnd.Container">
    <description>a constructor of the Selector</description>
    <methods>
      <method name="getSelectedNodes" scope="prototype">
        <description>returns a list (an array) of selected nodes</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="selectNone" scope="prototype">
        <description>unselects all items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectAll" scope="prototype">
        <description>selects all items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deleteSelectedNodes" scope="prototype">
        <description>deletes all selected items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="prototype">
        <description>iterates over selected items,
	see dojo.dnd.Container.forInItems() for details</description>
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="sync" scope="prototype">
        <description>synch up the node list with the data map</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <description>this function is called once, when mouse is over our container</description>
      </method>
      <method name="onOutEvent" scope="prototype">
        <description>this function is called once, when mouse is out of our container</description>
      </method>
      <method name="_removeSelection" scope="prototype">
        <description>unselects all items</description>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="prototype">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="singular" scope="instance-prototype" type="Boolean">
        <description>allows selection of only one element, if true
	the rest of parameters are passed to the container</description>
      </property>
      <property name="anchor" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_normalizedCreator" scope="instance" type="Object"/>
      <property name="simpleSelection" scope="instance" type="Object"/>
      <property name="onmousemoveEvent" scope="instance" type="Object"/>
      <property name="autoSync" scope="instance" type="Boolean">
        <description>autosynchronizes the source with its list of DnD nodes,
	false by default</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Selector.insertNodes">
    <description>inserts new data items (see Container's insertNodes method for details)</description>
    <methods>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="dojo.dnd.Selector.superclass.insertNodes" scope="instance"/>
    </mixins>
    <properties>
      <property name="anchor" scope="instance" type="Node">
        <description>the anchor node to be used as a point of insertion</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Source" superclass="dojo.dnd.Selector">
    <description>a constructor of the Source</description>
    <methods>
      <method name="checkAcceptance" scope="prototype">
        <description>checks, if the target can accept nodes from this source</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="prototype">
        <description>Returns true, if we need to copy items, false to move.
	It is separated to be overwritten dynamically, if needed.</description>
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>the &amp;quot;copy&amp;quot; was pressed</description>
          </parameter>
          <parameter name="self" type="Boolean" usage="optional">
            <description>optional flag, which means that we are about to drop on itself</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <description>prepares the object to be garbage-collected</description>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <description>event processor for onmousemove</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <description>event processor for onmousedown</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <description>event processor for onmouseup</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="prototype">
        <description>topic event processor for /dnd/source/over, called when detected a current source</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="prototype">
        <description>topic event processor for /dnd/start, called to initiate the DnD operation</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndDrop" scope="prototype">
        <description>topic event processor for /dnd/drop, called to finish the DnD operation</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
          <parameter name="target" type="Object" usage="required">
            <description>the target which accepts items</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <description>topic event processor for /dnd/cancel, called to cancel the DnD operation</description>
      </method>
      <method name="onDrop" scope="prototype">
        <description>called only on the current target, when drop is performed</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="prototype">
        <description>called during the active DnD operation, when items
	are dragged over this target, and it is not disabled</description>
      </method>
      <method name="onDraggingOut" scope="prototype">
        <description>called during the active DnD operation, when items
	are dragged away from this target, and it is not disabled</description>
      </method>
      <method name="onOverEvent" scope="prototype">
        <description>this function is called once, when mouse is over our container</description>
      </method>
      <method name="onOutEvent" scope="prototype">
        <description>this function is called once, when mouse is out of our container</description>
      </method>
      <method name="_markTargetAnchor" scope="prototype">
        <description>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status</description>
        <parameters>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before, if true, after otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <description>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status</description>
      </method>
      <method name="_markDndStatus" scope="prototype">
        <description>changes source's state based on &amp;quot;copy&amp;quot; status</description>
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="prototype">
        <description>checks if user clicked on &amp;quot;approved&amp;quot; items</description>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="isSource" scope="prototype" type="Object"/>
      <property name="horizontal" scope="prototype" type="Object"/>
      <property name="copyOnly" scope="prototype" type="Object"/>
      <property name="selfCopy" scope="prototype" type="Object"/>
      <property name="selfAccept" scope="prototype" type="Object"/>
      <property name="skipForm" scope="prototype" type="Object"/>
      <property name="withHandles" scope="prototype" type="Object"/>
      <property name="autoSync" scope="prototype" type="Object"/>
      <property name="delay" scope="prototype" type="Object"/>
      <property name="accept" scope="instance-prototype" type="Object"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="targetState" scope="instance" type="Object"/>
      <property name="targetBox" scope="instance" type="Object"/>
      <property name="mouseDown" scope="instance" type="Object"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="_normalizedCreator" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="sourceState" scope="instance" type="Object"/>
      <property name="topics" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Source.onDropExternal">
    <description>called only on the current target, when drop is performed
	from an external source</description>
    <methods>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.dnd.Source.onDropInternal">
    <description>called only on the current target, when drop is performed
	from the same target/source</description>
    <methods>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.dnd.Target" superclass="dojo.dnd.Source">
    <description>a constructor of the Target --- see the Source constructor for details</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.AutoSource" superclass="dojo.dnd.Source">
    <description>a constructor of the AutoSource --- see the Source constructor for details</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.__SourceArgs">
    <description>a dict of parameters for DnD Source configuration. Note that any
	property on Source elements may be configured, but this is the
	short-list</description>
    <properties>
      <property name="isSource" scope="instance" type="Boolean?">
        <description>can be used as a DnD source. Defaults to true.</description>
      </property>
      <property name="accept" scope="instance" type="Array?">
        <description>list of accepted types (text strings) for a target; defaults to
	[&amp;quot;text&amp;quot;]</description>
      </property>
      <property name="autoSync" scope="instance" type="Boolean">
        <description>if true refreshes the node list on every operation; false by default</description>
      </property>
      <property name="copyOnly" scope="instance" type="Boolean?">
        <description>copy items, if true, use a state of Ctrl key otherwise,
	see selfCopy and selfAccept for more details</description>
      </property>
      <property name="delay" scope="instance" type="Number">
        <description>the move delay in pixels before detecting a drag; 0 by default</description>
      </property>
      <property name="horizontal" scope="instance" type="Boolean?">
        <description>a horizontal container, if true, vertical otherwise or when omitted</description>
      </property>
      <property name="selfCopy" scope="instance" type="Boolean?">
        <description>copy items by default when dropping on itself,
	false by default, works only if copyOnly is true</description>
      </property>
      <property name="selfAccept" scope="instance" type="Boolean?">
        <description>accept its own items when copyOnly is true,
	true by default, works only if copyOnly is true</description>
      </property>
      <property name="withHandles" scope="instance" type="Boolean?">
        <description>allows dragging only by handles, false by default</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.TimedMoveable" superclass="dojo.dnd.Moveable">
    <description>an object, which makes a node moveable with a timer</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="timeout" scope="instance-prototype" type="Number">
        <description>delay move by this number of ms
	accumulating position changes during the timeout
	sanitize parameters</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd._validNodes">
    <properties>
      <property name="div" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="td" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd._validOverflow">
    <properties>
      <property name="auto" scope="instance" type="Object"/>
      <property name="scroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move">
    <methods>
      <method name="constrainedMover" scope="instance">
        <description>returns a constrained version of dojo.dnd.Mover</description>
        <parameters>
          <parameter name="fun" type="Function" usage="required">
            <description>called on drag, and returns a constraint box</description>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <description>if true, constraints the whole dragged object withtin the rectangle,
	otherwise the constraint is applied to the left-top corner</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="boxConstrainedMover" scope="instance">
        <description>a specialization of dojo.dnd.constrainedMover, which constrains to the specified box</description>
        <parameters>
          <parameter name="box" type="Object" usage="required">
            <description>a constraint box (l, t, w, h)</description>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <description>if true, constraints the whole dragged object withtin the rectangle,
	otherwise the constraint is applied to the left-top corner</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parentConstrainedMover" scope="instance">
        <description>a specialization of dojo.dnd.constrainedMover, which constrains to the parent node</description>
        <parameters>
          <parameter name="area" type="String" usage="required">
            <description>&amp;quot;margin&amp;quot; to constrain within the parent's margin box, &amp;quot;border&amp;quot; for the border box,
	&amp;quot;padding&amp;quot; for the padding box, and &amp;quot;content&amp;quot; for the content box; &amp;quot;content&amp;quot; is the default value.</description>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <description>if true, constraints the whole dragged object withtin the rectangle,
	otherwise the constraint is applied to the left-top corner</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.dnd.move.constrainedMoveable" superclass="dojo.dnd.Moveable">
    <description>an object, which makes a node moveable</description>
    <methods>
      <method name="constraints" scope="instance-prototype">
        <description>a function, which calculates a constraint box,
	it is called in a context of the moveable object.</description>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <description>called during the very first move notification,
	can be used to initialize coordinates, can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <description>called during every move notification,
	should actually move the node, can be overwritten.</description>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="within" scope="instance-prototype" type="Boolean">
        <description>restrict move within boundaries.
	the rest is passed to the base class</description>
      </property>
      <property name="constraintBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.boxConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <description>an object, which makes a node moveable</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constraints" scope="instance"/>
    </methods>
    <properties>
      <property name="box" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <description>an object, which makes a node moveable</description>
    <methods>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constraints" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="area" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="script">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.fx">
    <description>Effects library on top of Base animations</description>
    <methods>
      <method name="wipeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <example>summary
	Returns an animation that will slide "node"
	defined in args Object from its current position to
	the position defined by (args.left, args.top).
		dojo.fx.slideTo({ node: node, left:"40", top:"50", unit:"px" }).play()</example>
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="chain" scope="instance">
        <description>Chain a list of dojo._Animation s to run in sequence</description>
        <example>
		dojo.fx.chain([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
        <parameters>
          <parameter name="animations" type="dojo._Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="combine" scope="instance">
        <description>Combine a list of dojo._Animation s to run in parallel</description>
        <example>
		dojo.fx.combine([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
        <parameters>
          <parameter name="animations" type="dojo._Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.fx.easing">
    <description>Collection of easing functions to use beyond the default dojo._defaultEasing</description>
    <example>
		dojo.require("dojo.fx.easing");
		var anim = dojo.fadeOut({
			node: 'node',
			duration: 2000,
			easing: dojo.fx.easing.quadIn
		}).play();</example>
    <methods>
      <method name="linear" scope="instance">
        <description>A linear easing function</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backIn" scope="instance">
        <description>An easing function that starts away from the target, and
	quickly accelerates towards the end value</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backOut" scope="instance">
        <description>An easing function that pops past the range briefly, and
	slowly comes back.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backInOut" scope="instance">
        <description>An easing function combining the effects of backIn and backOut</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticIn" scope="instance">
        <description>An easing function the elastically snaps from the start value</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticOut" scope="instance">
        <description>An easing function that elasticly snaps around the target value, near the end of the Animation</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticInOut" scope="instance">
        <description>An easing function that elasticly snaps around the value, near the beginning and end of the Animation</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceIn" scope="instance">
        <description>An easing function that &amp;quot;bounces&amp;quot; near the beginning of an Animation</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="bounceOut" scope="instance">
        <description>An easing function that &amp;quot;bounces&amp;quot; near the end of an Animation</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceInOut" scope="instance">
        <description>An easing function that &amp;quot;bounces&amp;quot; at the beginning and end of the Animation</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.fx.Toggler">
    <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc.</description>
    <example>
		var t = new dojo.fx.Toggler({
			node: "nodeId",
			showDuration: 500,
			// hideDuration will default to "200"
			showFunc: dojo.wipeIn,
			// hideFunc will default to "fadeOut"
		});
		t.show(100); // delay showing for 100ms
		// ...time passes...
		t.hide();</example>
    <methods>
      <method name="showFunc" scope="prototype">
        <description>The function that returns the dojo._Animation to show the node</description>
      </method>
      <method name="hideFunc" scope="prototype">
        <description>The function that returns the dojo._Animation to hide the node</description>
      </method>
      <method name="show" scope="prototype">
        <description>Toggle the node to showing</description>
        <parameters>
          <parameter name="delay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="prototype">
        <description>Toggle the node to hidden</description>
        <parameters>
          <parameter name="delay" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="prototype" type="DomNode">
        <description>the node to toggle</description>
      </property>
      <property name="showDuration" scope="prototype" type="Time">
        <description>in milliseconds to run the show Animation</description>
      </property>
      <property name="hideDuration" scope="prototype" type="Time">
        <description>in milliseconds to run the hide Animation</description>
      </property>
      <property name="_showArgs" scope="prototype" type="Object"/>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideArgs" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_isShowing" scope="prototype" type="Object"/>
      <property name="_isHiding" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.gears">
    <methods>
      <method name="_gearsObject" scope="instance">
        <description>factory method to get a Google Gears plugin instance to
	expose in the browser runtime environment, if present</description>
        <return-types>
          <return-type type="already defined elsewhere"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="Object">
        <description>True if client is using Google Gears</description>
      </property>
    </properties>
  </class>
  <class type="dojo.html">
    <methods>
      <method name="_secureForInnerHtml" scope="instance">
        <description>removes !DOCTYPE and title elements from the html string.
	khtml is picky about dom faults, you can't attach a style or &amp;lt;title&amp;gt; node as child of body
	must go into head, so we need to cut out those tags</description>
        <parameters>
          <parameter name="cont" type="String" usage="required">
            <description>An html string for insertion into the dom</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_emptyNode" scope="instance">
        <description>removes all child nodes from the given node</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNodeContent" scope="instance">
        <description>inserts the given content into the given node
	overlaps similiar functionality in dijit.layout.ContentPane._setContent</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element
	content:
	the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
	shouldEmptyFirst
	if shouldEmptyFirst is true, the node will first be emptied of all content before the new content is inserted
	defaults to false</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
          <parameter name="shouldEmptyFirst" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>inserts (replaces) the given content into the given node</description>
        <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element that will receive the content</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <description>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.html._ContentSetter">
    <description>Provides a configurable, extensible object to wrap the setting on content on a node
	call the set() method to actually set the content..
	the original params are mixed directly into the instance &amp;quot;this&amp;quot;</description>
    <methods>
      <method name="set" scope="prototype">
        <description>front-end to the set-content sequence</description>
        <parameters>
          <parameter name="cont" type="String|DomNode|NodeList" usage="optional">
            <description>An html string, node or enumerable list of nodes for insertion into the dom
	If not provided, the object's content property will be used</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <description>sets the content on the node</description>
      </method>
      <method name="empty" scope="prototype"/>
      <method name="onBegin" scope="prototype">
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="onEnd" scope="prototype">
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="tearDown" scope="prototype"/>
      <method name="onContentError" scope="prototype">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="prototype">
        <description>runs the dojo parser over the node contents, storing any results in this.parseResults
	Any errors resulting from parsing are passed to _onError for handling</description>
      </method>
      <method name="_onError" scope="prototype">
        <description>shows user the string that is returned by on[type]Error
	overide/implement on[type]Error and return your own string to customize</description>
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance-prototype" type="DomNode|String">
        <description>An node which will be the parent element that we set content into</description>
      </property>
      <property name="content" scope="instance-prototype" type="String|DomNode|DomNode[]">
        <description>The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes</description>
      </property>
      <property name="id" scope="instance-prototype" type="String?">
        <description>Usually only used internally, and auto-generated with each instance</description>
      </property>
      <property name="cleanContent" scope="prototype" type="Boolean">
        <description>Should the content be treated as a full html document,
	and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</description>
      </property>
      <property name="extractContent" scope="prototype" type="Boolean">
        <description>Should the content be treated as a full html document, and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</description>
      </property>
      <property name="parseContent" scope="prototype" type="Boolean">
        <description>Should the node by passed to the parser after the new content is set</description>
      </property>
      <property name="parseResults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.i18n">
    <description>Utility classes to enable loading of resources for internationalization (i18n)</description>
    <methods>
      <method name="getLocalization" scope="instance">
        <description>Returns an Object containing the localization for a given resource
	bundle in a package, matching the specified locale.</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required">
            <description>package which is associated with this resource</description>
          </parameter>
          <parameter name="bundleName" type="String" usage="required">
            <description>the base filename of the resource bundle (without the &amp;quot;.js&amp;quot; suffix)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>the variant to load (optional).  By default, the locale defined by
	the host environment: dojo.locale</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalizeLocale" scope="instance">
        <description>Returns canonical form of locale, as used by Dojo.</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_requireLocalization" scope="instance">
        <description>See dojo.requireLocalization()</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="optional"/>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_searchLocalePath" scope="instance">
        <description>A helper method to assist in searching for locale-based resources.
	Will iterate through the variants of a particular locale, either up
	or down, executing a callback function.  For example, &amp;quot;en-us&amp;quot; and
	true will try &amp;quot;en-us&amp;quot; followed by &amp;quot;en&amp;quot; and finally &amp;quot;ROOT&amp;quot;.</description>
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
          <parameter name="down" type="Boolean" usage="required"/>
          <parameter name="searchFunc" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_preloadLocalizations" scope="instance">
        <description>Load built, flattened resource bundles, if available for all
	locales used in the page. Only called by built layer files.</description>
        <parameters>
          <parameter name="bundlePrefix" type="String" usage="required"/>
          <parameter name="localesGenerated" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.io.iframe">
    <methods>
      <method name="__ioArgs" scope="instance">
        <description>All the properties described in the dojo.__ioArgs type, apply
	to this type. The following additional properties are allowed
	for dojo.io.iframe.send():</description>
      </method>
      <method name="create" scope="instance">
        <description>Creates a hidden iframe in the page. Used mostly for IO
	transports.  You do not need to call this to start a
	dojo.io.iframe request. Just call send().</description>
        <parameters>
          <parameter name="fname" type="String" usage="required">
            <description>The name of the iframe. Used for the name attribute on the
	iframe.</description>
          </parameter>
          <parameter name="onloadstr" type="String" usage="required">
            <description>A string of JavaScript that will be executed when the content
	in the iframe loads.</description>
          </parameter>
          <parameter name="uri" type="String" usage="optional">
            <description>The value of the src attribute on the iframe element. If a
	value is not given, then dojo/resources/blank.html will be
	used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSrc" scope="instance">
        <description>Sets the URL that is loaded in an IFrame. The replace parameter
	indicates whether location.replace() should be used when
	changing the location of the iframe.</description>
        <parameters>
          <parameter name="iframe" type="DOMNode" usage="required"/>
          <parameter name="src" type="String" usage="required"/>
          <parameter name="replace" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="doc" scope="instance">
        <description>Returns the document object associated with the iframe DOM Node argument.</description>
        <parameters>
          <parameter name="iframeNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="instance">
        <description>function that sends the request to the server.
	This transport can only process one send() request at a time, so if send() is called
	multiple times, it will queue up the calls and only process one at a time.</description>
        <parameters>
          <parameter name="args" type="dojo.io.iframe.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeOnload" scope="instance"/>
    </methods>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
      <property name="_dfdQueue" scope="instance" type="Object"/>
      <property name="_iframeName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io">
    <description>Additional I/O transports (Ajax)</description>
  </class>
  <class type="dojo.io.iframe._fireNextRequest">
    <description>Internal method used to fire the next request in the bind queue.</description>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._fireNextRequest._dfdQueue">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.script._jsonpCallback">
    <description>generic handler for jsonp callback. A pointer to this function
	is used for all jsonp callbacks.  NOTE: the &amp;quot;this&amp;quot; in this
	function will be the Deferred object that represents the script
	request.</description>
  </class>
  <class type="dojo.io.script._jsonpCallback.ioArgs">
    <properties>
      <property name="json" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.number">
    <description>localized formatting and parsing routines for Number</description>
    <methods>
      <method name="format" scope="instance">
        <description>Format a Number as a String, using locale-specific settings</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.  If not a valid JavaScript number,
	return null.</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_applyPattern" scope="instance">
        <description>Apply pattern to format value as a string using options. Gives no
	consideration to local customs.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>a pattern string as described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <description>_applyPattern is usually called via `dojo.number.format()` which
	populates an extra property in the options parameter, &amp;quot;customs&amp;quot;.
	The customs object specifies group and decimal parameters if set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="round" scope="instance">
        <description>Rounds the number at the given number of places</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to round</description>
          </parameter>
          <parameter name="places" type="Number" usage="required">
            <description>the number of decimal places where rounding takes place</description>
          </parameter>
          <parameter name="multiple" type="Number" usage="optional">
            <description>rounds next place to nearest multiple</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_formatAbsolute" scope="instance">
        <description>Apply numeric pattern to absolute value using options. Gives no
	consideration to local customs.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted, ignores sign</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>the number portion of a pattern (e.g. `#,##0.00`)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatAbsoluteOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Builds the regular needed to parse a number</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Convert a properly formatted string to a primitive Number, using
	locale-specific settings.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a Number</description>
          </parameter>
          <parameter name="options" type="dojo.number.__ParseOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="NaN"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_realNumberRegexp" scope="instance">
        <description>Builds a regular expression to match a real number in exponential
	notation</description>
        <parameters>
          <parameter name="flags" type="dojo.number.__RealNumberRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_integerRegexp" scope="instance">
        <description>Builds a regular expression that matches an integer</description>
        <parameters>
          <parameter name="flags" type="dojo.number.__IntegerRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_numberPatternRE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.number.__FormatOptions">
    <properties>
      <property name="pattern" scope="instance" type="String?">
        <description>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string</description>
      </property>
      <property name="type" scope="instance" type="String?">
        <description>choose a format type based on the locale from the following:
	decimal, scientific, percent, currency. decimal by default.</description>
      </property>
      <property name="places" scope="instance" type="Number?">
        <description>fixed number of decimal places to show.  This overrides any
	information in the provided pattern.</description>
      </property>
      <property name="round" scope="instance" type="Number?">
        <description>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means don't round.</description>
      </property>
      <property name="currency" scope="instance" type="String?">
        <description>an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;</description>
      </property>
      <property name="symbol" scope="instance" type="String?">
        <description>localized currency symbol</description>
      </property>
      <property name="locale" scope="instance" type="String?">
        <description>override the locale used to determine formatting rules</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__FormatAbsoluteOptions">
    <properties>
      <property name="decimal" scope="instance" type="String?">
        <description>the decimal separator</description>
      </property>
      <property name="group" scope="instance" type="String?">
        <description>the group separator</description>
      </property>
      <property name="places" scope="instance" type="Integer?|String?">
        <description>number of decimal places.  the range &amp;quot;n,m&amp;quot; will format to m places.</description>
      </property>
      <property name="round" scope="instance" type="Number?">
        <description>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means don't round.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__RegexpOptions">
    <properties>
      <property name="pattern" scope="instance" type="String?">
        <description>override pattern with this string.  Default is provided based on
	locale.</description>
      </property>
      <property name="type" scope="instance" type="String?">
        <description>choose a format type based on the locale from the following:
	decimal, scientific, percent, currency. decimal by default.</description>
      </property>
      <property name="locale" scope="instance" type="String?">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="strict" scope="instance" type="Boolean?">
        <description>strict parsing, false by default</description>
      </property>
      <property name="places" scope="instance" type="Number|String?">
        <description>number of decimal places to accept: Infinity, a positive number, or
	a range &amp;quot;n,m&amp;quot;.  Defined by pattern or Infinity if pattern not provided.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__ParseOptions">
    <properties>
      <property name="pattern" scope="instance" type="String">
        <description>override pattern with this string.  Default is provided based on
	locale.</description>
      </property>
      <property name="type" scope="instance" type="String?">
        <description>choose a format type based on the locale from the following:
	decimal, scientific, percent, currency. decimal by default.</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="strict" scope="instance" type="Boolean?">
        <description>strict parsing, false by default</description>
      </property>
      <property name="currency" scope="instance" type="Object">
        <description>object with currency information</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__RealNumberRegexpFlags">
    <properties>
      <property name="places" scope="instance" type="Number?">
        <description>The integer number of decimal places or a range given as &amp;quot;n,m&amp;quot;.  If
	not given, the decimal part is optional and the number of places is
	unlimited.</description>
      </property>
      <property name="decimal" scope="instance" type="String?">
        <description>A string for the character used as the decimal point.  Default
	is &amp;quot;.&amp;quot;.</description>
      </property>
      <property name="fractional" scope="instance" type="Boolean|Array?">
        <description>Whether decimal places are allowed.  Can be true, false, or [true,
	false].  Default is [true, false]</description>
      </property>
      <property name="exponent" scope="instance" type="Boolean|Array?">
        <description>Express in exponential notation.  Can be true, false, or [true,
	false]. Default is [true, false], (i.e. will match if the
	exponential part is present are not).</description>
      </property>
      <property name="eSigned" scope="instance" type="Boolean|Array?">
        <description>The leading plus-or-minus sign on the exponent.  Can be true,
	false, or [true, false].  Default is [true, false], (i.e. will
	match if it is signed or unsigned).  flags in regexp.integer can be
	applied.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__IntegerRegexpFlags">
    <properties>
      <property name="signed" scope="instance" type="Boolean?">
        <description>The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	Default is `[true, false]`, (i.e. will match if it is signed
	or unsigned).</description>
      </property>
      <property name="separator" scope="instance" type="String?">
        <description>The character used as the thousands separator. Default is no
	separator. For more than one symbol use an array, e.g. `[&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;]`,
	makes ',' optional.</description>
      </property>
      <property name="groupSize" scope="instance" type="Number?">
        <description>group size between separators</description>
      </property>
      <property name="groupSize2" scope="instance" type="Number?">
        <description>second grouping, where separators 2..n have a different interval than the first separator (for India)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.parser">
    <description>The Dom/Widget parsing package</description>
    <methods>
      <method name="_functionFromScript" scope="instance">
        <parameters>
          <parameter name="script" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="instantiate" scope="instance">
        <description>Takes array of nodes, and turns them into class instances and
	potentially calls a layout method to allow them to connect with
	any children</description>
        <parameters>
          <parameter name="nodes" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <description>Search specified node (or root node) recursively for class instances,
	and instantiate them Searches for
	dojoType=&amp;quot;qualified.class.name&amp;quot;</description>
        <parameters>
          <parameter name="rootNode" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="_nameAnonFunc" scope="instance">
        <description>Creates a reference to anonFuncPtr in thisObj with a completely
	unique name. The new name is returned as a String.</description>
        <parameters>
          <parameter name="anonFuncPtr" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="prototype">
      <mixin type="func" scope="instance"/>
    </mixins>
    <properties>
      <property name="_anon" scope="instance" type="Object"/>
      <property name="_anonCtr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.regexp">
    <description>Regular expressions and Builder resources</description>
    <methods>
      <method name="escapeString" scope="instance">
        <description>Adds escape sequences for special characters in regular expressions</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="except" type="String" usage="optional">
            <description>a String with special characters to be left unescaped</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildGroupRE" scope="instance">
        <description>Builds a regular expression that groups subexpressions</description>
        <parameters>
          <parameter name="arr" type="Object|Array" usage="required">
            <description>A single value or an array of values.</description>
          </parameter>
          <parameter name="re" type="Function" usage="required">
            <description>A function. Takes one parameter and converts it to a regular
	expression.</description>
          </parameter>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression. Defaults to false</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="group" scope="instance">
        <description>adds group match to expression</description>
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.resources">
    <properties>
      <property name="_modules" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="doh.robot">
    <methods>
      <method name="_scrollIntoView" scope="instance">
        <description>Scroll the passed node into view, if it is not.
	Stub to be replaced dijit.robot.</description>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <description>Scroll the passed node into view, if it is not.</description>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Number, optional" usage="required">
            <description>Delay in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.</description>
          </parameter>
        </parameters>
      </method>
      <method name="mouseMoveAt" scope="instance">
        <description>Moves the mouse over the specified node at the specified relative x,y offset.</description>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Integer, optional" usage="required">
            <description>Delay in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.
	For example, the following code ends after 600ms:
	doh.mouseClick({left:true}, 100) // first call; wait 100ms
	doh.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all</description>
          </parameter>
          <parameter name="duration" type="Integer, optional" usage="required">
            <description>Approximate time Robot will spend moving the mouse
	The default is 100ms.</description>
          </parameter>
          <parameter name="offsetX" type="Number, optional" usage="required">
            <description>x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.</description>
          </parameter>
          <parameter name="offsetY" type="Number, optional" usage="required">
            <description>y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateDocument" scope="instance"/>
      <method name="initRobot" scope="instance">
        <description>Opens the application at the specified URL for testing, redirecting dojo to point to the application environment instead of the test environment.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.</description>
          </parameter>
        </parameters>
      </method>
      <method name="waitForPageToLoad" scope="instance">
        <description>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.</description>
        <parameters>
          <parameter name="submitActions" type="Function" usage="required">
            <description>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
	expecting these actions to create a page change (like a form submit).
	After these actions execute and the resulting page loads, the next test will start.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.rpc">
    <description>Dojo remote-procedure-call resources</description>
  </class>
  <class type="dojo.rpc.JsonService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="callRemote" scope="prototype">
        <description>call an arbitrary remote method without requiring it to be
	predefined with SMD</description>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>the name of the remote method you want to call.</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>of parameters to pass to method</description>
          </parameter>
        </parameters>
      </method>
      <method name="bind" scope="prototype">
        <description>JSON-RPC bind method. Takes remote method, parameters,
	deferred, and a url, calls createRequest to make a JSON-RPC
	envelope and passes that off with bind.</description>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="prototype">
        <description>create a JSON-RPC envelope for the request</description>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are creating the requst for</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>The array of parameters for this request;</description>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="prototype">
        <description>parse the result envelope and pass the results back to
	the callback function</description>
        <parameters>
          <parameter name="obj" type="anything" usage="required">
            <description>Object Object containing envelope of data we recieve from the server</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="bustCache" scope="prototype" type="Object"/>
      <property name="contentType" scope="prototype" type="Object"/>
      <property name="lastSubmissionId" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.rpc.JsonpService" superclass="dojo.rpc.RpcService">
    <description>Generic JSONP service.  Minimally extends RpcService to allow
	easy definition of nearly any JSONP style service. Example
	SMD files exist in dojox.data</description>
    <methods>
      <method name="bind" scope="prototype">
        <description>JSONP bind method. Takes remote method, parameters,
	deferred, and a url, calls createRequest to make a JSON-RPC
	envelope and passes that off with bind.</description>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="prototype">
        <description>create a JSONP req
	params: array
	The array of parameters for this request;</description>
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="strictArgChecks" scope="prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.rpc.RpcService">
    <description>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</description>
    <methods>
      <method name="parseResults" scope="prototype">
        <parameters>
          <parameter name="obj" type="summary" usage="required">
            <description>parse the results coming back from an rpc request.  this
	base implementation, just returns the full object
	subclasses should parse and only return the actual results
	Object
	Object that is the return results from an rpc request</description>
          </parameter>
        </parameters>
      </method>
      <method name="errorCallback" scope="prototype">
        <description>create callback that calls the Deferres errback method</description>
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="resultCallback" scope="prototype">
        <description>create callback that calls the Deferred's callback method</description>
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateMethod" scope="prototype">
        <description>generate the local bind methods for the remote object</description>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are generating</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>the array of parameters for this call.</description>
          </parameter>
          <parameter name="url" type="string" usage="required">
            <description>the service url for this call</description>
          </parameter>
        </parameters>
      </method>
      <method name="processSmd" scope="prototype">
        <description>callback method for reciept of a smd object.  Parse the smd
	and generate functions based on the description</description>
        <parameters>
          <parameter name="object" type="smd" usage="required">
            <description>object defining this service.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="strictArgChecks" scope="instance-prototype" type="Object"/>
      <property name="serviceUrl" scope="instance-prototype" type="Object"/>
      <property name="required" scope="instance" type="Object"/>
      <property name="smd" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.string">
    <description>String utilities for Dojo</description>
    <methods>
      <method name="rep" scope="instance">
        <description>Efficiently replicate a string `n` times.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>the string to replicate</description>
          </parameter>
          <parameter name="num" type="Integer" usage="required">
            <description>number of times to replicate the string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="pad" scope="instance">
        <description>Pad a string to guarantee that it is at least `size` length by
	filling with the character `ch` at either the start or end of the
	string. Pads at the start, by default.</description>
        <example>
	
		// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
		dojo.string.pad("Dojo", 10, "+", true);</example>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>the string to pad</description>
          </parameter>
          <parameter name="size" type="Integer" usage="required">
            <description>length to provide padding</description>
          </parameter>
          <parameter name="ch" type="String" usage="optional">
            <description>character to pad, defaults to '0'</description>
          </parameter>
          <parameter name="end" type="Boolean" usage="optional">
            <description>adds padding at the end if true, otherwise pads at start</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="substitute" scope="instance">
        <description>Performs parameterized substitutions on a string. Throws an
	exception if any parameter is unmatched.</description>
        <example>
	
		// returns "File 'foo.html' is not found in directory '/temp'."
		dojo.string.substitute(
			"File '${0}' is not found in directory '${1}'.",
			["foo.html","/temp"]
		);
	
		// also returns "File 'foo.html' is not found in directory '/temp'."
		dojo.string.substitute(
			"File '${name}' is not found in directory '${info.dir}'.",
			{ name: "foo.html", info: { dir: "/temp" } }
		);</example>
        <parameters>
          <parameter name="template" type="String" usage="required">
            <description>a string with expressions in the form `${key}` to be replaced or
	`${key:format}` which specifies a format function.</description>
          </parameter>
          <parameter name="map" type="Object|Array" usage="required">
            <description>hash to search for substitutions</description>
          </parameter>
          <parameter name="transform" type="Function" usage="optional">
            <description>a function to process all parameters before substitution takes
	place, e.g. dojo.string.encodeXML</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>where to look for optional format function; default to the global
	namespace</description>
          </parameter>
        </parameters>
      </method>
      <method name="trim" scope="instance">
        <description>trims whitespaces from both sides of the string</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
</javascript>
